// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Copyright (c) 2016, Laird                                                  ++
//                                                                            ++
// Permission to use, copy, modify, and/or distribute this software for any   ++
// purpose with or without fee is hereby granted, provided that the above     ++
// copyright notice and this permission notice appear in all copies.          ++
//                                                                            ++
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES   ++
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF           ++
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR    ++
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES     ++
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN      ++
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR ++
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.                ++
//                                                                            ++
// SPDX-License-Identifier:ISC                                                ++
//                                                                            ++
// <description>                                                              ++
//                                                                            ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app to the module it will be saved    ++
// +++++  as a file with filename $autorun$ which means it will run           ++
// +++++  automatically on reset.                                             ++
// +++++  The File System can be queried using the command AT+DIR             ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// -------------------
// Application Version
// -------------------
#define AppVer                 "1.01"                             //Application version
#define AppUpdated             "30/Nov/2016"                      //Application last updated
//
// -------------------
// Application History
// -------------------
// 1.01 "30/Nov/2016"
//    Bug Fix: DeviceNameConfigMinLen was bing used instead of LoginPswrdConfigMinLen
//             when checking for password. However, since that value is 1 it is 
//             relatively benign
//    On BL600 default baudrate is now 9600 instead of 115200
//
// 1.00 "28/Nov/2016"
//    Initial Release. @7.5ms conn interval
//       Throughput : 10.5kbps  Client->Server
//                    64kbps    Server->Client
//
//******************************************************************************
// -----------
// Usage Guide
// -----------
//
// ~~~~~~~~~
// Overview
// ~~~~~~~~~
//
// This application provides a Virtual Serial Port Service which bridges the uart
// to the air-side BLE VSP.
// 
// On start/power up, for the first 60 seconds it will accept a password which by
// default is "@command_mode@" and if received from either the uart or vsp, then 
// it will fall into configuration mode so that the application can be configured
// using a text command api as described below and the new configuration is 
// automatically saved in non-volatile memory.
//
// (To reset configuration, enter config mode, enter the command 'exit' which will
//  result in the module entering the native command mode and then enter the
//  command   AT&F 0xFFFFFFFE and the non-volatile data and bonding data will be 
//  deleted and automatically reset and re-enter the application)
// 
// It is also possible to enable encrypted VSP operation and for now only 'Just Works'
// pairing is recomended as the support for MITM protection is not provided but will
// be added at a later release of this application
//  
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Compile time configuration
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// The features (including debugging ones) of this application can be adjusted
// by setting a bitmask specified via the "#set $cmpif" statement which one 
// can search for below. Details of which bit does what is specified near that
// statement and will not be repeated here.
// 
// Suffice to say that the compilation bitmask, as shipped, allows for the 
// config mode to be accessed over the VSP connection within the 60 seconds
// of reset.
// 
// For security reasons the user is encouraged to consider if the ability to
// capture the config mode over the air is a risk not worth taking. In that
// case clear the appropriate bit in the "#set $cmpif" statement. At the very
// least, if the feature is not disabled, then it is highly recommended that
// the Login Password be changed via command "cfg$ wr 1 newpassword"
//
// In a similar manner it is also recommended that the 'exit' command is 
// disabled in a similar manner.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  DEBUGGING :: Upper 16 bits of the compilation bitmask
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// There is a bit dedicated to using LED1 when a connection is up which is 
// useful for debugging.
// 
// In addition there is a compilation bitmask which can be enabled to
// indicate whether the application is in config on bridge mode via LED2. 
// That same led will be flashed if there is an error.
//
// Finally, bit 31 (0x80000000) is very useful for debugging as it enables 
// very verbose messages that are output via the uart as things happen.
// All debuggin messages sent this ways start with "\n## " to facilitate
// differentiation from normal traffic
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Indication via general purpose I/O
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// It is possible to use two digital output pins to indicate that there is
// a connection and that the connection is encrypted.
// 
// The config key 9 is used to specify a SIO pin number (0..31) which is will
// be set to 1 when there is a connection and 0 when there isn't. If the 
// config key is set to -1, then it is not enabled. Please be careful not to
// allocate a pin that is being used for UART activity
// 
// The config key 10 is used to specify a SIO pin number (0..31) which is will
// be set to 1 when the connection is encrypted and 0 when there isn't. If the 
// config key is set to -1, then it is not enabled. Please be careful not to
// allocate a pin that is being used for UART activity
// 
// Note that if both keys are set to the same pin number, then it implies that
// when encrypted VSP operation is required then that SIO pin will go high 
// only when data can be transferred.
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The commands in config mode are as follows in alphabetical order :-
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  
// addr
//   Outputs the mac address of the module
//   
// bridge
//   Use this command to exot config mode and into bridge mode so that if there 
//   is a connection, then any data arriving over the uart is conveyed to the 
//   peer and vice-versa any data coming over the air is output from the uart
//   
// cfg rd #INTid
//   Outputs the current integer value of configuration key #INTid
//     All the keys are described below
// 
// cfg$ rd #INTid
//   Outputs the current string value of configuration key #INTid
//     All the keys are described below
//   
// cfg wr #INTid #INTval
//   Writes new value #INTval to the integer configuration key #INTid.
//   If the value is invalid then it will be rejected. An OK response
//   implies it was accepted.
//     All the keys are described below
// 
// cfg$ wr #INTid #STRval
//   Writes new value #STRval to the integer configuration key #INTid.
//   If the value is invalid then it will be rejected. An OK response
//   implies it was accepted.
//   The string value #STRval, must be delimited with double quotes "
//   if the string contains whitespace
//     All the keys are described below
// 
// client
//   If in a connection, then the mac address of the peer is output, otherwise 
//   the message "NO-CONNECTION"
//   
// conninfo
//   If in a connection, then connection related information is output as follows:-
//      Interval=7500,SuperTout=500000,SlaveLatency=0,Encrypted
//      or
//      Interval=7500,SuperTout=500000,SlaveLatency=0,NotEncrypted
//   where the latter is for non-encrypted connections and the integer values will
//   be as per the connection setup.
//   If there is no connection otherwise the message "NO-CONNECTION"
// 
// erase
//   If the appropriate SIO pin is high, then the application will be deleted
//   and the module will be reset resulting it advertising so that it can be
//   connected to and over a non-encrypted virtual serial port service a new
//   application can be downloaded over the air
// 
// exit
//   Abort the application and enter the native command mode of the module
//   from where you could completely erase all non-volatile data, including
//   the application using the command AT&F* and then reload a new application
//   over the uart (or VSP if the appropriate pin is in the correct state
//   for the module to start advertising for a connection)
//   
// reset
//   Reset the module and if nAutorun is low, the application will restart
//   
// si #INTid
//   Outputs the value returned by SYSINFO(#INTid)
// 
// si$ #INTid
//   Outputs the value returned by SYSINFO$(#INTid)
//   
// ver
//   Outputs the application version info
//   
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Integer Configuration Keys (for commands "cfg rd" and "cfg wr")
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// 0 : Device Name Format
//        0    - The MAC address is not automatically appended to the device name
//        1..7 - The right most bytes of the max after conversion to hex are appended
//               Note: The number of characters appended is double this value
//               
// 1 : Transmit Power (dBm)              
//        -20..4 - The transmit power to use, nearest value in the actual power table
//                 will be used. In BL600/620 that means a value divisible by 4
//                 
// 2 : Encryption Wait Timeout (milliseconds)
//        1000..20000 - If encryption is enabled (see key 17) then on connection a
//                      timer is started and if the master has not enabled encryption
//                      by the this time times out, then the module will disconnect
//                      
// 3 : Advertising Interval (milliseconds)
//        20..10240 - This sets the advertising interval. Lower values results in
//                    more energy consumption and so will impact on battery life
//                    
// 4 : Minimum Connection Interval (microseconds)
//        7500.. 3998750 - This specifies the acceptable minimum connection interval
//                         Note longer values will impact throughput
//                         It must <= the maximum connection interval (see key 5)
//                         otherwise it will be rejected
//                    
// 5 : Maximum Connection Interval (microseconds)
//        7500.. 3998750 - This specifies the acceptable maximum connection interval
//                         Note longer values will impact throughput
//                         It must >= the minimum connection interval (see key 4)
//                         otherwise it will be rejected
// 
// 6 : Uart Baudrate
//        1200..1000000 - This is the baudrate for the UART interface
//        
// 7 : Uart Low Level TX Buffer Size
//        0..1024 - 0 will mean set the default. Values from 1 to 31 are invalid.
//        
// 8 : Uart Low Level RX Buffer Size
//        0..1024 - 0 will mean set the default. Values from 1 to 31 are invalid.
//                 
// 9 : Connection LED Indication gpio pin
//       -1..31 - This is the SIO pin to indicate that a connection exists.
//                A value of -1 implies do not indicate
//                Also see related key 10.
//                 
// 10 : Encryption LED Indication gpio pin
//       -1..31 - This is the SIO pin to indicate that the connection is encrypted.
//                A value of -1 implies do not indicate
//                Also see related key 9.
//                
// 11 : 16 bit offset UUID for TX Characteristic
// 12 : 16 bit offset UUID for RX Characteristic
// 13 : 16 bit offset UUID for MODEM_IN Characteristic
// 14 : 16 bit offset UUID for MODEM_OUT Characteristic
//       1..0xFFFF - These are the 16 bit offsets from the base of the VSP Service UUID
// 
// 15 : VSP Low Level TX Buffer Size
//        0..1024 - 0 will mean set the default. Values from 1 to XX are invalid.
//        
// 16 : VSP Low Level RX Buffer Size
//        0..1024 - 0 will mean set the default. Values from 1 to XX are invalid.
//        
// 17 : VSP Service Encryption Requirement (For BL652 only)
//        Bit 0 : Set for encryption required
//        Bit 1 : Set for MITM required  (Future enhancement, leave 0 for now)
//      Please note : 
//         (*) Do not set this to non-zero for BL600 as there is a known issue
//         (*) Do not set the MITM bit as it is for futue.
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// String Configuration Keys (for commands "cfg$ rd" and "cfg$ wr")
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// 0 : Login Password from Configuration Mode
//        Specify the password for entering configuration mode within 60 seconds
//        of a power cycle (or reset) which must be between 8 and 19 characters
//        long. 
//        The default password is "@command_mode@".
//        If this password is received from either the uart or the vsp 
//        connection, then bridge mode will be abandoned and config mode entered
//        
// 1 : Device Name
//        The default is "LAIRD BL652" which is the same as the inbuilt command
//        mode VSP service. If there are embedded spaces, then the double quote
//        must be used as delimiter
//        
// 2 : VSP Service 128bit UUID
//        This is the 128 bit UUID for the VSP service and used as a base for 
//        the 16 bit UUIDs (TX, RX, MODEMIN, MODEMOUT) which are specified via
//        keys 11,12,13,14 respectively.
//        The UUID has 16 bit offset of 1101 from the Laird Base UUID of
//                569a0000b87f490c92cb11ba5ea5167c
//        
//******************************************************************************
// Compiler/Debug options
//******************************************************************************

//   ======================================================
//   Conditional Compile Masks (they can be additive)
//   ------------------------------------------------------
//
// Lower 16 bits used for feature set
//   0x00000001 : Not used
//   0x00000002 : LED1: connection status (on = connected)
//   0x00000004 : LED2: Operation mode (ON = app config mode)
//   0x00000008 : LED2: flashes if fatal error occured
//   0x00000010 : Not used
//   0x00000020 : Allow config mode over UART
//   0x00000040 : Allow config mode over VSP
//   0x00000080 : Allow 'exit' command in command mode
//
// Upper 16 bits used for debugging
//   0x80000000 : Enable debugging messages
//   0x00010000 : Enable Asserts printed out of UART
//   ======================================================
#set $cmpif, 0x000000E0  //Allow configuration over UART & VSP & 'exit' command
//#set $cmpif, 0x000000A0  //Allow configuration over UART only & 'exit' command
//#set $cmpif, 0x00000040  //Allow configuration over UART only
//#set $cmpif, 0x0000FFFF  //All Features + NO debug messages
//#set $cmpif, 0xFFFFFFFF  //All Features + all debug messages
//
//******************************************************************************
// Definitions
//******************************************************************************

//Default selection if the BT address is appended to the advertised device name 
//   0 = BT Address not included 
//   1-7 = Last X bytes, which means 2X Charactes as they are converted to hex
#define DevNameFormatConfigDef   0      //0
    #define DevNameFormatConfigMin   0
    #define DevNameFormatConfigMax   7
//Default TX Power in dBm
#define TxPowerConfigDef         4      //1
    #define TxPowerConfigMin         -20
    #define TxPowerConfigMax         4
//Default disconnect time (if device does not encrypt connection - VSP flag must be set to encrypted) in ms
#define EncrDisconToutConfigDef  8000      //2
    #define EncrDisconToutConfigMin  1000
    #define EncrDisconToutConfigMax  20000
//Default Advertising interval (lower will raise the power consumption)
#define AdvertIntvlConfigDef     250      //3
    #define AdvertIntvlConfigMin     20
    #define AdvertIntvlConfigMax     10240
//Default Minimum connection interval
#define MinConnIntConfigDef      7500      //4
    #define MinConnIntConfigMin      7500
    #define MinConnIntConfigMax      3998750
//Default Maximum connection interval
#define MaxConnIntConfigDef       40000      //5
    #define MaxConnIntConfigMin      7500
    #define MaxConnIntConfigMax      3998750
//Default UART baud rate
#define UARTSpeedConfigDef_BL600  9600        //6
#define UARTSpeedConfigDef_BL652  115200      //6
    #define UARTSpeedConfigMin       1200
    #define UARTSpeedConfigMax       1000000
//Default UART Tx buffer length
#define UARTTxBufConfigDef       0      //7
    #define UARTTxBufConfigMin       0
    #define UARTTxBufConfigMax       1024
//Default UART Rx buffer length
#define UARTRxBufConfigDef       0      //8
    #define UARTRxBufConfigMin       0
    #define UARTRxBufConfigMax       1024
//Default action of CONN pin (-1 for no gpio indication, otherwise the GPIO selected)
#define CONNPinConfigDef         29      //9
    #define CONNPinConfigMin         -1
    #define CONNPinConfigMax         31
//Default action of ENCR pin (-1 for no gpio indication, otherwise the GPIO selected)
#define ENCRPinConfigDef         30      //10
    #define ENCRPinConfigMin         -1
    #define ENCRPinConfigMax         31
//Default UUID of Tx characteristic (sibling of Base UUID)
#define VspTxUUIDConfigDef       0x2000      //11
    #define VspTxUUIDConfigMin       1
    #define VspTxUUIDConfigMax       0xFFFF
//Default UUID of Rx characteristic (sibling of Base UUID)
#define VspRxUUIDConfigDef       0x2001      //12
    #define VspRxUUIDConfigMin       1
    #define VspRxUUIDConfigMax       0xFFFF
//Default UUID of Modem-In characteristic (sibling of Base UUID)
//Set to 0 to disable (it will also disable MdmIn)
#define VspMdmInUUIDConfigDef    0x2003      //13
    #define VspMdmInUUIDConfigMin    0
    #define VspMdmInUUIDConfigMax    0xFFFF
//Default UUID of Modem-Out characteristic (sibling of Base UUID)
//Set to 0 to disable (it will also disable MdmOut)
#define VspMdmOutUUIDConfigDef   0x2002      //14
    #define VspMdmOutUUIDConfigMin   0
    #define VspMdmOutUUIDConfigMax   0xFFFF
//Default length of Tx buffer (0 = default, 1024 maximum (for BL652) or 512 maximum (for BL600))
#define VspTxBufConfigDef        384      //15
    #define VspTxBufConfigMin        0
    #define VspTxBufConfigMax        1024
//Default length of Rx buffer (0 = default, 1024 maximum (for BL652) or 512 maximum (for BL600))
#define VspRxBufConfigDef        384      //16
    #define VspRxBufConfigMin        0
    #define VspRxBufConfigMax        1024
//Default VSP Service Encryption setting, Bit 0: Enable(1)/Disable(0), Bit 1: (MITM(1)/NoMITM(0)
#define VspEncryptConfigDef      0      //17
    #define VspEncryptConfigMin      0
    #define VspEncryptConfigMax      3

//Default Login Password (Must NOT be > 19 because \r is added and we want to be 20 max)
#define LoginPswrdConfigDef      "@command_mode@"   //0
    #define LoginPswrdConfigMinLen   8
    #define LoginPswrdConfigMaxLen   19
//Default advertised name of device
#define DeviceNameConfigDef_BL652    "LAIRD BL652"   //1
#define DeviceNameConfigDef_BL600    "LAIRD BL600"   //1
    #define DeviceNameConfigMinLen    1
    #define DeviceNameConfigMaxLen    12
//VSP default
#define VspServiceUUIDConfigDef  "569a1101b87f490c92cb11ba5ea5167c"    //2
    #define VspServiceUUIDConfigMinLen   32
    #define VspServiceUUIDConfigMaxLen   32

//LED GPIO pin configuration
#define BL600GPIOLED1Pin       18                                 //GPIO for LED1 (DVK-BL600)
#define BL600GPIOLED2Pin       19                                 //GPIO for LED2 (DVK-BL600)
#define BL652GPIOLED1Pin       17                                 //GPIO for LED1 (DVK-BL652)
#define BL652GPIOLED2Pin       19                                 //GPIO for LED2 (DVK-BL652)

#define MaxCmdStringSize       144                                //Maximum allowable size of strings (1024 maximum (for BL652) or 512 maximum (for BL600))
 
#define MaxDevNameSize         20                                 //Maximum allowable size of the advertised device name (additional characters will be clipped off)

//like cmpif flag bits but works at runtime
// 0x00 = ignore 
// 0x01 = prevent if VSP NV failure 
// 0x02 = prevent if gap/other NV failure (affects battery life and throughput but not security)
// 0x04 = prevent if UART NV failure
#define NvReadFailMode         0 

//Defines for where various configuration parameters are stored in non-voltatile memory
#define DevNameFormatConfigID      0                              //nonval key where the type of the advertised device name is stored
#define TxPowerConfigID            1                              //nonval key where the Tx Power is stored
#define EncrDisconToutConfigID     2                              //nonval key where unecnrypted disconnect tiemout is stored
#define AdvertIntvlConfigID        3                              //nonval key where advertising interval is stored
#define MinConnIntConfigID         4                              //nonval key where minimum connection interval is stored
#define MaxConnIntConfigID         5                              //nonval key where maximum connection interval is stored
#define UARTSpeedConfigID          6                              //nonval key where UART baud rate is stored
#define UARTTxBufConfigID          7                              //nonval key where UART Tx buffer length is stored
#define UARTRxBufConfigID          8                              //nonval key where UART Rx buffer length is stored
#define CONNPinConfigID            9                              //nonval key where the CONNection indication gpio pin is stored
#define ENCRPinConfigID           10                              //nonval key where the ENCRyption indication gpio pin is stored
#define VspTxUUIDConfigID         11                              //nonval key where VSP Tx UUID is stored
#define VspRxUUIDConfigID         12                              //nonval key where VSP Rx UUID is stored
#define VspMdmInUUIDConfigID      13                              //nonval key where VSP Modem-In UUID is stored
#define VspMdmOutUUIDConfigID     14                              //nonval key where VSP Modem-Out UUID is stored
#define VspTxBufConfigID          15                              //nonval key where Tx buffer length is stored
#define VspRxBufConfigID          16                              //nonval key where Rx buffer length is stored
#define VspEncryptConfigID        17                              //nonval key where VSP service encryption flag is stored

//The following are STRING configs so need to be remapped to 0 .. N
#define LoginPswrdConfigID         0                              //nonval key where the login password is stored (8-19) characters
#define DeviceNameConfigID         1                              //nonval key where the advertised device name is stored
#define VspServiceUUIDConfigID     2                              //nonval key where base VSP UUID is stored


#define AppModeAppBridge       0                                  //Application in bridge mode
#define AppModeAppCmd          1                                  //Application in command mode
#define AppModeAppLogin        2                                  //Application in Login mode for first LOGIN_MODE_TIMEOUT_MS milliseconds

#define UartConfigParameters   "CN81H"                            //Can only be "CN81H" or "CN81N"

#define BT900_DEV_ID           0x42370900                         //Device ID for BT900
#define BL600_DEV_ID           0x424C0600                         //Device ID for BL600
#define BL652_DEV_ID           0x424C0652                         //Device ID for BL652

#define CONFIG_KEY_ID_START_NUM   0                               //The start ID in nvrecord non-vol space for integer config keys
#define CONFIG_KEY_ID_MAX_NUM     20                              //Maximum number of integer config keys
#define CONFIG_KEY_ID_START_STR   100                             //The start ID in nvrecord non-vol space for string config keys
#define CONFIG_KEY_ID_MAX_STR     10                              //Maximum number of string config keys

        
#define NUM_OF_I_PARAMS           (8)                             // size of i[]        
#define NUM_OF_S_PARAMS           (8)                             // size of s$[]

#define LOGIN_MODE_TIMEOUT_MS      60000 //Login modeout timeout in seconds

#define PROMPT_OK                  "OK\r\n>"

//******************************************************************************
// Global Variable Declarations
//******************************************************************************

//Result code variable (used for checking if a function completed successfully or not)
dim rc

//Base UUID for the VSP service which other UUIDs will be siblings of
dim BaseUUID

//Application mode (application command mode or application bridge mode)
dim AppMode

//Advertising interval
dim AdvInt

//Set to 1 when there is an application error to prevent device working as VSP server
dim ApplicationError

//VSP send/receive buffer (for application command mode)
dim VSPSndBuf$
dim VSPRecBuf$

//UART send/receive buffer (for application command mode)
dim UARTSndBuf$
dim UARTRecBuf$

//Terminator for commands in command mode
dim SearchStr$ : SearchStr$ = "\r"

//Holds the device ID
dim DevID

//Holds the connection ID of the VSP client (if one is connected)
dim ConnectionID

//Will be 0 if connection is not encrypted, 1 if it is
dim Encrypted : Encrypted=0

//Login Password cache
dim LoginPassword$ 
dim LoginPasswordLen 

//Holds the various GPIO pin numbers (varies based on module)
dim CONNPin, ENCRpin
#cmpif 0x00000002 : dim GPIOLED1Pin
#cmpif 0x0000000C : dim GPIOLED2Pin

//Holds the timeout value that will disconnect a device that connects but doesn't 
//encrypt the connection within the time (if the encryption flag is enabled)
dim DisconnectTime

//temporary variables used by the command parser
dim i[NUM_OF_I_PARAMS]      // index 0 used for return values
dim s$[NUM_OF_S_PARAMS]    // must be at least 8 elements for BleSvcRegDevInfo()

//******************************************************************************
// Initialise Global Variable
//******************************************************************************
AppMode = AppModeAppLogin
ApplicationError = 0
VSPSndBuf$ = ""
VSPRecBuf$ = ""
UARTSndBuf$ = ""
UARTRecBuf$ = ""
DevID = SysInfo(0)
ConnectionID = 0
if (DevID == BL600_DEV_ID) then
    //BL600 module
    #cmpif 0x00000002 : GPIOLED1Pin = BL600GPIOLED1Pin
    #cmpif 0x0000000C : GPIOLED2Pin = BL600GPIOLED2Pin
elseif (DevID == BL652_DEV_ID) then
    //BL652 module
    #cmpif 0x00000002 : GPIOLED1Pin = BL652GPIOLED1Pin
    #cmpif 0x0000000C : GPIOLED2Pin = BL652GPIOLED2Pin
endif

//******************************************************************************
// Function and Subroutine definitions
//******************************************************************************

//------------------------------------------------------------------------------
// Assert to check that a resultCode is 0 which means success
//------------------------------------------------------------------------------
#cmpif 0x00010000 : sub AssertRC(rc, tag)
#cmpif 0x00010000 :     if (rc != 0) then
#cmpif 0x00010000 :         print "Assert Error ";rc;" @ tag ";tag;"\r\n"
#cmpif 0x00010000 :     endif
#cmpif 0x00010000 : endsub

//------------------------------------------------------------------------------
// Assert to check that the value is as per specified
//------------------------------------------------------------------------------
#cmpif 0x00010000 : sub Assert(v1,v2,tag)
#cmpif 0x00010000 :     if (v1 != v2) then
#cmpif 0x00010000 :         print "Assert Error ";v1;"!=";v2;"@ tag ";tag;"\r\n"
#cmpif 0x00010000 :     endif
#cmpif 0x00010000 : endsub

//------------------------------------------------------------------------------
// Assert to check that the value is as per specified
//------------------------------------------------------------------------------
#cmpif 0x00010000 : sub AssertBound(v,vl,vh,tag)
#cmpif 0x00010000 :     if (v < vl) then
#cmpif 0x00010000 :         print "Assert Error ";v;"<";vl
#cmpif 0x00010000 :     elseif (v > vh) then
#cmpif 0x00010000 :         print "Assert Error ";v;">";vh
#cmpif 0x00010000 :     else
#cmpif 0x00010000 :         exitsub
#cmpif 0x00010000 :     endif
#cmpif 0x00010000 :     print " @ tag ";tag;"\r\n"
#cmpif 0x00010000 : endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x80000000 : sub DbgMsg(byval msg$ as string)
#cmpif 0x80000000 :     print "\n## ";msg$
#cmpif 0x80000000 : endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x80000000 : sub DbgMsgVal(byval msg$ as string, byval vl as integer)
#cmpif 0x80000000 :     print "\n## ";msg$;" ";vl
#cmpif 0x80000000 : endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x80000000 : sub DbgMsgVal$(byval msg$ as string, byref vl$ as string)
#cmpif 0x80000000 :     print "\n## ";msg$;" ";vl$
#cmpif 0x80000000 : endsub

//------------------------------------------------------------------------------
// Non-voltatile storage error handler (if program is set to stop running)
//------------------------------------------------------------------------------
sub NvFailure()
    //Non-volatile storage failure and application set to not continue when this is detected
    #cmpif 0x00010000 : AssertRC(rc, 3550)

    //Enable LED2 flashing if set to do so
    rc = 0
    #cmpif 0x00000008 : rc = GPIOSetFunc(GPIOLED2Pin, 2, 3) //Set as frequency output
    #cmpif 0x00000008 : GPIOWrite(GPIOLED2Pin, 2)
    #cmpif 0x00010000 : AssertRC(rc, 3610)
endsub

//------------------------------------------------------------------------------
// There are 2 types of non-volatile config keys. One type stores integer values
// and the other stores string values.
// This function gets the default for the key of INTEGER type
// Valid keyID values are 0 to (CONFIG_KEY_ID_MAX_NUM-1)
//------------------------------------------------------------------------------
function ConfigKeyGetDef( keyID as integer) as integer
    dim defVal
    
    #cmpif 0x00010000 : AssertBound(keyID, 0, (CONFIG_KEY_ID_MAX_NUM-1), 3730 )
    
    select keyID
    case VspTxBufConfigID
        defval=VspTxBufConfigDef
    case VspRxBufConfigID
        defval=VspRxBufConfigDef
    case VspEncryptConfigID
        defval=VspEncryptConfigDef
    case VspTxUUIDConfigID
        defval=VspTxUUIDConfigDef
    case VspRxUUIDConfigID
        defval=VspRxUUIDConfigDef
    case VspMdmInUUIDConfigID
        defval=VspMdmInUUIDConfigDef
    case VspMdmOutUUIDConfigID
        defval=VspMdmOutUUIDConfigDef
    case AdvertIntvlConfigID
        defval=AdvertIntvlConfigDef
    case MinConnIntConfigID
        defval=MinConnIntConfigDef
    case MaxConnIntConfigID
        defval=MaxConnIntConfigDef
    case UARTSpeedConfigID
        if (DevID == BL600_DEV_ID) then
            //BL600 module
            defval=UARTSpeedConfigDef_BL600
        elseif (DevID == BL652_DEV_ID) then
            //BL652 module
            defval=UARTSpeedConfigDef_BL652
        endif
    case UARTTxBufConfigID
        defval=UARTTxBufConfigDef
    case UARTRxBufConfigID
        defval=UARTRxBufConfigDef
    case EncrDisconToutConfigID
        defval=EncrDisconToutConfigDef
    case DevNameFormatConfigID
        defval=DevNameFormatConfigDef
    case TxPowerConfigID
        defval=TxPowerConfigDef
    case CONNPinConfigID
        defval=CONNPinConfigDef
    case ENCRPinConfigID
        defval=ENCRPinConfigDef
    case else
        defVal=0
    endselect
    
endfunc defVal

//------------------------------------------------------------------------------
// There are 2 types of non-volatile config keys. One type stores integer values
// and the other stores string values.
// This function gets the INTEGER variety
// Valid keyID values are 0 to (CONFIG_KEY_ID_MAX_NUM-1)
// Integer config keys are stored beginning at ID = CONFIG_KEY_ID_START_NUM
//------------------------------------------------------------------------------
function ConfigKeyGet( keyID as integer) as integer
    dim keyVal,tmpStr$
    
    if (keyID<0)||(keyID>=CONFIG_KEY_ID_MAX_NUM) then
        exitfunc ConfigKeyGetDef(keyID)
    endif
    
    if (NvRecordGet((keyID + CONFIG_KEY_ID_START_NUM), tmpStr$) <= 0 ) then
        //The key is empty or does not exist yet
        exitfunc ConfigKeyGetDef(keyID)
    else
        //Record read successfully
        keyVal = StrValDec(tmpStr$)
    endif
endfunc keyVal

//------------------------------------------------------------------------------
// Returns 0 if the value is outside min and max
//------------------------------------------------------------------------------
function InRange(newVal,minVal,maxVal) as integer
    if newVal<minVal then
        exitfunc 0
    elseif newVal>maxVal then
        exitfunc 0
    endif
endfunc 1

//------------------------------------------------------------------------------
// There are 2 types of non-volatile config keys. One type stores integer values
// and the other stores string values.
// This function checks if the integer type key value is valid
// Return 0 if not valid !0 if valid
//------------------------------------------------------------------------------
function ConfigKeyIsValid( keyID as integer, byref newVal as integer) as integer
    dim isValid
    
    #cmpif 0x00010000 : AssertBound(keyID, 0, (CONFIG_KEY_ID_MAX_NUM-1), 4480 )
    
    select keyID
    case VspTxBufConfigID
        isValid=InRange(newVal,VspTxBufConfigMin,VspTxBufConfigMax)
        
    case VspRxBufConfigID
        isValid=InRange(newVal,VspRxBufConfigMin,VspRxBufConfigMax)
        
    case VspEncryptConfigID
        isValid=InRange(newVal,VspEncryptConfigMin,VspEncryptConfigMax)
        
    case VspTxUUIDConfigID
        isValid=InRange(newVal,VspTxUUIDConfigMin,VspTxUUIDConfigMax)
        
    case VspRxUUIDConfigID
        isValid=InRange(newVal,VspRxUUIDConfigMin,VspRxUUIDConfigMax)
        
    case VspMdmInUUIDConfigID
        isValid=InRange(newVal,VspMdmInUUIDConfigMin,VspMdmInUUIDConfigMax)
        
    case VspMdmOutUUIDConfigID
        isValid=InRange(newVal,VspMdmOutUUIDConfigMin,VspMdmOutUUIDConfigMax)
        
    case AdvertIntvlConfigID
        isValid=InRange(newVal,AdvertIntvlConfigMin,AdvertIntvlConfigMax)
        
    case MinConnIntConfigID
        isValid=InRange(newVal,MinConnIntConfigMin,ConfigKeyGet(MaxConnIntConfigID))
        
    case MaxConnIntConfigID
        isValid=InRange(newVal,ConfigKeyGet(MinConnIntConfigID),MaxConnIntConfigMax)
        
    case UARTSpeedConfigID
        select newVal
          case 1200,2400,4800,9600,14400,19200,28800,38400,57600,76800,115200,230400,250000,460800,921600,1000000
              isValid=1
          case else
              isValid=0  
        endselect
        
    case UARTTxBufConfigID
        isValid=InRange(newVal,UARTTxBufConfigMin,UARTTxBufConfigMax)
        
    case UARTRxBufConfigID
        isValid=InRange(newVal,UARTRxBufConfigMin,UARTRxBufConfigMax)
        
    case EncrDisconToutConfigID
        isValid=InRange(newVal,EncrDisconToutConfigMin,EncrDisconToutConfigMax)
        
    case DevNameFormatConfigID
        isValid=InRange(newVal,DevNameFormatConfigMin,DevNameFormatConfigMax)
        
    case CONNPinConfigID
        isValid=InRange(newVal,CONNPinConfigMin,CONNPinConfigMax)
        
    case ENCRPinConfigID
        isValid=InRange(newVal,ENCRPinConfigMin,ENCRPinConfigMax)
        
    case TxPowerConfigID
        isValid=InRange(newVal,TxPowerConfigMin,TxPowerConfigMax)
        
    case else
        isValid=0
    endselect
    
endfunc isValid

//------------------------------------------------------------------------------
// There are 2 types of non-volatile config keys. One type stores integer values
// and the other stores string values.
// This function sets the INTEGER variety and validates against min/max 
// Valid keyID values are 0 to (CONFIG_KEY_ID_MAX_NUM-1)
// returns 0 if successful, 1 invalid key, 2 invalid value, 3 if NvRecordSet fails
//------------------------------------------------------------------------------
function ConfigKeySet(keyID as integer, newVal as integer)as integer
    dim tmpStr$
    
    if (keyID<0)||(keyID>=CONFIG_KEY_ID_MAX_NUM) then
        exitfunc 1
    endif
    
    if ConfigKeyIsValid(keyID,newVal)==0 then
        //new value is not valid
        exitfunc 2
    endif
    
    sprint #tmpStr$, newVal
    rc = NvRecordSet((keyID + CONFIG_KEY_ID_START_NUM),tmpStr$)
    
    if (rc <= 0 && (NvReadFailMode & 1) == 1) then
        //Failed to write non-volatile record and application set to not continue
        NvFailure()
        exitfunc 3
    endif
endfunc 0

//------------------------------------------------------------------------------
// There are 2 types of non-volatile config keys. One type stores integer values
// and the other stores string values.
// This function gets the default for the key of STRING type
// Valid keyID values are 0 to (CONFIG_KEY_ID_MAX_STR-1)
//------------------------------------------------------------------------------
sub ConfigKeyGetDef$( keyID as integer, byref defVal$ as string)
    
    #cmpif 0x00010000 : AssertBound(keyID, 0, (CONFIG_KEY_ID_MAX_STR-1), 5550 )
    
    select keyID
    case VspServiceUUIDConfigID
        defVal$=VspServiceUUIDConfigDef
    case DeviceNameConfigID
        if (DevID == BL600_DEV_ID) then
            //BL600 module
            defVal$=DeviceNameConfigDef_BL600
        elseif (DevID == BL652_DEV_ID) then
            //BL652 module
            defVal$=DeviceNameConfigDef_BL652
        endif
    case LoginPswrdConfigID
        defVal$=LoginPswrdConfigDef
    case else
        defVal$="-"
    endselect
    
endsub

//------------------------------------------------------------------------------
// There are 2 types of non-volatile config keys. One type stores integer values
// and the other stores string values.
// This function gets the STRING variety
// Valid keyID values are 0 to (CONFIG_KEY_ID_MAX_STR-1)
// String config keys are stored beginning at ID = CONFIG_KEY_ID_START_STR
//------------------------------------------------------------------------------
function ConfigKeyGet$(keyID as integer) as string
    dim keyVal$
    if (keyID<0)||(keyID>=CONFIG_KEY_ID_MAX_STR) then
        //invalid key id
        ConfigKeyGetDef$(keyID,keyVal$)   
        
    elseif (NvRecordGet((keyID+CONFIG_KEY_ID_START_STR), keyVal$) <= 0 ) then
        //the key does not exist yet
        ConfigKeyGetDef$(keyID,keyVal$)   
        
    endif
endfunc keyVal$

//------------------------------------------------------------------------------
// There are 2 types of non-volatile config keys. One type stores string values
// and the other stores string values.
// This function checks if the string type key value is valid
// Return 0 if not valid !0 if valid
//------------------------------------------------------------------------------
function ConfigKey$IsValid( keyID as integer, newVal$ as string) as integer
    dim isValid, tmpStr1$, nlen
    
    #cmpif 0x00010000 : AssertBound(keyID, 0, (CONFIG_KEY_ID_MAX_STR-1), 6000 )
    
    isValid = 0 // assume invalid
    nlen = strlen(newVal$) //get length of new value
    
    select keyID
    case VspServiceUUIDConfigID
        tmpStr1$=StrDehexize$(newVal$)
        if( strlen(tmpStr1$) == 16 ) then
            isValid=1
        endif
        
    case DeviceNameConfigID
        if( (nlen>=DeviceNameConfigMinLen) && (nlen<=DeviceNameConfigMaxLen) ) then
            //valid length
            isValid=1
        endif
    
    case LoginPswrdConfigID
        if( (nlen>=LoginPswrdConfigMinLen) && (nlen<=LoginPswrdConfigMaxLen) ) then
            //valid length
            isValid=1
        endif
    
    case else
    endselect
    
endfunc isValid

//------------------------------------------------------------------------------
// There are 2 types of non-volatile config keys. One type stores integer values
// and the other stores string values.
// This function sets the INTEGER variety and validates against min/max 
// Valid keyID values are 0 to (CONFIG_KEY_ID_MAX_STR-1)
// returns 0 if successful, 1 invalid key, 2 invalid value, 3 if NvRecordSet fails
//------------------------------------------------------------------------------
function ConfigKeySet$(keyID as integer, newVal$ as string)as integer
    if (keyID<0)||(keyID>=CONFIG_KEY_ID_MAX_STR) then
        exitfunc 1
    endif
    
    if ConfigKey$IsValid(keyID,newVal$)==0 then
        //new value is not valid
        exitfunc 2
    endif
    
    rc = NvRecordSet((keyID + CONFIG_KEY_ID_START_STR),newVal$)
    
    if (rc <= 0 && (NvReadFailMode & 1) == 1) then
        //Failed to write non-volatile record and application set to not continue
        NvFailure()
        exitfunc 3
    endif
endfunc 0

//------------------------------------------------------------------------------
// Extract 'num' integer tokens from the string u$ and save starting at i[stIdx]
// u$ is left shifted as then tokens are extraced
// Returns 0 if all 'num' integer tokens are successfyully extracted, and 4 if not
//------------------------------------------------------------------------------
function ExtractIntTokens(u$,stIdx,num)
    dim tlen
    while num>0
        tlen = ExtractIntToken(u$,i[stIdx])
        if tlen == 0 then
            exitfunc 4
        endif
        num=num-1
        stIdx = stIdx+1
    endwhile
endfunc 0

//------------------------------------------------------------------------------
// Extract 'num' string tokens from the string u$ and save starting at s$[stIdx]
// u$ is left shifted as the tokens are extraced
// Returns 0 if all 'num' string tokens are successfyully extracted, and 4 if not
//------------------------------------------------------------------------------
sub TrimQuotes(str$)
    dim len 
    if strgetchr(str$,0)==0x22 then  //check for beginning "
        len = strlen(str$)
        if len > 2 then
            if strgetchr(str$,(len-1))==0x22 then //check for ending "
                str$ = mid$(str$,1,(len-2))
            endif
        elseif len == 2 then
            str$=""
        endif
    endif
endsub

//------------------------------------------------------------------------------
// Extract 'num' string tokens from the string u$ and save starting at s$[stIdx]
// u$ is left shifted as the tokens are extraced
// Returns 0 if all 'num' string tokens are successfyully extracted, and 4 if not
//------------------------------------------------------------------------------
function ExtractStrTokens(u$,stIdx,num)
    dim tlen
    while num>0
        tlen = ExtractStrToken(u$,s$[stIdx])
        if tlen == 0 then
            exitfunc 3
        endif
        TrimQuotes(s$[stIdx])  //remove delimiting "" quotes
        num=num-1
        stIdx = stIdx+1
    endwhile
endfunc 0

//------------------------------------------------------------------------------
// Function that will load the VSP configuration and initiate the VSP service
//------------------------------------------------------------------------------
function OpenVSPService()
    //Creates the VSP server instance
    dim TmpStr$, vspTxBufLen, vspRxBufLen, ModemChars, VspFlags, RxUUID, TxUUID, ModemInUUID, ModemOutUUID
    TmpStr$ = ""

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //Load the configuration from non-voltatile storage
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    //Tx buffer size
    vspTxBufLen = ConfigKeyGet( VspTxBufConfigID )
    //Rx buffer size
    vspRxBufLen = ConfigKeyGet( VspRxBufConfigID)
    
    //Base UUID
    TmpStr$ = ConfigKeyGet$( VspServiceUUIDConfigID )
    TmpStr$ = StrDehexize$(TmpStr$)
    BaseUUID = BleHandleUuid128(TmpStr$)
    //Tx UUID handles
    TxUUID = ConfigKeyGet( VspTxUUIDConfigID)
    TxUUID = BleHandleUuidSibling(BaseUUID, TxUUID)
    //Rx UUID handles
    RxUUID = ConfigKeyGet( VspRxUUIDConfigID)
    RxUUID = BleHandleUuidSibling(BaseUUID, RxUUID)
    
    //Modem characteristics enabled/disabled
    ModemInUUID  = ConfigKeyGet( VspMdmInUUIDConfigID)
    ModemOutUUID = ConfigKeyGet( VspMdmOutUUIDConfigID)
    if( (ModemInUUID==0) || (ModemOutUUID==0) ) then 
        //do not register the modem chars
        ModemInUUID=0
        ModemOutUUID=0
    else
        ModemInUUID = BleHandleUuidSibling(BaseUUID, ModemInUUID)
        ModemOutUUID = BleHandleUuidSibling(BaseUUID, ModemOutUUID)
    endif    
    
    //VspFlags
    VspFlags = ConfigKeyGet( VspEncryptConfigID)
    //Read the disconnection timeout value (if the encryption flag is set)
    if ((VspFlags & 0x1) == 0x1 ) then
        //VSP encryption is enabled, get timer value
        DisconnectTime = ConfigKeyGet( EncrDisconToutConfigID)
        if ((VspFlags & 0x2) == 0x2 ) then
            VspFlags = 0x0C
        else
            VspFlags = 0x08
        endif
    else
        //VSP encryption is disabled, disable timer
        DisconnectTime = 0
        VspFlags = 0
    endif

    //Open the VSP service with the provided configuration
    rc = BleVSPOpenEx(vspTxBufLen, vspRxBufLen, VspFlags, BaseUUID, RxUUID, TxUUID, ModemInUUID, ModemOutUUID)
    #cmpif 0x00010000 : AssertRC(rc, 7680)
endfunc 1

//------------------------------------------------------------------------------
// Function for setting up the GAP service
//------------------------------------------------------------------------------
function SetupGAPService()
    dim TmpStr$, TmpVal, MinCntInt, MaxCntInt, DevName$
    
    //Set the tx power level
    TmpVal = ConfigKeyGet( TxPowerConfigID)
    rc=BleTxPowerSet(TmpVal)

    //Read the minimum connection interval and check sensible value
    MinCntInt = ConfigKeyGet( MinConnIntConfigID)   
    
    //Read the maximum connection interval and check sensible value
    MaxCntInt = ConfigKeyGet( MaxConnIntConfigID)

    //Get device name
    DevName$ = ConfigKeyGet$( DeviceNameConfigID)
    //Append part of module BT address if required
    TmpVal = ConfigKeyGet( DevNameFormatConfigID)
    #cmpif 0x80000000 : DbgMsgVal("DevNameFormat =",TmpVal)
    //Default selection if the BT address is appended to the advertised device name 
    if ((TmpVal >= 1) && (TmpVal <= 7)) then
        //Get device address
        TmpStr$ = SysInfo$(4)
        //#cmpif 0x80000000 : dim x$ : x$=strhexize$(TmpStr$)
        //#cmpif 0x80000000 : DbgMsgVal$("SysInfo$(4) =",x$)
        TmpStr$ = Right$(TmpStr$, TmpVal)
        //Append to device name
        DevName$ = DevName$ + "-" + strhexize$(TmpStr$)
    endif
    //take the righmost max characters
    DevName$ = right$(DevName$,MaxDevNameSize)
    
    #cmpif 0x80000000 : DbgMsgVal$("DeviceName =",DevName$)

    //Initialise the GAP service with the connection interval data and device name
    rc = BleGapSvcInit(DevName$, 0, 0, MinCntInt, MaxCntInt, 4000000,  0)
    #cmpif 0x00010000 : AssertRC(rc, 8220)

    //Read the advertising interval and check that the value is sane
    AdvInt = ConfigKeyGet( AdvertIntvlConfigID)
    
endfunc 1

//------------------------------------------------------------------------------
// Sub-routine to create the adverts for the VSP service
//------------------------------------------------------------------------------
sub CreateAdverts()
    //Add device name to advert report and service UUID to scan report
    dim advRpt$, scRpt$
    rc = BleAdvRptInit(advRpt$, 2, 0, MaxDevNameSize)
    #cmpif 0x00010000 : AssertRC(rc, 8440)
    rc = BleScanRptInit(scRpt$)
    #cmpif 0x00010000 : AssertRC(rc, 8460)
    rc = BleAdvRptAddUuid128(scRpt$, BaseUUID)
    #cmpif 0x00010000 : AssertRC(rc, 8480)
    rc = BleAdvRptsCommit(advRpt$, scRpt$)
    #cmpif 0x00010000 : AssertRC(rc, 8500)
endsub

//------------------------------------------------------------------------------
// Sub-routine that initiates Ble advertising for central devices to connect to
//------------------------------------------------------------------------------
sub StartAdvertising()
    if (ApplicationError == 0) then
        //Application has not encountered any errors, continue
        dim Addr$
        Addr$ = ""

        //Start advertising over BLE
        rc = BleAdvertStart(0, Addr$, AdvInt, 0, 0)
        #cmpif 0x00010000 : AssertRC(rc, 8640)
    endif
endsub

//------------------------------------------------------------------------------
//get cuttent connection parameters into a string
//------------------------------------------------------------------------------
sub GetConnParms(byref outStr$)
    dim intrvl,sprvto,slat
    rc=-1
    if ConnectionID != 0 then
        rc = BleGetCurConnParms(ConnectionID,intrvl,sprvto,slat)
        if rc==0 then
          sprint #outStr$, "Interval=";intrvl;",SuperTout=";sprvto;",SlaveLatency=";slat
        endif
        if Encrypted == 0 then
            outStr$ = outStr$ + ",NotEncrypted"
        else
            outStr$ = outStr$ + ",Encrypted"
        endif
    endif
    if rc!=0 then
        outStr$="NO-CONNECTION"
    endif
endsub

//------------------------------------------------------------------------------
// This shows the cuttent connection parameters
//------------------------------------------------------------------------------
#cmpif 0x80000000 : sub ShowConnParms()
#cmpif 0x80000000 :     dim outStr$
#cmpif 0x80000000 :     GetConnParms(outStr$)
#cmpif 0x80000000 :     print "\n## ConnParms :: ";outStr$
#cmpif 0x80000000 : endsub

//------------------------------------------------------------------------------
// Function to handle Ble event messages
//------------------------------------------------------------------------------
#define BLE_EVBLEMSGID_CONNECT                  0   //nCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT               1   //nCtx = connection handle
#define BLE_EVBLEMSGID_SERVICE_ERROR            4   //nCtx = resultcode
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY          9   //nCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                 10  //nCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST         11  //nCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_HRS_NOTIFICATION_STATE   12  //nCtx = new notification state 0=off, 1=on
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE        14  //nCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL   15  //nCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER    16  //nCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND             17  //nCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                18  //nCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING    19  //nCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED              20  //nCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE         21  //nCtx = connection handle
//------------------------------------------------------------------------------
function HndlrBleMsg(nMsgId, nCtx)

    select nMsgId
    case BLE_EVBLEMSGID_CONNECT
        //Connection
        if (ConnectionID==0) then
            #cmpif 0x80000000 : DbgMsg("Connected")
            ConnectionID = nCtx
            Encrypted = 0
            #cmpif 0x00000002 : GPIOWrite(GPIOLED1Pin, 1)

            if (CONNPin >= 0) && (CONNPin!=ENCRPin) then
                //Update CONN status due to device connection, then (CONNPin!=ENCRPin)
                //ensures that if the same pin is used then ENCR takes higher priority
                GPIOWrite(CONNPin, 1)
            endif
            if (ENCRPin >= 0) then
                //Update ENCR status due to device connection
                GPIOWrite(ENCRPin, 0)
            endif
            #cmpif 0x80000000 : ShowConnParms()

            //Check if disconnection timer is enabled
            if (DisconnectTime > 0) then
                //Start timer for disconnect if connection does not become encrypted
                TimerStart(0, DisconnectTime, 0)
            endif
        else
            //prevent multiple connections
            rc = BleDisconnect(nCtx)
        endif
        
    case BLE_EVBLEMSGID_DISCONNECT
        //Disconnection
        if (ConnectionID==nCtx) then
            #cmpif 0x80000000 : DbgMsg("Disconnected")
            ConnectionID = 0
            #cmpif 0x00000002 : GPIOWrite(GPIOLED1Pin, 0)
            if (CONNPin >= 0) then
                GPIOWrite(CONNPin, 0)
            endif
            if (ENCRPin >= 0) then
                GPIOWrite(ENCRPin, 0)
            endif
            StartAdvertising()
            if (TimerRunning(0) > 0) then
                //Cancel disconnect timer
                TimerCancel(0)
            endif
        endif
        
    case BLE_EVBLEMSGID_ENCRYPTED
        //Encrypted connection
        #cmpif 0x80000000 :  DbgMsg("Encrypted")
        //set flag to indicate we are encrypted
        Encrypted = 1
        if (TimerRunning(0) > 0) then
            //Cancel disconnect timer
            TimerCancel(0)
        endif

        if (ENCRPin >= 0) then
            //Update ENCR status due to connection becoming encrypted
            GPIOWrite(ENCRPin, 1)
        endif
        
    #cmpif 0x80000000 : case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    #cmpif 0x80000000 :     DbgMsgVal("Display Pairing Passkey ",nCtx)

    #cmpif 0x80000000 : case BLE_EVBLEMSGID_NEW_BOND
    #cmpif 0x80000000 :     DbgMsg("New Bond")

    #cmpif 0x80000000 : case BLE_EVBLEMSGID_UPDATED_BOND
    #cmpif 0x80000000 :     DbgMsg("Updated Bond")

    #cmpif 0x80000000 : case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
    #cmpif 0x80000000 :     DbgMsg("Conn to Bonded Master ")

    #cmpif 0x80000000 : case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    #cmpif 0x80000000 :     DbgMsgVal("Auth Key Request, type=",nCtx)
      
    #cmpif 0x80000000 : case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
    #cmpif 0x80000000 :     ShowConnParms()
        
    #cmpif 0x80000000 : case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
    #cmpif 0x80000000 :     DbgMsg("Conn Parm Negotiation FAILED")
        
    case else        
    endselect
    
endfunc 1

//------------------------------------------------------------------------------
// Function for bridging data between the VSP service and the UART
//------------------------------------------------------------------------------
function HndlrBridge()
    //Pass data between UART and VSP service
    BleVspUartBridge()
endfunc 1

//------------------------------------------------------------------------------
// Function that will convert a string to lowercase - insitu
//------------------------------------------------------------------------------
sub StrToLower$(byref Text$)
    //Takes a string and replaces uppercase letters with lowercase letters
    dim i, chr
    i = strlen(Text$)-1
    while (i >= 0)
        chr = StrGetChr(Text$, i)
        if (chr >= 65 && chr <= 90) then
            rc = StrSetChr(Text$, chr+32, i)
        endif
        i = i-1
    endwhile
endsub

//------------------------------------------------------------------------------
// Function for sending buffered data for the UART or VSP out of those ports
//------------------------------------------------------------------------------
function SendBufferedData()
    dim BufferSize

    //Check if there is any VSP data to send
    BufferSize = StrLen(VSPSndBuf$)
    if (BufferSize > 0) then
        //Send VSP data
        rc = BleVSPWrite(VSPSndBuf$)
        StrShiftLeft(VSPSndBuf$, rc)
    endif

    //Check if there is any UART data to send
    BufferSize = StrLen(UARTSndBuf$)
    if (BufferSize > 0) then
        //Send UART data
        rc = UARTWrite(UARTSndBuf$)
        StrShiftLeft(UARTSndBuf$, rc)
    endif
endfunc 1

//------------------------------------------------------------------------------
// returns an integer with number of bits set to 1 from right
//------------------------------------------------------------------------------
function GetBitMask( bits as integer) as integer
    dim i,j,bm
    bm=0
    i=1
    for j = 1 to bits
        bm = bm | (i<<(j-1))
    next
endfunc bm

//------------------------------------------------------------------------------
// returns the a version string by splitting the bits as specified
//------------------------------------------------------------------------------
function GetVersion$( plat as integer, major as integer, minor as integer, engb as integer) as string
    dim v$, cv[4], compId
    
    compId = SysInfo(3)
    
    //platform
    cv[0] = (compId >> (major+minor+engb)) & GetBitMask(plat)    
    //major
    cv[1] = (compId >> (minor+engb)) & GetBitMask(major)
    //minor
    cv[2] = (compId >> (engb)) & GetBitMask(minor)
    //engbuild
    cv[3] = compId  & GetBitMask(engb)
    
    sprint #v$, "(";cv[0];".";cv[1];".";cv[2];".";cv[3];")"
    
endfunc v$

//------------------------------------------------------------------------------
//##CMD##  reset
//------------------------------------------------------------------------------
function _reset()
    //Reset module
    Reset(1)
endfunc 0

//------------------------------------------------------------------------------
//##CMD##  ver
//------------------------------------------------------------------------------
function _ver(byref bufferStr$)        
    bufferStr$ = "\nVSP Version " + AppVer + " updated " + AppUpdated + " on "
    if (DevID == BL600_DEV_ID) then
        //Running on BL600
        bufferStr$ = bufferStr$ + "BL600 " + GetVersion$( 6,6,14,6)            
    elseif (DevID == BL652_DEV_ID) then
        //Running on BL652
        bufferStr$ = bufferStr$ + "BL652 " + GetVersion$( 8,6,12,6)
    elseif (DevID == BT900_DEV_ID) then
        //Running on BL652
        bufferStr$ = bufferStr$ + "BT900 " + GetVersion$( 6,6,14,6)
    else
        //Unknown module
        bufferStr$ = bufferStr$ + "Unknown"
    endif
endfunc 0

//------------------------------------------------------------------------------
//##CMD##  addr
//------------------------------------------------------------------------------
function _addr(byref bufferStr$)        
    dim tmpStr$
    tmpStr$ = SysInfo$(4)
    tmpStr$ = strhexize$(tmpStr$)
    bufferStr$ = bufferStr$ + tmpStr$
endfunc 0

//------------------------------------------------------------------------------
//##CMD##  conninfo
//------------------------------------------------------------------------------
function _conninfo(byref bufferStr$)        
    dim tmpStr$
    GetConnParms(tmpStr$)
    bufferStr$ = bufferStr$ + tmpStr$
endfunc 0

//------------------------------------------------------------------------------
//##CMD##  bridge
//------------------------------------------------------------------------------
sub _bridge()
    //update the led indication
    #cmpif 0x00000004 : if (DevID == BL600_DEV_ID) then
    #cmpif 0x00000004 :     GPIOWrite(BL600GPIOLED2Pin, 0)
    #cmpif 0x00000004 : elseif (DevID == BL652_DEV_ID) then
    #cmpif 0x00000004 :     GPIOWrite(BL652GPIOLED2Pin, 0)
    #cmpif 0x00000004 : endif
    
    //change mode
    AppMode = AppModeAppBridge
    
    //flush the command mode buffers as they are no longer required so no need to hog memory
    UARTRecBuf$=""
    VSPRecBuf$=""
    LoginPassword$="" : LoginPasswordLen=0
    
    //change handlers so that data transfer happens in 'C'
    ONEVENT EVVSPRX CALL HndlrBridge
    ONEVENT EVUARTRX CALL HndlrBridge
    ONEVENT EVVSPTXEMPTY CALL HndlrBridge
    ONEVENT EVUARTTXEMPTY CALL HndlrBridge
    
    #cmpif 0x80000000 : DbgMsg("BRIDGE MODE")
endsub

//------------------------------------------------------------------------------
//##CMD##  erase
//------------------------------------------------------------------------------
function _erase(byref bufferStr$)        
    rc = EraseFileSystem(1)
    if (rc != 0) then
        //Erase failure
        bufferStr$ = "\nErase Fail: Vsp in cmd mode not enabled"
    endif
endfunc rc

//------------------------------------------------------------------------------
//##CMD##  cfg rd #INTid
//##CMD##  cfg wr #INTid #INTval
//------------------------------------------------------------------------------
function _cfg(byref bufferStr$, byref cmdStr$)        
    dim tkn$, tlen
    tlen = ExtractStrToken(cmdStr$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"rd")==0 then
      //extract 1 (#INTid) and store starting at i[1]
      rc = ExtractIntTokens(cmdStr$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      sprint #tkn$, ConfigKeyGet(i[1])
      bufferStr$ = BufferStr$ + tkn$
      exitfunc 0
    endif  
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"wr")==0 then
      //extract 2 (#INTid #INTval) and store starting at i[1]
      rc = ExtractIntTokens(cmdStr$,1,2)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc ConfigKeySet(i[1],i[2])
    endif      
endfunc 5

//------------------------------------------------------------------------------
//##CMD##  cfg$ rd #INTid
//##CMD##  cfg$ wr #INTid #STRval
//------------------------------------------------------------------------------
function _cfg$(byref bufferStr$, byref cmdStr$) as integer      
    dim tkn$, tlen
    tlen = ExtractStrToken(cmdStr$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"rd")==0 then
      //extract 1 (#INTid) and store starting at i[1]
      rc = ExtractIntTokens(cmdStr$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      bufferStr$ = bufferStr$ + ConfigKeyGet$(i[1])
      exitfunc 0
    endif  
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"wr")==0 then
      //extract 1 (#INTid) and store starting at i[1]
      rc = ExtractIntTokens(cmdStr$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 1 (#STRval) and store starting at s$[1]
      rc = ExtractStrTokens(cmdStr$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc ConfigKeySet$(i[1],s$[1])
    endif      
endfunc 5

//------------------------------------------------------------------------------
// Function to disconnect VSP client
//------------------------------------------------------------------------------
function _discon(byref bufferStr$)
    if (ConnectionID != 0) then
        //Client is connected, disconnect
        rc = BleDisconnect(ConnectionID)
    else
        //No connection
        BufferStr$ = "\nNO-CONNECTION"
        rc = 20
    endif
endfunc rc

//------------------------------------------------------------------------------
//##CMD##  client
//------------------------------------------------------------------------------
function _client(byref bufferStr$)        
    dim tmpStr$
    //Outputs client BT address (if one is connected)
    if (ConnectionID != 0) then
        //Connection: output address
        rc = BleGetAddrFromConnHandle(ConnectionID, tmpStr$)
        #cmpif 0x00010000 : AssertRC(rc, 11420)
        BufferStr$ = BufferStr$ + strhexize$(tmpStr$)
    else
        //No connection
        BufferStr$ = "\nNO-CONNECTION"
        rc = 20
    endif
endfunc rc

//------------------------------------------------------------------------------
//##CMD##  si #INTid
//------------------------------------------------------------------------------
function _si(byref bufferStr$, byref cmdStr$)
    dim tmpStr$
    //Outputs sysinfo(id)
    //extract 1 (#INTid) and store starting at i[1]
    rc = ExtractIntTokens(cmdStr$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    sprint #tmpStr$, SysInfo(i[1])
    bufferStr$ = bufferStr$ + tmpStr$
endfunc 0

//------------------------------------------------------------------------------
//##CMD##  si$ #INTid
//------------------------------------------------------------------------------
function _si$(byref bufferStr$, byref cmdStr$) as integer        
    dim tmpStr$
    //Outputs sysinfo(id)
    //extract 1 (#INTid) and store starting at i[1]
    rc = ExtractIntTokens(cmdStr$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    tmpStr$ = SysInfo$(i[1])
    bufferStr$ = BufferStr$ + StrHexize$(tmpStr$)
endfunc 0

//==============================================================================
//==============================================================================
sub AppendRspEnd(rsp as integer, byref bufferStr$ )
    if strlen(bufferStr$) > 1 then
        bufferStr$ = bufferStr$ + "\r\n"
    endif
    
    if rsp == 0 then
        bufferStr$ = bufferStr$ + PROMPT_OK
    elseif rsp > 0 then
        dim tmpStr$
        sprint #tmpStr$, integer.h' rsp
        bufferStr$ = bufferStr$ + "ER " + tmpStr$ + "\r\n>"
    endif    
endsub

//------------------------------------------------------------------------------
// Function for parsing commands when in application command mode, as follows:-
//------------------------------------------------------------------------------
function ParseCommand(byref CommandStr$, byref rspBuf$)
    //Parses UART/VSP command when in application command mode, 
    dim bufferStr$, tkn$, tlen
    
    bufferStr$ = "\n"
    rc=1 //assume there is an error    
    
    tlen = ExtractStrToken(CommandStr$,tkn$) //get first token
    if tlen == 0 then
        rc=0
    elseif tlen > 0 then
        //convert all data to lower case
        StrToLower$(tkn$)
        if     strcmp(tkn$,"reset")==0 then
            //Reset module
            rc = _reset()
            
        elseif strcmp(tkn$,"ver")==0 then
            //output platform and version information
            rc = _ver(bufferStr$)
            
        elseif (strcmp(tkn$, "addr") == 0) then
            //Output module Bluetooth address
            rc = _addr(bufferStr$)
            
        elseif (strcmp(tkn$, "conninfo") == 0) then
            //Output connection information
            rc = _conninfo(bufferStr$)
            
        elseif (strcmp(tkn$, "bridge") == 0) then
            //Switch to bridge mode
            _bridge()
            bufferStr$ = "\nBRIDGE-MODE"

        elseif (strcmp(tkn$, "erase") == 0) then
            //Erase module
            rc = _erase(bufferStr$)
            
        elseif (strcmp(tkn$, "cfg") == 0) then
            //read/write an integer configuration
            rc = _cfg(bufferStr$, CommandStr$)
            
        elseif (strcmp(tkn$, "cfg$") == 0) then
            //read/write a string configuration
            rc = _cfg$(bufferStr$, CommandStr$)
            
        elseif (strcmp(tkn$, "discon") == 0) then
            //disconnect
            rc = _discon(bufferStr$)
            
        elseif (strcmp(tkn$, "client") == 0) then
            //Outputs client BT address (if one is connected)
            rc = _client(bufferStr$)
            
        #cmpif 0x00000080 : elseif (strcmp(tkn$, "exit") == 0) then
        #cmpif 0x00000080 :     //Returns to module command mode
        #cmpif 0x00000080 :     exitfunc 0
            
        elseif (strcmp(tkn$, "si") == 0) then
            //Returns sysinfo
            rc = _si(bufferStr$, CommandStr$)
            
        elseif (strcmp(tkn$, "si$") == 0) then
            //Returns sysinfo
            rc = _si$(bufferStr$, CommandStr$)
            
        endif
    endif
    
    // Add an OK or ERROR to the response
    AppendRspEnd(rc,bufferStr$)

    //append the response to the buffer that will be sent    
    rspBuf$ = rspBuf$ + BufferStr$

    //Send out data waiting in buffer
    rc = SendBufferedData()
    
endfunc 1


//------------------------------------------------------------------------------
// Routine to check for command mode at startup
//------------------------------------------------------------------------------
function CheckForLoginCommand(byref newData$, byref ORIGRecBuf$, byref FWDSndBuf$, byref RSPSndBuf$)
    Dim CmdLen,GoForBridge
    
    //bridge this new string if a connection exists
    if (ConnectionID != 0) then
        //connection exists so throw the string across
        FWDSndBuf$=FWDSndBuf$+newData$
        //flush the data out
        rc = SendBufferedData()
    endif
    ORIGRecBuf$ = ORIGRecBuf$+newData$
    
    //now only scan for login command if password len is >= than min
    GoForBridge=0
    if ( LoginPasswordLen >= LoginPswrdConfigMinLen ) then
        //if the buffer is longer than the length of the command string then we
        //are no longer going to get the magic login command so just enter bridge mode
        if strlen(ORIGRecBuf$) >= LoginPasswordLen then
            //we can test if we have the command
            newData$=left$(ORIGRecBuf$,LoginPasswordLen)
            if strcmp(newData$,LoginPassword$)==0 then
                //magic command received so remain in command mode
                #cmpif 0x80000000 : DbgMsg("Login CmdMode\n")
                //change to command mode
                AppMode = AppModeAppCmd
                //and send an OK back out of the uart
                RSPSndBuf$=RSPSndBuf$+PROMPT_OK
                //empty the receicebuf
                ORIGRecBuf$=""
                //flush the data out
                rc = SendBufferedData()
                //stop timer
                TimerCancel(1)
            else
                //no magic command
                GoForBridge=1
            endif
        else
            newData$ = "\r"
            CmdLen = StrPos(ORIGRecBuf$, newData$, 0)
            if (CmdLen >= 0) then
                GoForBridge=1
            endif
        endif
    else
        GoForBridge=1
    endif
    
    if GoForBridge != 0 then
        //stop timer
        TimerCancel(1)
        //not magic command
        _bridge()
    endif
    
endfunc 1

//------------------------------------------------------------------------------
// Routine to service command mode, if it returns 0, then it implies exit the application
//------------------------------------------------------------------------------
function ProcessCommands(byref ORIGRecBuf$,byref RSPSndBuf$)
    dim CmdLen, CmdStr$
    
    //Check if any commands are present
    CmdLen = 1
    while (CmdLen >= 0)
        CmdLen = StrPos(ORIGRecBuf$, SearchStr$, 0)
        if (CmdLen >= 0) then
            //Command is present
            CmdLen = CmdLen + 1
            CmdStr$ = Left$(ORIGRecBuf$, CmdLen)
            StrShiftLeft(ORIGRecBuf$, CmdLen)

            //Parse and run command
            if (CmdLen > 1) then
                //Command is not empty
                rc = ParseCommand(CmdStr$,RSPSndBuf$)
                if (rc == 0) then
                    //Exit application
                    exitfunc 0
                endif
            endif
        endif
    endwhile

endfunc 1

//------------------------------------------------------------------------------
// In Login or Command mode and data has arrived from the peer
//------------------------------------------------------------------------------
function HndlrVSPCommand()
    //Data received from VSP
    dim newData$
    rc = BleVSPRead(newData$, MaxCmdStringSize - strlen(VSPRecBuf$))
    
    if (AppMode == AppModeAppCmd) then
        //--------------------------------------------
        //in command mode
        //--------------------------------------------
        //Check if any commands are present
        VSPRecBuf$ = VSPRecBuf$ + newData$
        
        //process commands
        exitfunc ProcessCommands(VSPRecBuf$,VSPSndBuf$)
        
    else
        //--------------------------------------------
        //in login mode
        //--------------------------------------------
        
        //scan the data for login command
        exitfunc CheckForLoginCommand(newData$, VSPRecBuf$,  UARTSndBuf$, VSPSndBuf$)
        
    endif
    
endfunc 1

//------------------------------------------------------------------------------
// In Login or Command mode and data has arrived from the uart
//------------------------------------------------------------------------------
function HndlrUARTCommand()

    //Data received from UART
    if (AppMode == AppModeAppCmd) then
        //--------------------------------------------
        //in command mode
        //--------------------------------------------
        rc = UARTReadN(UARTRecBuf$, MaxCmdStringSize)

        //process commands
        exitfunc ProcessCommands(UARTRecBuf$,UARTSndBuf$)
        
    else
        //--------------------------------------------
        //in login mode
        //--------------------------------------------
        dim newData$
        
        rc = UARTReadN(newData$, LoginPasswordLen)
        
        //scan the data for login command
        exitfunc CheckForLoginCommand(newData$, UARTRecBuf$, VSPSndBuf$, UARTSndBuf$)
        
    endif
    
endfunc 1

//------------------------------------------------------------------------------
// Configures the application operation mode
//------------------------------------------------------------------------------
sub SetupMode()
    if (AppMode == AppModeAppLogin) then
        //Start TIMER 1 to 
        TimerStart(1, LOGIN_MODE_TIMEOUT_MS, 0)
    endif
endsub

//------------------------------------------------------------------------------
// Configures the GPIO appropriately
//------------------------------------------------------------------------------
sub SetupGPIOs()

    //Setup LED1 as output if configured to be used as connection indicator
    rc = 0
    #cmpif 0x00000002 : rc = GPIOSetFunc(GPIOLED1Pin, 2, 0)
    #cmpif 0x00010000 : AssertRC(rc, 13580)

    //Set LED state if LED2 status is enabled
    rc = 0
    #cmpif 0x00000004 : rc = GPIOSetFunc(GPIOLED2Pin, 2, 0)
    #cmpif 0x00000004 : if (AppMode == AppModeAppCmd) then
    #cmpif 0x00000004 :     GPIOWrite(GPIOLED2Pin, 1)
    #cmpif 0x00000004 : else
    #cmpif 0x00000004 :     GPIOWrite(GPIOLED2Pin, 0)
    #cmpif 0x00000004 : endif
    #cmpif 0x00010000 : AssertRC(rc, 13680)

    //Determine which pins are to be used
    CONNPin = ConfigKeyGet( CONNPinConfigID)   
    ENCRPin = ConfigKeyGet( ENCRPinConfigID)   

    //Setup CONN as output GPIO for connection status
    if CONNPin>= 0 then
        rc = GPIOSetFunc(CONNPin, 2, 0) //0 = initial is low, 1 = initial is high
        #cmpif 0x00010000 : AssertRC(rc, 13720)
    endif
    //Setup ENCR as output GPIO for connection encryption status
    if ENCRPin>= 0 then
        rc = GPIOSetFunc(ENCRPin, 2, 0) //0 = initial is low, 1 = initial is high
        #cmpif 0x00010000 : AssertRC(rc, 13720)
    endif
endsub

//------------------------------------------------------------------------------
// Initialise
//------------------------------------------------------------------------------
sub Initialise()
    //cache the login password
    LoginPassword$   = ConfigKeyGet$( LoginPswrdConfigID ) + "\r"
    LoginPasswordLen = strlen(LoginPassword$)
    
    
endsub


//------------------------------------------------------------------------------
// Configures the UART
//------------------------------------------------------------------------------
function SetupUART()
    //Sets up the UART to use the required baud rate, flow control and parity options
    dim TmpStr$, UARTSpeed, UARTTxBuf, UARTRxBuf, UARTFlags$
    
    rc = UARTInfo(0)
    if (rc != 0) then
        //UART is opened, close
        UARTClose()
    endif

    //Read UART Baud rate and check it is sane
    UARTSpeed = ConfigKeyGet( UARTSpeedConfigID)
    //Read UART Tx buffer size and check it is sane
    UARTTxBuf = ConfigKeyGet( UARTTxBufConfigID)    
    //Read UART Rx buffer size and check it is sane
    UARTRxBuf = ConfigKeyGet( UARTRxBufConfigID)
    //Read UART flags and check it is sane
    UARTFlags$ = UartConfigParameters

    //Reopen the UART
    rc = UartOpen(UARTSpeed, UARTTxBuf, UARTRxBuf, UARTFlags$)
    #cmpif 0x00010000 : AssertRC(rc, 14020)
endfunc 1

//------------------------------------------------------------------------------
// Timer 0 handler - disconnect
//------------------------------------------------------------------------------
function HndlrTmr0()
    if (ConnectionID != 0) then
        //Client is connected, disconnect
        rc = BleDisconnect(ConnectionID)
    endif
endfunc 1

//------------------------------------------------------------------------------
// Timer 1 handler - abort login mode
//------------------------------------------------------------------------------
function HndlrTmr1()
    _bridge()
    #cmpif 0x80000000 : DbgMsg("Login Timer Expired")
endfunc 1


//******************************************************************************
// Start up code from here -equivalent to main() in a 'C' application
//******************************************************************************

Initialise()

rc = SetupUART()
if (rc != 1) then
    //Error with non-volatile storage
    ApplicationError = 1
    WAITEVENT
endif
SetupMode()
SetupGPIOs()
rc = SetupGapService()
if (rc != 1) then
    //Error with non-volatile storage
    ApplicationError = 1
    WAITEVENT
endif
rc = OpenVSPService()
if (rc != 1) then
    //Error with non-volatile storage
    ApplicationError = 1
    WAITEVENT
endif
CreateAdverts()
StartAdvertising()


//******************************************************************************
//Setup event handlers
//******************************************************************************
ONEVENT EVBLEMSG CALL HndlrBleMsg

//Set up uart/vsp handlers depending on mode
if (ApplicationError == 0) then
    #cmpif 0x00000060 : if (AppMode == AppModeAppCmd) || (AppMode == AppModeAppLogin) then
        //Application command mode: parse commands sent via VSP or UART on the module depending on which is enabled
        #cmpif 0x00000040 : ONEVENT EVVSPRX CALL HndlrVSPCommand
        #cmpif 0x00000020 : ONEVENT EVUARTRX CALL HndlrUARTCommand
        #cmpif 0x00000040 : ONEVENT EVVSPTXEMPTY CALL SendBufferedData
        #cmpif 0x00000020 : ONEVENT EVUARTTXEMPTY CALL SendBufferedData
    #cmpif 0x00000060 : else
        //Application bridge mode: enable bridging function to handle sending/receiving data from VSP or UART
        ONEVENT EVVSPRX CALL HndlrBridge
        ONEVENT EVUARTRX CALL HndlrBridge
        ONEVENT EVVSPTXEMPTY CALL HndlrBridge
        ONEVENT EVUARTTXEMPTY CALL HndlrBridge
    #cmpif 0x00000060 : endif
endif

ONEVENT EVTMR0 CALL HndlrTmr0   //disconnects
ONEVENT EVTMR1 CALL HndlrTmr1   //Abort Login Mode

//******************************************************************************
//Wait in a lower-power mode for an event to occur
//******************************************************************************
WAITEVENT
