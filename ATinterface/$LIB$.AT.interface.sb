// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Copyright (c) 2017, Laird                                                  ++
//                                                                            ++
// Permission to use, copy, modify, and/or distribute this software for any   ++
// purpose with or without fee is hereby granted, provided that the above     ++
// copyright notice and this permission notice appear in all copies.          ++
//                                                                            ++
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES   ++
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF           ++
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR    ++
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES     ++
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN      ++
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR ++
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.                ++
//                                                                            ++
// SPDX-License-Identifier:ISC                                                ++
//                                                                            ++
// ************************************************************************** ++
// A smartBASIC library that exposes an AT Interface to control a VSP         ++
// or non-VSP connection and advertise or scan that will run on a Laird       ++
// module with the following compile time optional features:-                 ++
//    + AT+GCTM command enabled to query peer's gatt table schema             ++
//    + If error handler called then module will reset and restart            ++
//    + VSP Overrun Event is enabled when there is a VSP incoming overrun     ++
//    + Long Range Connection capability enabled                              ++
//    + NFC related commands enabled                                          ++
//    + Low Power Uart operation - port closed when there is no activity      ++
// ************************************************************************** ++
//                                                                            ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminalX downloads the app to the module it will be saved   ++
// +++++  as a file with filename $autorun$ which means it will run           ++
// +++++  automatically on reset.                                             ++
// +++++  The File System can be queried using the command AT+DIR             ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// -------------------
// ATinterface Library Version
// -------------------
#define LibVer                 "2.10"  //Library version  (ATI23)
//
//******************************************************************************
// Compiler/Debug options
//******************************************************************************
//   ======================================================
//   Conditional Compile Masks (they can be additive)
//   ------------------------------------------------------
//
// Higher 16 bits used for feature set
//   0x00000000 :
//
// Lower 16 bits used for debugging (Collectively == DebugMessages)
//   0x00000001 : Enable debugging messages
//   0x00000002 : Enable Asserts printed out of UART
//   0x00000004 : Enable DbgXXX messages
//   0x00000008 : Enable Conn Parameters display
//   0x00000010 : Enable PHY Change debugging (+PHYchng)
//   0x00000040 : Enable vsp MDM change activity for debugging (+MDMCHNG)
//   0x00000080 : Enable VSPRXOVRN debug print
//   0x00000100 : Enable low power uart debugging
//   0x00000200 : Enable BUTTON1 & BUTTON2 related debugging
//   0x00000400 : Enable printing of all adverts for debugging
//   0x00004000 : Enable S Register interface debugging
//   0x00008000 : Enable arg parsing prints
//
// Upper 16 bits for features (Collectively == AllFeatures)
//   0x00010000 : Include Verbose Code for setting defaults (VerboseDefRegisterCreation)
//   0x00020000 : Enable TableMap command AT+GCTM
//   0x00040000 : On ERROR call reset
//   0x00080000 : Enable the EVVSPRXOVRN event handler  +VSPOVRN
//   0x00100000 : Enable Long Range Capability  +LRANGE
//   0x00200000 : Enable NFC    +NFC
//   0x00400000 : Enable LowPower Uart Operation  +LOWPWR
//   ======================================================
// -------------------
// Application History
// -------------------
//
//  2.10
//    * Max limit for SReg 109 is 31 for 652 and 47 for 654
//    * Added SReg117 to add DCD output for VSP operation (Low for connection)
//
//  2.00
//    * Added low power uart operation
//    * Added NFC AT commands for Type 2 functionality
//    * Converted filename to $LIB$.AT.interface.sb so that we can include in
//        $autorun$.AT.interface.BL652._.sb  and $autorun$.AT.interface.BL654._.sb
//    * AssertRC changed so that it does not take rc argument to reduce code size
//    * Cater for BLE_RESOURCES return code from BLGATTCWRITECMD() function
//    * SReg100 now allows DLE and PHY specification
//        Data Length Extension to increase throughput
//
//  1.50
//    New firmware returns a different resultcode when there are no more writecmd buffers
//    so routine HndlrUartRxVspOutFC() updated so that it looks for it.
//    Aso the 'case else' in that same select exits the function
//
//  1.40
//    Merged 1.10 and 1.30 changes into one file
//
//  1.30
//    When getting tablemap with the GCTM command, it copes if a service is empty
//
//  1.10
//    Allow scanning in STATE_nonVSP_CONNECTED state - but only if timeout
//    value is non-zero
//
//  1.00 "22/June/2017"
//    BL652 First public deployment via the BL652 apps repository in github
//
//  0.20 "1/June/2017"
//    Througput 127kbps bi-directional (total 254kbps) without data lenght
//    extension, SRreg100 enhanced with extra bit to allow 6 packets per
//    connection interval. By default that bit is set to give 6 pkts
//
//  0.10 "24/May/2017"
//    Initial Release. @7.5ms conn interval
//       Throughput : 10.5kbps  Client->Server
//                    64kbps    Server->Client
//
//******************************************************************************

//******************************************************************************
// Definitions
//******************************************************************************

//------------------------------------------------------------------------------
//It is NOT recommended that the following be modified for customisation - do so with
//care, and it is suggested it is fed back to Laird to ease your maintenance in
//the future if laird modifies and enhances this application
//------------------------------------------------------------------------------

//This defines the maximum number of uuid handles
#define MAX_UUID_HANDLES                          16

//This defines the maximum number of elements in metadata array
#define MAX_METADATA_HANDLES                      4

//Maximum comma seperated arguments allowed in an AT command
#define MAX_ARGS_IN_ATCMD                         10

//ASCII characters
#define CHR_ASCII_SPACE                           0x20

//Invalid connection handle
#define INVALID_CONN_HANDLE                       0

//Invalid uuid handle
#define INVALID_UUID_HANDLE                       -1

//Index for the handle for the VSP connection
#define HCONN_VSP                                 0

//Timer used for encryption timeout
#define TMRNUM_ENCR_WAIT                          0
#define TMRNUM_DATA_PUMP                          1
#define TMRNUM_LOWPWR_UART                        2

//Maximum length of attibute length in metadata when creating gatt table
#define MAX_ATTRIBUTE_LEN                         250

//Only check for carets in uart buffer if there is at least this
//much space in the vsp tx buffer
#define MIN_SPACE_IN_VSPTXBUF_TO_CHECK_FOR_CARETS  20

//AT Command letter
#define ATCMD_EMPTY                               0
#define ATCMD_D                                   0x44
#define ATCMD_F                                   0x46
#define ATCMD_I                                   0x49
#define ATCMD_S                                   0x53
#define ATCMD_W                                   0x57
#define ATCMD_X                                   0x58
#define ATCMD_Z                                   0x5A
#define ATCMD_PERCENT                             0x25
#define ATCMD_AMPERSAND                           0x26
#define ATCMD_PLUS                                0x2B

//AT Responses for VSP connect ( starts at 80 because HSI reason is up to 64 )
#define CONN_OK                                     0
#define CONN_ERROR_BLECONNECT                       80
#define CONN_ERROR_INVALID_ADDRESS                  81
#define CONN_ERROR_CMDPINSTATE                      82
#define CONN_ERROR_TOOMANYCONNECTIONS               83
#define CONN_ERROR_TIMEOUT                          84
#define CONN_ERROR_OUTOFMEM                         85
#define CONN_ERROR_UNENCRYPTED                      86
#define CONN_ERROR_NOVSPSERVICE                     87
#define CONN_ERROR_PAIRUI                           88
#define CONN_ERROR_USER_DISCON                      90
#define CONN_ERROR_AUTHLINK_REQUIRED                91
#define CONN_SUSPEND                                -1

//types of adverts
#define ADV_IND                                     0
#define ADV_DIRECT_IND                              1
#define ADV_SCAN_IND                                2
#define ADV_NONCONN_IND                             3

//Bonding KeyInfo
#define BONDING_KEYINFO_MITM_AUTHENTICATED          1
#define BONDING_KEYINFO_AUTO_DELETE_ROLLING         2
#define BONDING_KEYINFO_IRK_EXISTS                  4
#define BONDING_KEYINFO_CSRK_EXISTS                 8
#define BONDING_KEYINFO_LTK_AS_SLAVE_EXISTS         16
#define BONDING_KEYINFO_LTK_AS_MASTER_EXISTS        32

//Bond trust context
#define BOND_TRUSTED_AS_PERIPHERAL                  0
#define BOND_TRUSTED_AS_CENTRAL                     1

//MITM requirement bit masks
#define BLE_ENCRYPT_MITM_NOT_REQUIRED               0
#define BLE_ENCRYPT_MITM_REQUIRED                   1

// Minimum LTK size reqruirement
#define LTK_MINIMUM_SIZE                            7

//Values in curState variable
#define STATE_INIT                                  0
#define STATE_IDLE_nonVSP                           10
#define STATE_IDLE_VSP                              20
#define STATE_SCAN_VSP                              30
#define STATE_VSP_FAST_CONNECTED                    40
#define STATE_VSP_CONNECTING                        50
#define STATE_VSP_WAIT_ENCRYPT                      51
#define STATE_VSP_GET_HANDLES                       52
#define STATE_VSP_WRITE_CCCDS                       53
#define STATE_VSP_PAIRING                           54
#define STATE_VSP_DISCONNECTING                     55
#define STATE_nonVSP_CONNECTING                     60
#define STATE_nonVSP_CONNECTED                      80
#define STATE_VSP_IN_WAIT_ENCR                      70
#define STATE_VSP_CARET_CONNECTED                   90

//MsgID for SendMsgApp so that we can serialise processes and also used
//to invoke functionality which is not compiled yet
#define MSGAPP_PROCESS_UART                         0
#define MSGAPP_ENTER_VSPOUT_CONN_STATE              1
#define MSGAPP_ENTER_VSPIN_CONN_STATE               2
#define MSGAPP_ENTER_NONVSP_CONN_STATE              3
#define DONTCARE_CTX                                0

//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0    //msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1    //msgCtx = connection handle
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9    //msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                         10   //msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                 11   //msgCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE                14   //msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL           15   //msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER            16   //msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                     17   //msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                        18   //msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING            19   //msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                      20   //msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                 21   //msgCtx = connection handle
#define BLE_EVBLEMSGID_BOND_ADDFAIL                     22   //msgCtx = connection handle
#define BLE_EVBLEMSGID_SRVCCHNG_IND_SENT                23   //msgCtx = connection handle
#define BLE_EVBLEMSGID_SRVCCHNG_IND_CNF                 24   //msgCtx = connection handle
#define BLE_EVBLEMSGID_OOB_AVAILABLE_REQEST             25   //msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTHENTICATION_FAILED            26   //msgCtx = connection handle
#define BLE_EVBLEMSGID_LESC_PAIRING                     27   //msgCtx = connection handle
#define BLE_EVBLEMSGID_LESC_OOB_REQUEST                 28   //msgCtx = connection handle

//Keytype values that arrive in message BLE_EVBLEMSGID_AUTH_KEY_REQUEST
#define BLE_GAP_AUTH_KEY_TYPE_NONE        0x00   // No key (may be used to reject)
#define BLE_GAP_AUTH_KEY_TYPE_PASSKEY     0x01   // 6-digit Passkey
#define BLE_GAP_AUTH_KEY_TYPE_OOB         0x02   // Out Of Band data

//defines associated with uart low power operation
#define UART_SIONUM_RX                             8
#define UART_SIONUM_CTS                            7
#define UART_SIONUM_TX                             6
#define UART_SIONUM_RTS                            5
#define UART_IDLE_REPOLL_TIMEOUT_MS                1000
#define UART_DEFAULT_LOWPWR_CMDPIN                 24

//These are ID's used to help with reuse of helper functions
#define CMD_I_LDSC                                 0
#define CMD_I_PAIR                                 1
#define CMD_I_LENC                                 2
#define CMD_I_GCTM                                 3

#define CMD_IS_NOTIFY                              0
#define CMD_IS_INDICATE                            1
#define CMD_IS_LOCALWRITE                          2

#define DEFAULT_ATT_MTU                            23
#define DEFAULT_ATTRIBUTE_SIZE                     (DEFAULT_ATT_MTU-3)

#define ATTRIBUTE_MTU_KEY_ID                       211    // CFG ID 211
#define ATTRIBUTE_DATA_LENGTH_KEY_ID               212    // CFG ID 212
#define USE_STRINT_IN_EVENTS_KEY_ID                213    // CFG ID 213
#define ENABLE_HIGH_BANDWIDTH_KEY_ID               214    // CFG ID 214
#define BLE_MAX_PACKET_LENGTH_KEY_ID               216    // CFG ID 216

#define FALSE                                      0
#define TRUE                                       (!0)

//NFC related
#define INVALID_NFC_HANDLE                         0xFFFFFFFF
#define INVALID_NDEF_HANDLE                        0xFFFFFFFF
#define NFC_DEFAULT_TAG_SIZE                       128
#define NFC_MIN_TAG_SIZE                           128
#define NFC_MAX_TAG_SIZE                           512

#define NFC_TNF_EMPTY                             0x00 // The value indicates that there is no type or payload associated with this record.
#define NFC_TNF_WELL_KNOWN                        0x01 // NFC Forum well-known type [NFC RTD].
#define NFC_TNF_MEDIA_TYPE                        0x02 // Media-type as defined in RFC 2046 [RFC 2046].
#define NFC_TNF_ABSOLUTE_URI                      0x03 // Absolute URI as defined in RFC 3986 [RFC 3986].
#define NFC_TNF_EXTERNAL_TYPE                     0x04 // NFC Forum external type [NFC RTD].
#define NFC_TNF_UNKNOWN_TYPE                      0x05 // The value indicates that there is no type associated with this record.
#define NFC_TNF_UNCHANGED                         0x06 // The value is used for the record chunks used in chunked payload.
#define NFC_TNF_RESERVED                          0x07 // The value is reserved for future use.
#define NFC_MSGIN_NFCFIELDOFF                     2
#define NFC_MSGIN_NFCFIELDON                      3
#define NFC_MSGIN_NFCTAGREAD                      7

#define SIOTYPE_DIN                               1
#define SIOTYPE_DOUT                              2
#define SIOTYPE_AIN                               3

#define INPUT_PULL_NONE                           0
#define INPUT_PULL_DOWN                           1
#define INPUT_PULL_UP                             2

#define OUTPUT_INIT_LOW                           0
#define OUTPUT_INIT_HI                            1

#define DCD_ASSERT_STATE                          0
#define DCD_DEASSERT_STATE                        1

//******************************************************************************
// Global Variable Declarations
//******************************************************************************

//Result code variable (used for checking if a function completed successfully or not)
dim rc

//Don't care value
dim dontcare
dim dontcare$
dim tmpDta$

//Contains current state, see STATE_XXX
dim curState : curState=STATE_INIT
//Contains the state as we will need it later before entering a non-idle state
dim oldIdleState

//UART send/receive buffer (for application command mode)
dim UARTSndBuf$ : UARTSndBuf$ = ""
dim UARTRecBuf$ : UARTRecBuf$ = ""
dim UARTbaud, UARTTxBuf, UARTRxBuf, UARTFlags$

//Terminator for commands in command mode
dim termStr$ : termStr$ = "\r"

//OK or ERROR response strings
dim ok$ : ok$ = "\nOK"
dim er$ : er$ = "\nERROR "
//If the following is zero then the AT parser is suspended
dim atParse : atParse=1

//This array is updated by ExtractXxxxx() functions
dim sArg$[MAX_ARGS_IN_ATCMD]
//This array is updated if an integer needs to be extracted from sArg$
dim nArg[MAX_ARGS_IN_ATCMD]

//Cache of SReg 100
dim startflags

//Holds the timeout value that will disconnect a device that connects but doesn't
//encrypt the connection within the time (if the encryption flag is enabled)
dim encDisconTime   //if 0 then encryption via S102 is not requested

//This is the serice uuid that was submitted to BleVspOpen
dim handleVspServiceUuid : handleVspServiceUuid=0

//When scanning using AT+BLS, this is the pattern to search for in each advert report
dim scnPattern$
//This contains the length of the pattern$ string
dim scnPatternLen
//When scanning using AT+BLS, this is the minimum rssi to allow
dim scnRssi

//these variables are used in the adv_report handler and are defined as globals
//to improve speed
dim periphAddr$, advData$, nDiscarded, nRssi, nme$

//This is the most recent i/o capability submitted to the stack
dim pairIoCapCache

//The following is non-zero if BleVspOpen() was successful and it implies that the
//vsp service has been added to the gatt table
dim vspAdded

//these are advert and scan reports that will be submitted when not in VSP mode
//and advertising
dim idleAdvRpt$, idleScnRpt$, idleAdvType, idleAdvIntvlMs

//These are the cache for the Scan related parameters
dim scanIntervalMs, scanWindowMs, scanType

//This is the pin to use to enter command mode when in FAST mode. If <0 then it
//implies FAST mode as been disabled
dim vspCmdModePin

//This is the pin to use the connection status of VSP like the DCD pin in modems.
//Which means 0 is for -- there is a connection and 1 is for no connection
dim vspDcdPin

//Total number of connections active
dim connCount

//this is nonzero if gatt client is open
dim fGattClient : fGattClient=0

// uuid handles.
dim uuidHandles[MAX_UUID_HANDLES]

//metadata handles
dim metaHandles[MAX_METADATA_HANDLES+1]

// Connection handles. Index 0 is used for Vsp Connection (as they are mutually exclusive)
dim connHandles[MAX_CONNECTIONS+1]

//Char Handles that we manage - only index is sent to host
dim charHandles[MAX_CHARACTERISTICS+1]  //index 0 is never used
dim numOfChars : numOfChars=0

//Scan advert report display format
// 0 : default (abbreviated)
// 1 : full in hex format
dim scnFmt

//Outgoing VSP char/desc query array and array element definition is as per the
//#defines that follow
#define VSP_ATTR_INDEX_RX            0
#define VSP_ATTR_INDEX_TX            1
#define VSP_ATTR_INDEX_MDMIN         2
#define VSP_ATTR_INDEX_MDMOUT        3
#define VSP_ATTR_INDEX_TX_CCCD       4
#define VSP_ATTR_INDEX_MDMOUT_CCCD   5
#define VSP_ATTR_MAX_INDEXES         6
dim vspSvcUuid, hVspCccdUuids[VSP_ATTR_MAX_INDEXES], hVspAttr[VSP_ATTR_MAX_INDEXES]  //nArg[] i used to store CharUuid Handles

// this is the array index into hVspCccdUuids & hVspAttr when querying for attribute handles
dim vspFindIndex

//If a cccd write results in an error then this contains the status code
dim vspDisconSts
//If this is 1 then we are waiting for an ack from the VSP peer
dim vspAllowTx
//If this is 1 then we are waiting for an ack from the VSP peer
dim vspAllowRx
//This is the maximum attribute length for vsp
dim vspAttrMaxLen
//This is the maximum data chunk length based on negotiated ATT_MTU
dim vspChunkLen
//This is used to count the number of ^ in slow mode to drop the connection
dim vspEscCount
//This is the tick count when a ^ is recieved in slow mode
dim vspEscStart
//This is the max count of receiced ^ chrs to trigger a disconnect
dim vspEscCountMax
//This is the min interval between two ^ to count towards escaping towards a disconnect
dim vspEscMinIntrvl
//The following is the escape string that needs to entered vspEscCountMax times to disconnect
dim vspEscString$
dim vspEscStringLen
//Following will be non-zero if the VSP connection is outgoing
dim vspIsOutGoing

//This is the advert report prefix
dim advPrefix$

//Gatt Server use - current service handle being defined, non-0 if in the middle of
//entering a service
dim svcHandle : svcHandle=0

//Gatt Server use - current characteristic handle being defined, non-0 if in the middle of
//entering a characteristic
dim chrInProg : chrInProg=0

//made this a global variables for various handlers & functions to use so that
//code size if reduced
dim charIdx

//This is used to improve the datapump when sending data out to the slave in vsp mode
//It is used to start a timer so that BleGattcWriteCmd() can be called again.
dim vspPumpToutMs

//Following used to help debug Vsp MODEM change activity
#cmpif 0x00000040 : dim vtxcnt : vtxcnt=0
#cmpif 0x00000040 : dim vrxcnt : vrxcnt=0

//NFC related
#cmpif 0x00200000 : dim nfcHandle       //returned by NfcOpoen
#cmpif 0x00200000 : dim ndefHandle      //returned by NfcNdefMsgNew
#cmpif 0x00200000 : dim nfcSenseCnt     //ATI50
#cmpif 0x00200000 : dim nfcReadCnt      //ATI51

dim fLowPowerUart : fLowPowerUart = 0
#cmpif 0x00400000 : fLowPowerUart = 1
#cmpif 0x00400000 : dim uartIdleToutMs

//******************************************************************************
// Initialise Global Variable
//******************************************************************************

#cmpif 0x00200000 : nfcHandle  = INVALID_NFC_HANDLE
#cmpif 0x00200000 : ndefHandle = INVALID_NDEF_HANDLE
#cmpif 0x00200000 : nfcSenseCnt = 0
#cmpif 0x00200000 : nfcReadCnt  = 0

//******************************************************************************
// Function and Subroutine definitions
//******************************************************************************

#include "$LIB$.debug.code.sb"

//------------------------------------------------------------------------------
// Change state
//------------------------------------------------------------------------------
sub NewState( nState )
  if nState != curState then
    #cmpif 0x00000004 : sprint #dbgmsg$, "NewState = "; nState
    #cmpif 0x00000004 : DbgMsg(dbgmsg$)
    curstate = nState
  endif
endsub

//------------------------------------------------------------------------------
// Save state info
//------------------------------------------------------------------------------
sub SaveState( byref prState )
  prState = curstate
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub  GetFirmwareVersion(dontcare$)
  dim val, p,mj,mn,b

  val=sysinfo(3)
  b =(val    ) & b'111111
  mn=(val>> 6) & b'111111111111
  mj=(val>>18) & b'111111
  p =(val>>24)

  sprint #dontcare$,p;".";mj;".";mn;".";b
endsub

//------------------------------------------------------------------------------
// Function that will convert a string to lowercase - insitu
//------------------------------------------------------------------------------
sub StrToLower$(byref Text$)
  //Takes a string and replaces uppercase letters with lowercase letters
  dim i, chr
  i = strlen(Text$)-1
  while (i >= 0)
    chr = StrGetChr(Text$, i)
    if (chr >= 65 && chr <= 90) then
      rc = StrSetChr(Text$, chr+32, i)
    endif
    i = i-1
  endwhile
endsub

//------------------------------------------------------------------------------
// Returns the single letter AT command from the string
//------------------------------------------------------------------------------
function GetAtCmdLetter(byref cmdStr$) as integer
  dim drop : drop=0
  dim retVal

  while 1
    retVal = StrGetChr(cmdStr$,drop)
    if retVal<0 then
      StrShiftLeft(cmdStr$,drop)
      exitfunc RSP_OK
    elseif retVal>CHR_ASCII_SPACE then
      drop=drop+1
      StrShiftLeft(cmdStr$,drop)
      exitfunc retVal
    endif
    //this is a whitespace
    drop=drop+1
  endwhile
endfunc RSP_OK

//------------------------------------------------------------------------------
// Strip "" from str$ if they exist
//------------------------------------------------------------------------------
sub TrimQuotes(str$)
  dim len
  if strgetchr(str$,0)==0x22 then  //check for beginning "
    len = strlen(str$)
    if len > 2 then
      if strgetchr(str$,(len-1))==0x22 then //check for ending "
        str$ = mid$(str$,1,(len-2))
      endif
    elseif len == 2 then
      str$=""
    endif
  endif
endsub

//------------------------------------------------------------------------------
// Checks if the string is quoted
//------------------------------------------------------------------------------
function IsQuoted(str$)
  dim len
  if strgetchr(str$,0)==0x22 then  //check for beginning "
    len = strlen(str$)-1
    if len >= 1 then
      if strgetchr(str$,len)==0x22 then //check for ending "
        exitfunc 1
      endif
    endif
  endif
endfunc 0

//------------------------------------------------------------------------------
// Returns 0 if the value is outside min and max
//------------------------------------------------------------------------------
function InRange(newVal,minVal,maxVal) as integer
  if newVal<minVal then
    exitfunc 0
  elseif newVal>maxVal then
    exitfunc 0
  endif
endfunc 1

//------------------------------------------------------------------------------
// If the config value was different and got updated successfully, then the
// variable nUpdated is incremented
//------------------------------------------------------------------------------
sub SetConfigKey(keyId, newVal, byref nUpdated)
  dim curVal
  rc=NvCfgKeyGet(keyId,curVal)
  if rc==0 then
    if newVal != curVal then
      rc=NvCfgKeySet(keyId,newVal)
      if rc==0 then
        nUpdated=nUpdated+1
      endif
    endif
  endif
endsub

//******************************************************************************
//******************************************************************************
//******************************************************************************
// Initialisation values for sregister caches ...
//
// These values are created by running the application "sreg.defaults.creation.sb"
// and then copy/pasting its output here - verbatim.
//
// This technique is used to reduce the size of the .uwc file of the main sb file
//******************************************************************************
//******************************************************************************
//******************************************************************************
#include "$LIB$.SRegInterface.sb"
//******************************************************************************
//******************************************************************************
//******************************************************************************

//------------------------------------------------------------------------------
// get node index number from connection handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CONNECTIONS
//------------------------------------------------------------------------------
function GetIdxFromHConn(hConn as integer) as integer
  dim i
  //search for the address through the node cache which will also unconnected
  for i = 1 to MAX_CONNECTIONS  //start from index 1 because 0 is dedicated for VspConnection
    if connHandles[i]==hConn then
      exitfunc i
    endif
  next
endfunc 0

//------------------------------------------------------------------------------
// get free node index number for connection handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CONNECTIONS
//------------------------------------------------------------------------------
function GetFreeIdx() as integer
  dim i
  //search for an empty handle
  for i = 1 to MAX_CONNECTIONS
    if connHandles[i]==INVALID_CONN_HANDLE then
      exitfunc i
    endif
  next
endfunc 0

//------------------------------------------------------------------------------
// Save a charactertic handle to the managed array so that we can report an
// index number to the host.
//------------------------------------------------------------------------------
function AddCharHandle(charH,byref nIdx) as integer
  if numOfChars<MAX_CHARACTERISTICS then
    numOfChars = numOfChars+1
    nIdx = numOfChars
    charHandles[nIdx]=charH
    exitfunc RSP_OK
  endif
endfunc RSP_TOO_MANY_CHARACTERISTICS

//------------------------------------------------------------------------------
// get node index number from characteristc handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CHARACTERISTICS
//------------------------------------------------------------------------------
function GetIdxFromHChar(hChar as integer) as integer
  dim i
  //search for the address through the node cache which will also unconnected
  for i = 1 to MAX_CHARACTERISTICS  //start from index 1 because 0 is dedicated for VspConnection
    if charHandles[i]==hChar then
      exitfunc i
    endif
  next
endfunc 0

//------------------------------------------------------------------------------
// The rest of the str$ should be up to MAX_ARGS_IN_ATCMD arguments seperated by ','
// returns RSP_OK if ok and 'args' is updated with number of args and the global
// string array sArg$[] contains the arguments (but not the ',')
// If any arguments have "" delimitors they are removed
//------------------------------------------------------------------------------
function ExtractArgsCSV(str$,byref args, minargs,maxargs)
  dim tlen, commaExp, chr

  #cmpif 0x00000003 : AssertBound(minargs,0,MAX_ARGS_IN_ATCMD,2870)
  #cmpif 0x00000003 : AssertBound(maxargs,minargs,MAX_ARGS_IN_ATCMD,2880)

  args=0
  commaExp=0  //1 for expected

  //clear up to maxargs
  for chr=0 to maxargs
    sArg$[chr]=""
  next

  //special case check if maxargs is 0 and the line is not empty
  tlen = ExtractStrToken(str$,dontcare$)
  if tlen>0 then
    //first argument will not have a preceding comma, unless it is missing
    if strcmp(dontcare$,",")==0 then
      //unexpected comma so empty string
      sArg$[0]=""
    else
      //remove delimiting "" quotes
      TrimQuotes(dontcare$)
      //save it in the args array
      sArg$[0]=dontcare$
      //now extract another token and that could be a comma
      tlen = ExtractStrToken(str$,dontcare$)
    endif
    args=1
  endif

  //At this point dontcare$ has to be comma or empty

  //now parse the string further
  while tlen>0
    //check if too many args already encountered
    if args>=maxargs then
      exitfunc RSP_ERROR_TOOMANYARGS
    endif

    //this has to be a comma
    if strcmp(dontcare$,",")==0 then
      //increment the count
      sArg$[args]=""
    else
      exitfunc RSP_ERROR_SYNTAX_ERROR
    endif

    //now extract another token and that should be an arg, a comma, or empty
    tlen = ExtractStrToken(str$,dontcare$)
    if tlen>0 then
      if strcmp(dontcare$,",")==0 then
        //got an empty parameter so do nothing here, args count incremented later
      elseif strcmp(dontcare$,"-")==0 then
        //looks like there could be a negative number
        if strlen(str$) > 0 then
          chr = StrGetChr(str$,0)
          if (chr>=0x30)&&(chr<=0x39) then
            //it is a decimal digit
            tlen = ExtractStrToken(str$,dontcare$)
            //save it in the args array
            sArg$[args]="-" + dontcare$
            //now extract another token and that should be a comma or empty
            tlen = ExtractStrToken(str$,dontcare$)
          endif
        else
          //there are no more characters
          sArg$[args]=dontcare$
          tlen=0
        endif
      else
        //remove delimiting "" quotes
        TrimQuotes(dontcare$)
        //save it in the args array
        sArg$[args]=dontcare$
        //now extract another token and that should be a comma or empty
        tlen = ExtractStrToken(str$,dontcare$)
      endif
    endif
    args = args+1
  endwhile

  //#cmpif 0x00000004 : dim i
  //#cmpif 0x00000004 : DbgMsgVal ("args=",args)
  //#cmpif 0x00000004 : for i = 0 to (MAX_ARGS_IN_ATCMD-1)
  //#cmpif 0x00000004 :   print "\n## sArg$[";i;"]=";sArg$[i]
  //#cmpif 0x00000004 : next

  //check if too few args parsed
  if args < minargs then
    exitfunc RSP_ERROR_TOOFEWARGS
  endif

endfunc RSP_OK

////------------------------------------------------------------------------------
//// The rest of the str$ should not be up to MAX_ARGS_IN_ATCMD arguments which are
//// whitespace delimited as opposed to ',' delimited as in ExtractArgsCSV()
////
//// As it is not currently called, but could be in the future, it is commented out
////------------------------------------------------------------------------------
//function ExtractArgsStr(str$,byref args, minargs,maxargs)
//  dim tlen
//
//  #cmpif 0x00000003 : AssertBound(minargs,0,MAX_ARGS_IN_ATCMD,3600)
//  #cmpif 0x00000003 : AssertBound(maxargs,minargs,MAX_ARGS_IN_ATCMD,3610)
//
//  args=0
//
//  //Extract first token
//  tlen = ExtractStrToken(str$,dontcare$)
//  //then loop until max done
//  while tlen>0
//    //check if too many args already encountered
//    if args>=maxargs then
//      exitfunc RSP_ERROR_TOOMANYARGS
//    endif
//
//    //remove delimiting "" quotes
//    TrimQuotes(dontcare$)
//    //save it in the args array
//    sArg$[args]=dontcare$
//    #cmpif 0x00008000 : print "\narg=";dontcare$
//    //increment
//    args=args+1
//    //now extract another token and that should be a comma or empty
//    tlen = ExtractStrToken(str$,dontcare$)
//
//  endwhile
//
//  //check if too few args parsed
//  if args < minargs then
//    exitfunc RSP_ERROR_TOOFEWARGS
//  endif
//
//endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function SArgConvertToInt( ndx, defval, mn, mx)
  dim val

  #cmpif 0x00000003 : AssertBound(ndx,0,(MAX_ARGS_IN_ATCMD-1),5720)

  if strlen(sArg$[ndx])==0 then
    //not specified so set to default
    val = defval
  else
    //a threshold has been specified so attempt to convert to an integer
    if ExtractIntToken(sArg$[ndx],val)==0 then
      exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
  endif
  if (val<mn)||(val>mx) then
    exitfunc RSP_ERROR_VALUE_NOT_VALID
  endif
  nArg[ndx] = val
endfunc RSP_OK

//------------------------------------------------------------------------------
// Close the uart if rx/tx buffers are empty
//------------------------------------------------------------------------------
#cmpif 0x00400000 : sub UartCloseConditional()
#cmpif 0x00400000 :   //close only if the cmdpin is deasserted
#cmpif 0x00400000 :   if GpioRead(vspCmdModePin)==0 then
#cmpif 0x00400000 :     //host does not care if we close the uart
#cmpif 0x00400000 :
#cmpifand 0x00400104 :      DbgMsg("Uart closing   ")
#cmpifand 0x00400104 :      //Wait for tx buffer to flush
#cmpifand 0x00400104 :      while UartInfo(5)>0
#cmpifand 0x00400104 :      endwhile
#cmpif 0x00400000 :
#cmpif 0x00400000 :     if UartInfo(0) then
#cmpif 0x00400000 :       //Uart is open so try to close it if rx/tx ring buffers are empty
#cmpif 0x00400000 :       rc=UartCloseEx(1)
#cmpif 0x00400000 :     endif
#cmpif 0x00400000 :
#cmpif 0x00400000 :     if UartInfo(0) then
#cmpif 0x00400000 :       //the uart is still open so restart the time
#cmpif 0x00400000 :       TimerStart(TMRNUM_LOWPWR_UART,UART_IDLE_REPOLL_TIMEOUT_MS,0)
#cmpifand 0x00400104 :    DbgMsg("Uart Tmr STARTp")
#cmpif 0x00400000 :     else
#cmpif 0x00400000 :       //closed, so configure the TX and RTS as outputs and adjust outputs
#cmpif 0x00400000 :       rc=gpiosetfunc(UART_SIONUM_TX,SIOTYPE_DOUT,OUTPUT_INIT_HI)   //TX set high on default
#cmpifand 0x00400103 :    AssertRC(10090)
#cmpif 0x00400000 :       rc=gpiosetfunc(UART_SIONUM_RTS,SIOTYPE_DOUT,OUTPUT_INIT_HI)  //RTS set high to deassert
#cmpifand 0x00400103 :    AssertRC(10110)
#cmpif 0x00400000 :       rc=GpioSetFunc(UART_SIONUM_RX,SIOTYPE_DIN,INPUT_PULL_UP)    //RX Pull high
#cmpifand 0x00400103 :    AssertRC(10130)
#cmpif 0x00400000 :       rc=GpioSetFunc(UART_SIONUM_CTS,SIOTYPE_DIN,INPUT_PULL_DOWN) //CTS Pull low
#cmpifand 0x00400103 :    AssertRC(10150)
#cmpif 0x00400000 :     endif
#cmpif 0x00400000 :else
#cmpif 0x00400000 :   //Start the uart inactivity timer
#cmpif 0x00400000 :   TimerStart(TMRNUM_LOWPWR_UART,uartIdleToutMs,0)
#cmpifand 0x00400104 :  DbgMsg("Uart Tmr STARTv")
#cmpif 0x00400000 :   endif
#cmpif 0x00400000 : endsub

//------------------------------------------------------------------------------
// Reopen the uart and if it was closed
// unconditionally restarts the idle timer
//------------------------------------------------------------------------------
#cmpif 0x00400000 : sub UartReOpen()
#cmpif 0x00400000 :   if UartInfo(0)==0 then
#cmpif 0x00400000 :     //Uart was actually closed so open it
#cmpif 0x00400000 :     rc = UartOpen(UARTbaud, UARTTxBuf, UARTRxBuf, UARTFlags$)
#cmpifand 0x00400103 :  AssertRC(10280)
#cmpif 0x00400000 :   endif
#cmpif 0x00400000 :   //Start the uart inactivity timer
#cmpif 0x00400000 :   TimerStart(TMRNUM_LOWPWR_UART,uartIdleToutMs,0)
#cmpifand 0x00400104 :  DbgMsg("Uart Tmr STARTr")
#cmpif 0x00400000 : endsub

//------------------------------------------------------------------------------
// routine for sending buffered data for the UART
//------------------------------------------------------------------------------
sub SendUartData()
  if (StrLen(UARTSndBuf$) > 0) then
    //Send UART data
    #cmpif 0x00400000 :  UartReOpen()
    rc = UARTWrite(UARTSndBuf$)
    StrShiftLeft(UARTSndBuf$, rc)
  endif
endsub

//------------------------------------------------------------------------------
// routine for sending buffered data for the UART
//------------------------------------------------------------------------------
sub SendUartDataEx(byref appData$)
  UARTSndBuf$=UARTSndBuf$+appData$
  if (StrLen(UARTSndBuf$) > 0) then
    //Send UART data
    #cmpif 0x00400000 : UartReOpen()
    rc = UARTWrite(UARTSndBuf$)
    StrShiftLeft(UARTSndBuf$, rc)
  endif
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub AppendRspEnd(rsp as integer, byref bufferStr$ )
  dim tmpStr$
  if rsp == 0 then
    tmpStr$ = ok$
  elseif rsp > 99 then
    sprint #tmpStr$, integer.h' rsp
    tmpStr$ = er$ + right$(tmpStr$,4)
  elseif rsp > 0 then
    sprint #tmpStr$, "0";rsp
    tmpStr$ = er$ + right$(tmpStr$,2)
  else
    atParse=0
    exitsub
  endif
  bufferStr$ = bufferStr$ + tmpStr$ + "\r"
  atParse=1
endsub

//------------------------------------------------------------------------------
// for valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub GetConnInfoRsp(hConn, byref rsp$, byref intrvl )
  dim addr$,sprvto,slat

  rc = BleGetCurConnParms(hConn,intrvl,sprvto,slat)
  #cmpif 0x00000003 : AssertRC(10480)

  rc=BleGetAddrFromConnHandle(hConn,addr$)
  #cmpif 0x00000003 : AssertRC(10510)

  sprint #rsp$, StrHexize$(addr$);",";intrvl;",";sprvto;",";slat
endsub

//------------------------------------------------------------------------------
// for valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub AppendConnRspEnd(rsp as integer, byref bufferStr$ )
  dim tmpStr$,info$,intrvl
  if rsp == 0 then
    GetConnInfoRsp(connHandles[HCONN_VSP],info$,intrvl)
    sprint #tmpStr$, "\nCONNECT 0,";info$;"\r"
    //Set the data pump timer for when BleGattcWriteCmd fails due to lack of buffers
    vspPumpToutMs = (intrvl+2500)/1000
  elseif rsp > 0 then
    sprint #tmpStr$, "\nNOCARRIER ";rsp;"\r"
  else
    atParse=0
    exitsub
  endif
  bufferStr$ = bufferStr$ + tmpStr$
  atParse=1
endsub

//------------------------------------------------------------------------------
// Cache idleAdvType with Sreg value
//------------------------------------------------------------------------------
sub CacheAdvertType()
  idleAdvType  = SRegGet(CfgId_IdleAdvertType)
  if idleAdvType == ADV_DIRECT_IND then
    //Idle mode adverts are not allowed to be ADV_DIRECT_IND
    idleAdvType=ADV_IND
  endif
endsub

//------------------------------------------------------------------------------
// On non vsp connection, this is used to send the confirming 'connect' message
//------------------------------------------------------------------------------
sub SendNonVspConnect(ndx as integer, byref bufferStr$ )
  dim tmpStr$,info$,intrvl

  GetConnInfoRsp(connHandles[ndx],info$,intrvl)
  sprint #tmpStr$, "\nconnect ";ndx;",";info$;"\r"

  bufferStr$ = bufferStr$ + tmpStr$
  atParse=1

  //Send out data waiting in buffer
  SendUartData()
endsub

//------------------------------------------------------------------------------
// Used to send "RING " response on an incoming VSP connection
//------------------------------------------------------------------------------
sub SendRingRsp(hConn as integer, byref bufferStr$ )
  dim addr$,isTrusted, keyInfo, rollAge, rollCount
  rc=BleGetAddrFromConnHandle(hConn,addr$)
  #cmpif 0x00000003 : AssertRC(10980)

  isTrusted = BleBondingIsTrusted(addr$, BOND_TRUSTED_AS_CENTRAL, keyInfo, rollAge, rollCount)

  addr$=StrHexize$(addr$)
  bufferStr$ = bufferStr$ + "\nRING " + addr$

  if isTrusted then
    addr$ = ",T\r"
  else
    addr$ = ",U\r"
  endif

  bufferStr$ = bufferStr$ + addr$

  //Send out data waiting in buffer
  SendUartData()
endsub

//------------------------------------------------------------------------------
// for valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub SendNonVspDiscon(rsp as integer, ndx as integer, byref bufferStr$ )

  sprint #dontcare$, "\ndiscon ";ndx;",";rsp;"\r"
  bufferStr$ = bufferStr$ + dontcare$

  atParse=1

  //Send out data waiting in buffer
  SendUartData()
endsub

//------------------------------------------------------------------------------
// This is sent on non_vsp states when scanning times out
//------------------------------------------------------------------------------
sub SendScanEnd(byref bufferStr$ )

  bufferStr$ = bufferStr$ + "\nscanend\r"

  //Send out data waiting in buffer
  SendUartData()
endsub

//------------------------------------------------------------------------------
// This is sent when a passcode needs to be displayed
//------------------------------------------------------------------------------
sub SendDispPassKey(npsky, byref bufferStr$ )
  dim tmp$

  sprint #tmp$, "000000";npsky;"\r"

  bufferStr$ = bufferStr$ + "\nshowcode " + right$(tmp$,7)

  //Send out data waiting in buffer
  SendUartData()
endsub

//------------------------------------------------------------------------------
// This is sent when a authkey is required and
// keytype=1 for passcode (0 to 999999)
// keytype=2 for 32 hex digit OOB key
//------------------------------------------------------------------------------
sub SendAuthKeyReq(keyType, byref bufferStr$ )
  dim tmp$
  select keyType
  case BLE_GAP_AUTH_KEY_TYPE_PASSKEY
    tmp$ = "\npasskey?\r"

  case BLE_GAP_AUTH_KEY_TYPE_OOB
    tmp$ = "\noobkey?\r"

  case else
    tmp$ = "\nxxkey?\r"
  endselect
    bufferStr$ = bufferStr$ + tmp$

  //Send out data waiting in buffer
  SendUartData()
endsub

//------------------------------------------------------------------------------
// Send 'Encrypt' message
//------------------------------------------------------------------------------
sub SendEncryptRsp(ndx, sendMsg, byref bufferStr$ )
  dim msg$
  select sendMsg
  case 1
    msg$ = "\nENCRYPT\r"

  case 2
    sprint #msg$, "\nencrypt ";ndx;"\r"

  case else
  endselect
  if sendMsg>0 then
    bufferStr$ = bufferStr$ + msg$
    //Send out data waiting in buffer
    SendUartData()
  endif
endsub

//------------------------------------------------------------------------------
//  8-bit S-Registers are 100-199
// 16-bit S-Registers are 200-299
// 32-bit S-Registers are 300-399
//------------------------------------------------------------------------------
function ATSRegGetValue(regnum, byref rspBuf$)
  if (regnum >= SREGNUM_START_8BIT) && (regnum<(SREGNUM_START_8BIT+SREG_MAXREGISTERS_8)) then
    //This is 8-bit register access
    regnum = regnum-SREGNUM_START_8BIT
  elseif (regnum >= SREGNUM_START_16BIT) && (regnum<(SREGNUM_START_16BIT+SREG_MAXREGISTERS_16)) then
    //This is 16-bit register access
    regnum = regnum+0x10000-SREGNUM_START_16BIT
  elseif (regnum >= SREGNUM_START_32BIT) && (regnum<(SREGNUM_START_32BIT+SREG_MAXREGISTERS_32)) then
    //This is 32-bit register access
    regnum = regnum+0x20000-SREGNUM_START_32BIT
  else
    exitfunc RSP_ERROR_INVALID_S_REG
  endif

  dim regval$
  sprint #regval$,SRegGet(regnum)
  rspBuf$ = rspBuf$ + "\n" + regval$ + "\r"

endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegSetValue(regnum, regVal)
  if (regnum >= SREGNUM_START_8BIT) && (regnum<(SREGNUM_START_8BIT+SREG_MAXREGISTERS_8)) then
    //This is 8-bit register access
    regnum = regnum-SREGNUM_START_8BIT
  elseif (regnum >= SREGNUM_START_16BIT) && (regnum<(SREGNUM_START_16BIT+SREG_MAXREGISTERS_16)) then
    //This is 16-bit register access
    regnum = regnum+0x10000-SREGNUM_START_16BIT
  elseif (regnum >= SREGNUM_START_32BIT) && (regnum<(SREGNUM_START_32BIT+SREG_MAXREGISTERS_32)) then
    //This is 32-bit register access
    regnum = regnum+0x20000-SREGNUM_START_32BIT
  else
    exitfunc RSP_ERROR_INVALID_S_REG
  endif

  //check if valid range
  dim mn,mx
  mn=SRegGetRange(regnum,mx)
  if (regVal<mn) || (regVal>mx) then
    exitfunc RSP_ERROR_VALUE_OUT_OF_RANGE
  endif

  SRegSet(regnum,regVal)

endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegGetRange(regnum, byref rspBuf$)
  if (regnum >= SREGNUM_START_8BIT) && (regnum<(SREGNUM_START_8BIT+SREG_MAXREGISTERS_8)) then
    //This is 8-bit register access
    regnum = regnum-SREGNUM_START_8BIT
  elseif (regnum >= SREGNUM_START_16BIT) && (regnum<(SREGNUM_START_16BIT+SREG_MAXREGISTERS_16)) then
    //This is 16-bit register access
    regnum = regnum+0x10000-SREGNUM_START_16BIT
  elseif (regnum >= SREGNUM_START_32BIT) && (regnum<(SREGNUM_START_32BIT+SREG_MAXREGISTERS_32)) then
    //This is 32-bit register access
    regnum = regnum+0x20000-SREGNUM_START_32BIT
  else
    exitfunc RSP_ERROR_INVALID_S_REG
  endif

  dim regval$,mn,mx
  mn=SRegGetRange(regnum,mx)
  sprint #regval$,mn;"..";mx
  rspBuf$ = rspBuf$ + "\n" + regval$ + "\r"

endfunc RSP_OK

//------------------------------------------------------------------------------
// String S-Registers start at 0
//------------------------------------------------------------------------------
function ATSRegGetValueStr(regnum, byref rspBuf$)

  if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
    dontcare$=SRegGetStr$((regnum-SREGNUM_START_STR))
    rspBuf$ = rspBuf$ + "\n" + StrEscape$(dontcare$) + "\r"
    exitfunc RSP_OK
  endif

endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegSetValueStr(regnum, regVal$)

  if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
    //check if valid range
    dim mn,mx,len

    regnum = regnum - SREGNUM_START_STR

    //get the valid min/max for this register
    mn=SRegGetStrSizeRange(regnum,mx)
    //de-escape the string
    StrDeEscape(regVal$)  //ensure escaped characters are converted to single binary values

    //check for valid length
    len=strlen(regVal$)
    if (len<mn) || (len>mx) then
      exitfunc RSP_ERROR_VALUE_OUT_OF_RANGE
    endif

    //perform further checking
    select regnum
    case CfgIdStr_VspServiceUUID128
      //this must only contain hex characters
      dontcare$=strdehexize$(regVal$)
      if strlen(dontcare$) != 16 then
        exitfunc RSP_ERROR_INVALID_HEXSTR
      endif

    case else
    endselect

    SRegSet$(regnum, regVal$)
    exitfunc RSP_OK

  endif

endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegGetLenRangeStr(regnum, byref rspBuf$)
  if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
    dim tmp$,mn,mx
    mn=SRegGetStrSizeRange((regnum-SREGNUM_START_STR),mx)
    sprint #tmp$,mn;",";mx
    rspBuf$ = rspBuf$ + "\n" + tmp$ + "\r"
    exitfunc RSP_OK
  endif
endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
//Change PHY per start-up flag
//------------------------------------------------------------------------------
function ChangePhy( connHandle )
  dim nPhyReq
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  nPhyReq = ((startflags>>5) & 0x00000003)
  select nPhyReq
    #cmpif 0x00100000 :   case 1  // Long Range 125 kbps
    #cmpif 0x00100000 :     nPhyReq = 4

  case 3  // 2MPHY
    nPhyReq = 2

  case else  // 1MPHY
    exitfunc 0

  endselect
  #cmpif 0x00000001 :  print "\n## nPhyReq = ";nPhyReq
endfunc BlePhySet(connHandle, nPhyReq, nPhyReq, 0)

//------------------------------------------------------------------------------
//if advertising then return non-zero
//------------------------------------------------------------------------------
function IsAdvertising()
  if (sysinfo(2016) & 0x1) then
    exitfunc 1
  endif
endfunc 0

//------------------------------------------------------------------------------
//if scanning then return non-zero
//------------------------------------------------------------------------------
function IsScanning()
  if (sysinfo(2016) & 0x8) then
    exitfunc 1
  endif
endfunc 0

//------------------------------------------------------------------------------
//if advertising in progress stop it
//------------------------------------------------------------------------------
sub AdvertsStop()
  #cmpif 0x00000004 : DbgMsg("Called AdvertsStop()")
  if IsAdvertising() then
    rc=BleAdvertStop()
    #cmpif 0x00000003 : AssertRC(13650)
    #cmpif 0x00000004 : DbgMsg("Adverts Stopped")
  endif
endsub

//------------------------------------------------------------------------------
//if scanning in progress stop it
//------------------------------------------------------------------------------
sub ScanningStop()
  #cmpif 0x00000004 : DbgMsg("Called ScanningStop()")
  if IsScanning() then
    rc=BleScanStop()
    #cmpif 0x00000003 : AssertRC(13770)
    #cmpif 0x00000004 : DbgMsg("Scanning Stopped")
  endif
endsub

//------------------------------------------------------------------------------
//Stop & restart scanning
//------------------------------------------------------------------------------
function ScanningStart(tout, filter$, rsi)
  ScanningStop()
  rc = BleScanStart( tout, 0)
  #cmpif 0x00000008 :   AssertRC(13880)

  //Set up the filtering parameters for the scan reporting
  if rc==0 then
    scnPattern$   = filter$
    scnPatternLen = strlen(filter$)
    scnRssi       = rsi
  endif

  #cmpif 0x00000004 : if rc==0 then
  #cmpif 0x00000004 :   DbgMsg(    "Scanning Started")
  #cmpif 0x00000004 :   DbgMsgVal( "  Scan Tout (sec)=",tout)
  #cmpif 0x00000004 :   DbgMsgVal$("  Scan Pattern   =",filter$)
  #cmpif 0x00000004 :   DbgMsgVal( "  Scan Rssi (dBm)=",rsi)
  #cmpif 0x00000004 : else
  #cmpif 0x00000004 :   DbgMsg("Failed to start Scanning")
  #cmpif 0x00000004 : endif

endfunc rc

//------------------------------------------------------------------------------
// Load VSP service defaults into sArg$[] and nArg[] to set things up as follows
//   sArg$[0] =
//   nArg[1]  = TxBufLen
//   nArg[2]  = RxBufLen
//   nArg[3]  = VspServiceUuid
//   nArg[4]  = RxUUID
//   nArg[5]  = TxUUID
//   nArg[6]  = MdmInUUID
//   nArg[7]  = MdmOutUUID
//   nArg[8]  = EncryptionReq (bit 0 set to encrypt, 1 set for MITM)
//------------------------------------------------------------------------------
sub VspGetDefs()
  dim tmpStr$

  //Get Tx & Rx buffer sizes
  nArg[1] = SRegGet( CfgId_VspTxBufSize )
  nArg[2] = SRegGet( CfgId_VspRxBufSize)

  //if DLE is enabled or 2MPHY is selected, testing has shown that we need to
  //increase the size of the vsp rx buffer otherwise things go pear shaped because we need to cater to
  // up to 6 (or more) packets to arrive in a single connection interval. In that case if there is no
  //space to save the new data, then then only opion is to just dump it which is seen as a loss of data.
  //In future we can refactor the VSP functionality in this app by NOT using the BleVspXXX() helper functions
  //but leverage the fact that we now have the ability to send STRING data in event messages and so this
  //issue can only arise if the heap is running low.
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  if (startflags&0x78)!=0 then
    //we need to increase the size of the vsp rxbuffer if it is too small
    dontcare = 8 * DLE_ATTRIBUTE_SIZE
    if dontcare > nArg[2] then
      nArg[2] = dontcare
      #cmpif 0x00000004 : DbgMsgVal("Increased VSP Rxbuf Size to ",dontcare)
    endif
  endif

  //Get UUID handles for Service and the 4 Characteristics
  tmpStr$ = SRegGetStr$( CfgIdStr_VspServiceUUID128)
  tmpStr$ = StrDehexize$(tmpStr$)
  nArg[3] = BleHandleUuid128(tmpStr$)  //VspServiceUuid
  nArg[4] = BleHandleUuidSibling(nArg[3], SRegGet(CfgId_VspRxUUID))
  nArg[5] = BleHandleUuidSibling(nArg[3], SRegGet(CfgId_VspTxUUID))
  nArg[6] = BleHandleUuidSibling(nArg[3], SRegGet(CfgId_VspMdmInUUID))
  nArg[7] = BleHandleUuidSibling(nArg[3], SRegGet(CfgId_VspMdmOutUUID))

  //Get EncryptionReq
  nArg[8] = SRegGet( CfgId_Encrypt)
endsub

//------------------------------------------------------------------------------
// Open VSP service using sArg$[] and nArg[] as per VspGetDefs()
//------------------------------------------------------------------------------
function VspOpen()
  dim vspFlags

  //Update vsp flags variable
  if ((nArg[8] & 0x1) == 0x1 ) then
    //Connection encryption is enabled, get timer value
    encDisconTime = SRegGet( CfgId_EncrDisconToutMs)
    if ((nArg[8] & 0x2) == 0x2 ) then
      //MITM required
      vspFlags = 0x0C
    else
      //MITM not required
      vspFlags = 0x08
    endif
  else
    //VSP encryption is disabled, disable timer
    encDisconTime = 0
    vspFlags = 0
  endif

  //save the service uuid handle so that we can use it when creating the advert report
  handleVspServiceUuid = nArg[3]

  //Open the VSP service with the provided configuration
  #cmpif 0x00000004 : DbgMsgVal("VSP Txbuf Size ",nArg[1])
  #cmpif 0x00000004 : DbgMsgVal("VSP Rxbuf Size ",nArg[2])
  rc = BleVSPOpenEx(nArg[1], nArg[2], vspFlags, nArg[3], nArg[4], nArg[5], nArg[6], nArg[7])
  #cmpif 0x00000003 : AssertRC(14680)
  if rc==0 then
    vspAdded = 1
  endif
endfunc rc

//------------------------------------------------------------------------------
// Create a generic minimal advert
//------------------------------------------------------------------------------
sub GenAdvCreateMinimal(byref advRpt$, byref scRpt$)
  dim flgsAD, nAppearance

  flgsAD      = SRegGet( CfgId_VspFlagsAD )
  nAppearance = SRegGet( CfgId_Appearance)

  rc = BleAdvRptInit(advRpt$, flgsAD, nAppearance, MaxDevNameSize)
    #cmpif 0x00000003 : AssertRC(14840)

  rc = BleScanRptInit(scRpt$)
    #cmpif 0x00000003 : AssertRC(14870)

endsub

//------------------------------------------------------------------------------
// The advert report for the VSP service
//------------------------------------------------------------------------------
sub VspAdvCreateCommit()
  //Add device name to advert report and service UUID to scan report
  dim advRpt$, scRpt$

  GenAdvCreateMinimal(advRpt$, scRpt$)

    #cmpif 0x00000003 : AssertNE(handleVspServiceUuid,0,10950)
  rc = BleAdvRptAddUuid128(scRpt$, handleVspServiceUuid)
    #cmpif 0x00000003 : AssertRC(15020)

  #cmpif 0x00000001 : print "\n## VspAdv ";strhexize$(advRpt$)
  #cmpif 0x00000001 : print "\n## VspScn ";strhexize$(scRpt$)

  rc = BleAdvRptsCommit(advRpt$, scRpt$)
    #cmpif 0x00000003 : AssertRC(15050)
endsub

//------------------------------------------------------------------------------
// Ble advertising for central devices to connect to for VSP service
//------------------------------------------------------------------------------
sub VspStartAdverts()
  dim Addr$
  Addr$ = ""

  rc = BleAdvertStart(0, Addr$, SRegGet(CfgId_VspAdvertIntvlMs), 0, 0)
    #cmpif 0x00000003 : AssertRC(15160)
    #cmpif 0x00000004 : DbgMsg("Vsp Adverts Started")
endsub

//------------------------------------------------------------------------------
// Create minimal idle advert/scan reports
//------------------------------------------------------------------------------
sub IdleAdvCreate()
  GenAdvCreateMinimal(idleAdvRpt$, idleScnRpt$)
endsub

//------------------------------------------------------------------------------
// Commit the idle mode advert reports
//------------------------------------------------------------------------------
sub IdleAdvCommit()

  #cmpif 0x00000001 : print "\n## IdlAdv ";strhexize$(idleAdvRpt$)
  #cmpif 0x00000001 : print "\n## IdlScn ";strhexize$(idleScnRpt$)

  rc = BleAdvRptsCommit(idleAdvRpt$, idleScnRpt$)
    #cmpif 0x00000003 : AssertRC(15320)
endsub

//------------------------------------------------------------------------------
// Ble advertising for central devices to connect to for VSP service
//------------------------------------------------------------------------------
sub IdleStartAdverts( advType, adIntervalMs )
  dim Addr$
  Addr$ = ""

  rc = BleAdvertStart(advType, Addr$, idleAdvIntvlMs , 0, 0)
  #cmpif 0x00000003 : AssertRC(15430)
  #cmpif 0x00000004 : DbgMsg("Idle Adverts Started")

  //save in cache
  idleAdvType    = advType
  idleAdvIntvlMs = adIntervalMs

endsub

//------------------------------------------------------------------------------
// Call this to assert the DCD state when there is a VSP connection
//------------------------------------------------------------------------------
sub VspDcdAssert()
  if vspDcdPin>= 0 then
    GpioWrite(vspDcdPin,DCD_ASSERT_STATE)
  endif
endsub

//------------------------------------------------------------------------------
// Call this to deassert the DCD state when there is a VSP disconnection
//------------------------------------------------------------------------------
sub VspDcdDeassert()
  if vspDcdPin>= 0 then
    GpioWrite(vspDcdPin,DCD_DEASSERT_STATE)
  endif
endsub

//------------------------------------------------------------------------------
// Currently only need to initialise the gpio for vspCmdMode Pin in Fast mode
// or when low power uart operation is compile time enabled then the same pin
// is used by the host to reopen the uart
//------------------------------------------------------------------------------
sub InitGPIO()

  //cache the command mode pin
  vspCmdModePin = SRegGet(CfgId_VspCmdModePin)

  #cmpif 0x00400000 : //Set Lowpower pin to default if not overriden in SReg
  #cmpif 0x00400000 : if vspCmdModePin<0 then
  #cmpif 0x00400000 :   vspCmdModePin = UART_DEFAULT_LOWPWR_CMDPIN
  #cmpif 0x00400000 : endif

  if vspCmdModePin>= 0 then
    //set it as input
    rc=GpioSetFunc(vspCmdModePin,SIOTYPE_DIN,INPUT_PULL_UP)
    #cmpif 0x00000003 : AssertRC(15620)

    if fLowPowerUart then
      //and arrange so that we will get an event each time it goes from 0 to 1
      //because when that pin is high, it means host wants to force the uart to
      //be open
      rc=GpioSetFunc(vspCmdModePin,SIOTYPE_DIN,INPUT_PULL_DOWN)
      #cmpif 0x00000003 : AssertRC(15530)

      rc=GpioAssignEvent(0,vspCmdModePin,0)
    else
      //and arrange so that we will get an event each time it goes from 1 to 0
      rc=GpioSetFunc(vspCmdModePin,SIOTYPE_DIN,INPUT_PULL_UP) //pullup resistor
      #cmpif 0x00000003 : AssertRC(15590)

      rc=GpioAssignEvent(0,vspCmdModePin,1)
    endif
    #cmpif 0x00000003 : AssertRC(15700)

  endif

  //cache the command mode pin and set as output if one specified
  vspDcdPin = SRegGet(CfgId_VspDcdPin)
  if vspDcdPin>= 0 then
    //set it as an output 
    rc=GpioSetFunc(vspDcdPin,SIOTYPE_DOUT,DCD_DEASSERT_STATE)
    #cmpif 0x00000003 : AssertRC(16000)
  endif

endsub

//------------------------------------------------------------------------------
// Common code when returning to one of the idle states
//------------------------------------------------------------------------------
sub IdleReturnAction()
  dim scanPat$
  #cmpif 0x00000004 : DbgMsgVal("IdleReturn - Radio", sysinfo(2016))
  #cmpif 0x00000004 : DbgMsgVal("OldIdleState=",oldIdleState)

  select oldIdleState
  case STATE_IDLE_VSP
    //Create the VSP related Advert report and scan report and commit
    VspAdvCreateCommit()
    //Start Advertising
    VspStartAdverts()

  case STATE_IDLE_nonVSP
    advPrefix$ = "\nAD0:"

  case else
    //nothing to do
    #cmpif 0x00000004 : DbgMsg("IdleReturn - unknown")
  endselect

  //change state
  NewState(oldIdleState)

endsub

//------------------------------------------------------------------------------
// Called from a handler when vsp connection fails
//------------------------------------------------------------------------------
sub VspNoCarrierRet(rsp)

  IdleReturnAction()  //Will change state to one of IDLE, IDLE_VSP, IDLE_ADV

  //send an NOCARRIER response
  AppendConnRspEnd(rsp,UARTSndBuf$)
  //Send out data waiting in buffer
  SendUartData()
  //also trigger a reprocessing of the uart buffer just in case
  rc=SendMsgApp(MSGAPP_PROCESS_UART, DONTCARE_CTX)

endsub

//------------------------------------------------------------------------------
// Called from a handler when nonVSP connection fails
//------------------------------------------------------------------------------
sub NonVspDisconRet(rsp, ndx)

  IdleReturnAction()  //Will change state to one of IDLE, IDLE_VSP, IDLE_ADV

  //send an DISCON response
  SendNonVspDiscon(rsp, ndx, UARTSndBuf$)

  //also trigger a reprocessing of the uart buffer just in case
  rc=SendMsgApp(MSGAPP_PROCESS_UART, DONTCARE_CTX)

endsub

//--------------------------------------------------------------------------
// Given a connection handle, returns 0 if not connected to a trusted device
// otherwise 1 for unauthenticated pairing and 2 for authenticaed
// This is called on when making an outgoing VSP Connection
//--------------------------------------------------------------------------
function IsTrustedPeer(hConn)
  dim kInfo, rAge, rCount,klen
  dim curAddr$

  //get address of connected device
  rc = BleGetAddrFromConnHandle(hConn,curAddr$)
  #cmpif 0x00000003 : AssertRC(16440)
  #cmpif 0x00000004 : dim a$ : a$=StrHexize$(curAddr$)
  #cmpif 0x00000004 : DbgMsgVal$("Master Addr = ",a$)

  //check if device is trusted
  klen = BleBondingIsTrusted(curAddr$, BOND_TRUSTED_AS_CENTRAL, kInfo, rAge, rCount)

  if klen > 0 then
    //it is trusted and for Phase 1 ignore the authentication stuff
    #cmpif 0x00000004 : print "\n## Peer is trusted "
    #cmpif 0x00000004 : if (kInfo & BONDING_KEYINFO_MITM_AUTHENTICATED)!=0 then
    #cmpif 0x00000004 :   print "(Authenticated)"
    #cmpif 0x00000004 : endif

    if (kInfo & BONDING_KEYINFO_MITM_AUTHENTICATED)!=0 then
      //it is an authenticated bond, reuse kInfo variable for return value
      kInfo = 2
    else
      //it is not an authenticated bond, reuse kInfo variable for return value
      kInfo = 1
    endif
  else
    //not trusted, reuse kInfo variable for return value
    #cmpif 0x00000004 : print "\n## Peer is NOT trusted "
    kInfo = 0
  endif
endfunc kInfo

//------------------------------------------------------------------------------
//open gatt client, returns a nonzero error code
//------------------------------------------------------------------------------
function GattClientOpen()
  if fGattClient==0 then
    rc = BleGattcOpen(SRegGet(CfgId_GattClientMemSize), 0)
    if rc > 0 then
      rc=CONN_ERROR_OUTOFMEM
    else
      fGattClient=1
      #cmpif 0x00000004 : DbgMsg("GattClientOpen")
    endif
  else
    rc=RSP_OK
      #cmpif 0x00000004 : DbgMsg("GattClient was Open")
  endif
endfunc rc

//------------------------------------------------------------------------------
// vspFindIndex is the index into the query array
//------------------------------------------------------------------------------
function FindCharOrDesc()
  //#cmpif 0x00000004 : DbgMsgVal("FindCharOrDesc Idx=",vspFindIndex)

  dim cccdUuid : cccdUuid = hVspCccdUuids[vspFindIndex]
  dim charUuid : charUuid = nArg[vspFindIndex]

  if cccdUuid==0 then
    //find char
    //#cmpif 0x00000004 : DbgMsg("BleGattcFindChar")
    rc = BleGattcFindChar(connHandles[HCONN_VSP], vspSvcUuid, 0, charUuid, 0)
  else
    //find desc
    //#cmpif 0x00000004 : DbgMsg("BleGattcFindDesc")
    rc = BleGattcFindDesc(connHandles[HCONN_VSP], vspSvcUuid, 0, charUuid, 0, cccdUuid, 0 )
  endif
  #cmpif 0x00000003 : AssertRC(17190)

endfunc rc

//------------------------------------------------------------------------------
// vspFindIndex is the index into the query array
// returns 0 if no more cccd's in the array
//------------------------------------------------------------------------------
function CccdsEnable()
  //#cmpif 0x00000004 : DbgMsgVal("CccdsEnable, idx=",vspFindIndex)
  dim i, hAttr
  //first find the first cccd
  for i=vspFindIndex to (VSP_ATTR_MAX_INDEXES-1)
    if hVspCccdUuids[i] != 0 then
      //this array index is for a cccd so get the attribure handle for it
      hAttr = hVspAttr[i]
      if hAttr != 0 then
        #cmpif 0x00000004 : print "\n## BleGattcWrite, hAttr =";hAttr;" i=";i
        //found attr handle for a cccd
        dontcare$ = "\01\00"
        rc = BleGattcWrite(connHandles[HCONN_VSP], hAttr, dontcare$)
        #cmpif 0x00000003 : AssertRC(17400)
        vspFindIndex = i
        exitfunc 1
      endif
    endif
  next
  //reaching here means no more cccd's to enable
endfunc 0

//------------------------------------------------------------------------------
//Setup array of chars+ desc that need to be found in the slave
//------------------------------------------------------------------------------
function GetVspHandles()
  dim i
  //get vsp uuids and other values into nArg[]
  VspGetDefs()
  //   nArg[3]  = VspServiceUuid
  //   nArg[4]  = RxUUID       //0
  //   nArg[5]  = TxUUID       //1
  //   nArg[6]  = MdmInUUID    //2
  //   nArg[7]  = MdmOutUUID   //3
  vspSvcUuid = nArg[3]
  //shuffle values in the nArg arrays as we are going to reuse it.
  for i=0 to 3
    nArg[i]=nArg[i+4]
  next
  //   nArg[0]  = RxUUID/0          //0
  //   nArg[1]  = TxUUID/0          //1
  //   nArg[2]  = MdmInUUID/0       //2
  //   nArg[3]  = MdmOutUUID/0      //3
  //   nArg[4]  = TxUUID/CCCD       //4
  //   nArg[5]  = MdmOutUUID/CCCD   //5
  for i=0 to (VSP_ATTR_MAX_INDEXES-1)
    hVspCccdUuids[i]=0
    hVspAttr[i]=0  //assume all are optinal
  next
  //the RX and TX characteristic are mandatory
  hVspAttr[VSP_ATTR_INDEX_RX]       = 1
  hVspAttr[VSP_ATTR_INDEX_TX]       = 1
  hVspAttr[VSP_ATTR_INDEX_TX_CCCD]  = 1
  //the TX is capable of being notified
  nArg[VSP_ATTR_INDEX_TX_CCCD]      = nArg[VSP_ATTR_INDEX_TX]   //uuid handle
  hVspCccdUuids[VSP_ATTR_INDEX_TX_CCCD] = BleHandleUuid16(0x2902)
  //the MdmOut is capable of being notified
  nArg[VSP_ATTR_INDEX_MDMOUT_CCCD]  = nArg[VSP_ATTR_INDEX_MDMOUT]  //uuid handle
  hVspCccdUuids[VSP_ATTR_INDEX_MDMOUT_CCCD] = hVspCccdUuids[VSP_ATTR_INDEX_TX_CCCD]

  //now trigger the query to find the chars and descriptors
  vspFindIndex=0
endfunc FindCharOrDesc()

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub VspEnterConnState(msgId)
  if (vspCmdModePin>=0) && (fLowPowerUart==0) then
    //we want fast mode of operation and not in low power operation
    if GpioRead(vspCmdModePin)==0 then
      //just disconnect
      vspDisconSts = CONN_ERROR_CMDPINSTATE
      //some other error, so just drop the connection
      rc=BleDisconnect(connHandles[HCONN_VSP])
      //change state
      NewState(STATE_VSP_DISCONNECTING)
      exitsub
    else
      #cmpif 0x00000004 :   DbgMsg("Going For FAST")
      rc=SendMsgApp(msgId, STATE_VSP_FAST_CONNECTED)
    endif
  else
    //we want ^^^ mode of operation
    #cmpif 0x00000004 :   DbgMsg("Going For CARET")
    rc=SendMsgApp(msgId, STATE_VSP_CARET_CONNECTED)
  endif
  #cmpif 0x00000003 : AssertRC(18140)

  //negotiate ATT_MTU if ATS213 is not the default minimum value
  if vspIsOutGoing != FALSE then
    if vspAttrMaxLen > DEFAULT_ATTRIBUTE_SIZE then
      rc = BleGattcAttributeMtuRequest(connHandles[HCONN_VSP])
#cmpif 0x00000001 :  print "\n## BleGattcAttributeMtuRequest() ret:";integer.h' rc
    else
      rc = ChangePhy( connHandles[HCONN_VSP] )
#cmpif 0x00000001 :  print "\n## ChangePhy() ret:";integer.h' rc
    endif
  endif
#cmpif 0x00000040 : vtxcnt=0 : vrxcnt=0
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub OnVspConnCommon(hConn)
  connHandles[HCONN_VSP] = hConn
  vspDisconSts=-1 //assume normal disconnection will happen
  vspEscCount=0
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub OnNonVspConnection(hConn)
  dim nodeIdx

  nodeIdx = GetFreeIdx()
  if nodeIdx==0 then
    //disconnect immediately
    rc=BleDisconnect(hConn)
    #cmpif 0x00000003 : AssertRC(18410)
  else
    //cache the connection handle
    connHandles[nodeIdx]=hConn
    //send an DISCON response
    SendNonVspConnect(nodeIdx, UARTSndBuf$)
    //change state
    NewState(STATE_nonVSP_CONNECTED)
    //for now do not process any incoming
       //
       //OnEvent EVATTRNOTIFY Disable
       //
    //need to process more
    rc=SendMsgApp(MSGAPP_ENTER_NONVSP_CONN_STATE, DONTCARE_CTX)
  endif

endsub

//------------------------------------------------------------------------------
//Called on Connection
//------------------------------------------------------------------------------
sub OnConnect(hConn)
  #cmpif 0x00000004 : DbgMsg("Connect")
  #cmpif 0x00000008 : ShowConnParms(hConn)

  //increment the connection count
  connCount=connCount+1

  select curState
  case STATE_IDLE_VSP
    //send a RING response
    SendRingRsp(hConn, UARTSndBuf$  )
    //action common stuff for vsp whether in our outgoing
    OnVspConnCommon(hConn)
    //Flush the VSP buffers just in case there is stuff from previous connections
    BleVspFlush(3)
    //incoming VSP connection
    SaveState(oldIdleState)
    if encDisconTime != 0 then
      //we expect an encrypted connection
      #cmpif 0x00000004 : DbgMsgVal("Enc Required, Timer(ms)=",encDisconTime)
      TimerStart(TMRNUM_ENCR_WAIT,encDisconTime,0)
      NewState(STATE_VSP_IN_WAIT_ENCR)
    else
      //no encryption required for this connection
      #cmpif 0x00000004 : DbgMsg("Enc NOT Required")
      vspIsOutGoing=FALSE
      VspEnterConnState(MSGAPP_ENTER_VSPIN_CONN_STATE)
    endif

  case STATE_VSP_CONNECTING
    //action common stuff for vsp whether in our outgoing
    OnVspConnCommon(hConn)
    //is this a trusted peer
    if IsTrustedPeer(hConn) > 0 then
      //Peer is trusted
      rc = BleEncryptConnection(hConn, LTK_MINIMUM_SIZE, BLE_ENCRYPT_MITM_NOT_REQUIRED)
      #cmpif 0x00000004 : DbgMsg("Encrypting..")
      //Change state
      NewState(STATE_VSP_WAIT_ENCRYPT)
    else
      //Peer is not trusted
      rc = GetVspHandles()
      //Change state
      NewState(STATE_VSP_GET_HANDLES)
    endif

  case STATE_IDLE_nonVSP
    //new connection so need to create a indx handle
    //incoming nonVSP connection
    SaveState(oldIdleState)
    OnNonVspConnection(hConn)

  case STATE_nonVSP_CONNECTING
    //new connection so need to create a indx handle
    OnNonVspConnection(hConn)

  case else
  endselect
endsub

//------------------------------------------------------------------------------
//Called on connection going encryted
//------------------------------------------------------------------------------
sub OnEncrypted(hConn)
  dim sendMsg : sendMsg=1
  dim nIdx : nIdx=HCONN_VSP
  #cmpif 0x00000004 : DbgMsg("Encrypted")

  select curState
  case STATE_VSP_IN_WAIT_ENCR
    vspIsOutGoing=FALSE
    VspEnterConnState(MSGAPP_ENTER_VSPIN_CONN_STATE)

  case STATE_VSP_WAIT_ENCRYPT
    //Peer is not trusted
    rc = GetVspHandles()
    //Change state
    NewState(STATE_VSP_GET_HANDLES)

  case STATE_VSP_PAIRING
    //Successful just works pairing
    rc=CccdsEnable()
    //Change state
    NewState(STATE_VSP_WRITE_CCCDS)

  case STATE_nonVSP_CONNECTED
    nIdx = GetIdxFromHConn(hConn)
    sendMsg=2

  case else
    sendMsg=0
  endselect

  //Conditionally send "ENCRYPT" message
  SendEncryptRsp(nIdx, sendMsg, UARTSndBuf$ )

endsub

//------------------------------------------------------------------------------
//Called when connection failed to encrypt
//------------------------------------------------------------------------------
sub OnUnencrypted(hConn)

  #cmpif 0x00000004 : DbgMsg("Failed to Encrypt")

  select curState
  case STATE_VSP_WAIT_ENCRYPT, STATE_VSP_PAIRING
    vspDisconSts=CONN_ERROR_UNENCRYPTED
    //some other error, so just drop the connection
    rc=BleDisconnect(hConn)
    //change state
    NewState(STATE_VSP_DISCONNECTING)

  case STATE_nonVSP_CONNECTED
    //some other error, so just drop the connection
    rc=BleDisconnect(hConn)
    //remain in state


  case else
  endselect
endsub

//------------------------------------------------------------------------------
//Called when asked to display passkey which is in nCtx
//------------------------------------------------------------------------------
sub OnDisplayPasskey(nCtx)

  #cmpif 0x00000004 : DbgMsgVal("Display Passkey = ",nCtx)

  select curState
  case STATE_VSP_IN_WAIT_ENCR
    vspDisconSts=CONN_ERROR_PAIRUI
    //some other error, so just drop the connection
    rc=BleDisconnect(connHandles[HCONN_VSP])
    //change state
    NewState(STATE_VSP_DISCONNECTING)

  case STATE_nonVSP_CONNECTED
    SendDispPassKey(nCtx, UARTSndBuf$)

  case else
  endselect
endsub

//------------------------------------------------------------------------------
//Called when asked for auth key request. nCtx is type of key requested
//------------------------------------------------------------------------------
sub OnAuthKeyRequest(nCtx)

  #cmpif 0x00000004 : DbgMsgVal("Auth Key Request = ",nCtx)

  select curState
  case STATE_VSP_IN_WAIT_ENCR
    vspDisconSts=CONN_ERROR_PAIRUI
    //some other error, so just drop the connection
    rc=BleDisconnect(connHandles[HCONN_VSP])
    //change state
    NewState(STATE_VSP_DISCONNECTING)

  case STATE_nonVSP_CONNECTED
    SendAuthKeyReq(nCtx, UARTSndBuf$)

  case else
  endselect
endsub

//------------------------------------------------------------------------------
//Called from finddesc and findchar event handlers in VSP mode
//------------------------------------------------------------------------------
sub SvcFindCharDescEv(hConn, hAttr)

  if hAttr==0 then
    //did not find the attribute, so check if it was mandatory
    if hVspAttr[vspFindIndex] != 0 then
      //this was a mandatory attribute so something went wrong hence abort
      vspDisconSts=CONN_ERROR_NOVSPSERVICE
      //some other error, so just drop the connection
      rc=BleDisconnect(hConn)
      //change state
      NewState(STATE_VSP_DISCONNECTING)
      exitsub
    endif
  endif

  //save the attribure and check if more to find
  hVspAttr[vspFindIndex]=hAttr
  if vspFindIndex>=(VSP_ATTR_MAX_INDEXES-1) then
    //this is for the last item in the query table
    vspFindIndex=0
    rc=CccdsEnable()
    #cmpif 0x00000003 : AssertNE(rc,0,13470)
    //change state
    NewState(STATE_VSP_WRITE_CCCDS)
  else
    //more to look for
    vspFindIndex=vspFindIndex+1
    rc=FindCharOrDesc()
    //remain in this state
  endif
endsub

//------------------------------------------------------------------------------
// Returns 1 if nSts from AttrWrite means 'encrypted link required'
//------------------------------------------------------------------------------
function Is_Encr_Required(xSts)
  select xSts
  case 0x105,0x010F,0x0111
    //0x105 = Authenticated link required
    //0x10F = Encrypted link required
    //0x111 = Encrypted link required
    exitfunc 1
  case else
  endselect
endfunc 0

//------------------------------------------------------------------------------
// Called only from when are VSP in master mode
//------------------------------------------------------------------------------
sub VspMasterRtsSend(nState)
    if hVspAttr[VSP_ATTR_INDEX_MDMIN] then
      if nState != vspAllowRx then
        if nState then
          dontcare$ = "\01"
        else
          dontcare$ = "\00"
        endif
        rc = BleGattcWriteCmd(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_MDMIN], dontcare$)
        if rc==0 then
          vspAllowRx=nState
        endif
      endif
    endif
endsub

//------------------------------------------------------------------------------
//We know there is 1 character in the uart buffer so process it for ^ character
//On exit dontcare$ contains the single caracter that was read from the buffer
//------------------------------------------------------------------------------
sub PollForEscapeSeq()
  dim uLen

  dontcare$=""
  uLen = UartReadN(dontcare$, vspEscStringLen)
  if strcmp(dontcare$,vspEscString$)==0 then
    if vspEscCount==0 then
      //first ^ in a while so take snapshot of tick count
      vspEscStart=GetTickCount()
      vspEscCount=1
    else
      //consecutive ^ so need to calc time spacing
      uLen = GetTickSince(vspEscStart)
      if uLen > vspEscMinIntrvl then
        //long enough so increment count
        vspEscCount=vspEscCount+1
        if vspEscCount >= vspEscCountMax then
          //disconnect
          vspDisconSts=CONN_ERROR_USER_DISCON
          //some other error, so just drop the connection
          rc=BleDisconnect(connHandles[HCONN_VSP])
          #cmpif 0x00000003 : AssertRC(21170)
          //the ^ caret will not get through
          dontcare$=""
          //change state
          NewState(STATE_VSP_DISCONNECTING)
        else
          //take snapshot of this one
          vspEscStart=GetTickCount()
        endif
      else
        //too short time so reset count
        vspEscCount=0
      endif
    endif
  else
    vspEscCount=0
  endif

endsub

//------------------------------------------------------------------------------
// Initialise the UART
//------------------------------------------------------------------------------
sub InitUART()
  //Sets up the UART to use the required baud rate, flow control and parity options

#cmpif 0x00400000 :   //get low power idle timeout
#cmpif 0x00400000 :   uartIdleToutMs=SRegGet(CfgId_UartIdleTime_ms)

  rc = UARTInfo(0)
  if (rc != 0) then
      //UART is opened, close
      UARTClose()
  endif

  //Get values from S-Register Cache
  UARTbaud  = SRegGet( CfgId_UARTBaudrate )
  UARTTxBuf = SRegGet( CfgId_UARTTxBufSize )
  UARTRxBuf = SRegGet( CfgId_UARTRxBufSize )
  UARTFlags$ = "CN81H"

  //Reopen the UART with comms parms from S Registers
  rc = UartOpen(UARTbaud, UARTTxBuf, UARTRxBuf, UARTFlags$)
  #cmpif 0x00000003 : AssertRC(21580)

#cmpif 0x00400000 :   //Start the uart inactivity timer if we are in low power operation
#cmpif 0x00400000 :   TimerStart(TMRNUM_LOWPWR_UART,uartIdleToutMs,0)
#cmpifand 0x00400104 :  DbgMsg("Uart Tmr STARTi")

endsub

//------------------------------------------------------------------------------
// Load GAP service defaults into sArg$[] and nArg[] to set things up as follows
//   sArg$[0] = device name
//   nArg[1]  = MinConnInterval
//   nArg[2]  = MaxConnInterval
//   nArg[3]  = LinkSupervisionTimeout
//   nArg[4]  = Appearance
//   nArg[5]  = Slave Latency
//   nArg[6]  = DeviceName is writeable
//------------------------------------------------------------------------------
sub GapServiceGetDefs()
  dim tmpStr$, tmpVal

  //Get device name
  sArg$[0] = SRegGetStr$( CfgIdStr_DeviceName )
  //Append part of module BT address if required
  tmpVal = SRegGet( CfgId_DevNameFormat)
  #cmpif 0x00000004 : DbgMsgVal("DevNameFormat =",tmpVal)
  //Default selection if the BT address is appended to the advertised device name
  if ((tmpVal >= 1) && (tmpVal <= 7)) then
    //Get device address
    tmpStr$ = SysInfo$(4)
    #cmpif 0x00000004 : dim x$ : x$=strhexize$(tmpStr$)
    #cmpif 0x00000004 : DbgMsgVal$("SysInfo$(4) =",x$)
    tmpStr$ = Right$(tmpStr$, tmpVal)
    //Append to device name
    sArg$[0] = sArg$[0] + "-" + strhexize$(tmpStr$)
  endif
  //take the righmost max characters
  sArg$[0] = right$(sArg$[0],MaxDevNameSize)

  #cmpif 0x00000004 : DbgMsgVal$("DeviceName =",sArg$[0])

  //Set the tx power level
  tmpVal = SRegGet( CfgId_TxPower_dBm )
  rc=BleTxPowerSet(tmpVal)
  #cmpif 0x00000003 : AssertRC(22080)

  //Set min/max connection intervals
  nArg[1]=CONN_INTERVAL_MIN_ASPERIPH_US
  nArg[2]=CONN_INTERVAL_MAX_ASPERIPH_US
  nArg[3]=SRegGet( CfgId_LinkSupervsnAsSlaveSec) * 1000000

  //Read the Slave latency
  nArg[5] = SRegGet( CfgId_SlaveLatency)
  tmpVal = nArg[3]/nArg[2]-1    //LinkSuprvsnTouUs/MaxConnIntUs
  if nArg[5] > tmpVal then
    nArg[5] = tmpVal   //slave latency has to be compatible with slave latency
  endif

  //Read the appearance
  nArg[4] = SRegGet( CfgId_Appearance)

  //Writeable device name is disabled for now
  nArg[6] = 0
endsub

//------------------------------------------------------------------------------
// Initialise the GAP service, uses sArg$[] and nArg[] setup using
// GapServiceGetDefs() and/or AT command line
//------------------------------------------------------------------------------
function GapServiceUpdate()
  //Initialise the GAP service with the connection interval data and device name
  rc = BleGapSvcInit(sArg$[0], nArg[6], nArg[4], nArg[1], nArg[2], nArg[3],  nArg[5])
  #cmpif 0x00000003 : AssertRC(22240)
endfunc rc

//------------------------------------------------------------------------------
// Configure the pairing capability as set via the S registers
//------------------------------------------------------------------------------
sub PairingConfig()
  //set the iocapability
  pairIoCapCache = SRegGet(CfgId_PairingIoCapability)
  rc=BleSecMngrIoCap(pairIoCapCache)
  #cmpif 0x00000003 : AssertRC(22340)

  //Enable LESC preference
  rc=BleSecMngrLescPairingPref(1)
  #cmpif 0x00000003 : AssertRC(22380)
endsub

//------------------------------------------------------------------------------
// Read, Cache & Config Scanning Parameters
//------------------------------------------------------------------------------
sub CacheConfigScanParms()
  scanIntervalMs = SRegGet(CfgId_ScanInterval_ms)
  scanWindowMs   = SRegGet(CfgId_ScanWindow_ms)
  scanType       = SRegGet(CfgId_ScanType)

  //Ensure that the window is sensible
  if scanWindowMs > scanIntervalMs then
    scanWindowMs = scanIntervalMs
  endif

  //and finally set them
  rc=BleScanConfig(0,scanIntervalMs)
    #cmpif 0x00000003 : AssertRC(22560)
  rc=BleScanConfig(1,scanWindowMs)
    #cmpif 0x00000003 : AssertRC(22580)
  rc=BleScanConfig(2,scanType)
    #cmpif 0x00000003 : AssertRC(22600)

endsub

//------------------------------------------------------------------------------
// Extract exatcly one parameter which MUST be a valid 14 hex digit address
//------------------------------------------------------------------------------
function ExtractAddr(byref cmdStr$)  //sArg$[0] is updated with address
  dim args
  rc = ExtractArgsCSV(cmdStr$,args,1,1)
  if rc == 0 then
    //The supplied parameter must dehex to exactly 7 bytes
    sArg$[0]=StrDehexize$(sArg$[0])
    if strlen(sArg$[0]) != 7 then
      //A valid address has not been supplied
      exitfunc CONN_ERROR_INVALID_ADDRESS
    endif
  endif
endfunc RSP_OK

//------------------------------------------------------------------------------
// Extract addr and load other connection related variables
//------------------------------------------------------------------------------
function ConnSetup(byref cmdStr$)

  //Stop adverts if on
  AdvertsStop()
  //Stop Scanning if on
  ScanningStop()

  //try to open the gatt client
  rc=GattClientOpen()
  if rc!=0 then
    exitfunc rc
  endif

  //Extract the mac address of the peer to connect to
  rc = ExtractAddr(cmdStr$) //sArg$[0] is updated with address
  if rc != 0 then
    exitfunc rc
  endif

  //Read the min & max connection intervals
  nArg[1] = SRegGet( CfgId_MinConnIntUs)
  nArg[2] = SRegGet( CfgId_MaxConnIntUs)
  if nArg[1] > nArg[2] then
     //check the values are sensible
     nArg[1] = nArg[2]
  endif

  //Read the link supervision timeout
  nArg[3] = SRegGet( CfgId_LinkSuprvsnToutMs) * 1000
  if nArg[3] < nArg[2] then
    nArg[3] = nArg[2]+1000000   //add a second to the max interval
  endif

  //get connection timeout from s register
  nArg[0] = SRegGet( CfgId_ConnTimeoutSec ) * 1000

  #cmpif 0x00000004 :     DbgMsg("Conn Parms")
  #cmpif 0x00000004 :  DbgMsgVal("  Conn Tout(msec)=",nArg[0])
  #cmpif 0x00000004 :  DbgMsgVal("  Min Intvl      =",nArg[1])
  #cmpif 0x00000004 :  DbgMsgVal("  Max Intvl      =",nArg[2])
  #cmpif 0x00000004 :  DbgMsgVal("  Link Suprvsn   =",nArg[3])

  //OK to start an outgoing connection
  rc=BleConnect(sArg$[0], nArg[0] , nArg[1],nArg[2],nArg[3] )
  if rc!=0 then
    #cmpif 0x00000004 : DbgMsgVal ("BleConnect failed with",rc)
    exitfunc CONN_ERROR_BLECONNECT
  endif
  #cmpif 0x00000004 : DbgMsg("Connecting..")

endfunc rc

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : function InitiateTableMap(hConn)
#cmpif 0x00020000 :   rc = BleDiscServiceFirst(hConn,0,0)
#cmpif 0x00020000 :   if rc==0 then
#cmpif 0x00020000 :     exitfunc -1
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 : endfunc rc

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : sub TerminateTableMap(rc)
#cmpif 0x00020000 :   if rc==0x6052 then
#cmpif 0x00020000 :     //0x6052 = BLE_GATTC_NO_MORE_DATA
#cmpif 0x00020000 :     rc=0
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 :   AppendRspEnd(rc,UARTSndBuf$)
#cmpif 0x00020000 :   //Send out data waiting in buffer
#cmpif 0x00020000 :   SendUartData()
#cmpif 0x00020000 : endsub


//##############################################################################
//##############################################################################

//------------------------------------------------------------------------------
// Process ATI command
//:/ATIn
//:/====
//:/
//:/
//------------------------------------------------------------------------------
function _ati(byref cmdStr$, byref rspBuf$)
  dim args
  rc = ExtractArgsCSV(cmdStr$,args,0,1)
  if rc != 0 then
    exitfunc rc
  endif
  if args > 0 then
    if ExtractIntToken(sArg$[0],nArg[0])==0 then
      exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
  else
    nArg[0]=0
  endif

  select nArg[0]
  case 0
    dontcare$ = ATI_RESPONSE_0

  case 3
    GetFirmwareVersion(dontcare$)

  case 4
    dontcare$ = SysInfo$(4)
    dontcare$ = strhexize$(dontcare$)

  case 10
    dontcare$ = ATI_RESPONSE_10

  case 11
    sprint #dontcare$, fLowPowerUart

  case 13
    sprint #dontcare$, integer.h' sysinfo(1000)

  case 23
    dontcare$ = LibVer

  case 33
    dontcare$ = AppVer

  case 42
    sprint #dontcare$, curState

  #cmpif 0x00200000 : case 50
  #cmpif 0x00200000 :   sprint #dontcare$, nfcSenseCnt
  #cmpif 0x00200000 :   nfcSenseCnt = nfcSenseCnt & 1
  #cmpif 0x00200000 :
  #cmpif 0x00200000 : case 51
  #cmpif 0x00200000 :   sprint #dontcare$, nfcReadCnt
  #cmpif 0x00200000 :   nfcReadCnt = 0

  case else
    sprint #dontcare$,sysinfo(nArg[0])

  endselect

  //append to buffer
  rspBuf$ = rspBuf$ + "\n" + dontcare$ + "\r"
endfunc RSP_OK

//------------------------------------------------------------------------------
// Process ATS command
//:/ATSn=m
//:/ATSn?
//:/ATSn=?
//:/
//:/
//------------------------------------------------------------------------------
function _ats(byref cmdStr$, byref rspBuf$)
  //Extract the s-reg number
  if ExtractIntToken(cmdStr$,nArg[0])==0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  //extract either = or ?
  if ExtractStrToken(cmdStr$,sArg$[1])==0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  rc = RSP_ERROR_SYNTAX_ERROR  //assume syntax error
  if strcmp(sArg$[1],"?")==0 then
    //get the value of an S register
    if ExtractStrToken(cmdStr$,sArg$[1])==0 then
      //rest of cmd string is empty
      rc = ATSRegGetValue(nArg[0],rspBuf$)
    endif
  elseif strcmp(sArg$[1],"=")==0 then
    //an assignment or get range
    if ExtractIntToken(cmdStr$,nArg[2])==0 then
      //not an integer so try to extract a string
      if ExtractStrToken(cmdStr$,sArg$[2])>0 then
        if strcmp(sArg$[2],"?")==0 then
          //range query
          rc = ATSRegGetRange(nArg[0],rspBuf$)
        endif
      endif
    else
      //got an integer
      if ExtractStrToken(cmdStr$,sArg$[3])==0 then
        //rest of cmd string is empty
        #cmpif 0x00000004 : sprint #dbgmsg$, "\nSetReg ";nArg[0];" ";nArg[2]
        #cmpif 0x00000004 : DbgMsg(dbgmsg$)
        rc = ATSRegSetValue(nArg[0],nArg[2])
      endif
    endif
  endif
endfunc rc

//------------------------------------------------------------------------------
// Process AT%S command
//:/AT%Sn=SomeStringValueInOptionalDoubleQuotes
//:/AT%Sn?
//:/AT%Sn=?
//:/
//:/
//------------------------------------------------------------------------------
function _atsSTR(byref cmdStr$, byref rspBuf$)
  //Extract the s-reg number
  if ExtractIntToken(cmdStr$,nArg[0])==0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  //extract either = or ?
  if ExtractStrToken(cmdStr$,sArg$[1])==0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  rc = RSP_ERROR_SYNTAX_ERROR  //assume syntax error
  if strcmp(sArg$[1],"?")==0 then
    //get the value of an S register
    if ExtractStrToken(cmdStr$,sArg$[1])==0 then
      //rest of cmd string is empty
      rc = ATSRegGetValueStr(nArg[0],rspBuf$)
    endif
  elseif strcmp(sArg$[1],"=")==0 then
    //an assignment or get range
    if ExtractStrToken(cmdStr$,sArg$[2])>0 then
      if strcmp(sArg$[2],"?")==0 then
        //range query
        rc = ATSRegGetLenRangeStr(nArg[0],rspBuf$)
      else
        if IsQuoted(sArg$[2]) then  //check for beginning " and ending "
          //the string is quoted, so set it
          TrimQuotes(sArg$[2])
          rc = ATSRegSetValueStr(nArg[0],sArg$[2])
        endif
      endif
    endif
  endif
endfunc rc

//------------------------------------------------------------------------------
// save registers to non-vol memory
//------------------------------------------------------------------------------
function _atampW(byref cmdStr$, byref rspBuf$)
  //extract something and there should be nothing
  if ExtractStrToken(cmdStr$,dontcare$)!=0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
endfunc SRegSave()

//------------------------------------------------------------------------------
// reset all non-vol data to factory settings and then reset
//------------------------------------------------------------------------------
function _atampF(byref cmdStr$, byref rspBuf$)
  //extract something and there should be nothing
  if ExtractStrToken(cmdStr$,dontcare$)!=0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  rc = SRegFactoryDef()
  if rc==RSP_OK then
    reset(0)
  endif
endfunc rc

//------------------------------------------------------------------------------
//:/ at+siorN       - read
//:/ at+siowN,V     - write
//:/ at+siocN,F,S   - config   F=1(DIG_IN), 2(DIG_OUT) 3(ANALOG_IN)
//                             (see appropriate value of S in module user guide)
//------------------------------------------------------------------------------
function _atPlusSIO(byval actType, byref cmdStr$, byref rspBuf$)
  dim args
  rc=ExtractArgsCSV(cmdStr$,args, 1,3)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  //extract the sio number
  rc = SArgConvertToInt(0,0,0,MAX_SIO_NUM)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //At this point rc==RSP_OK

  select actType
  case 0 //READ
    //append to buffer
    //#cmpif 0x00000004 :  print "\n## SIO read ";nArg[0]
    sprint #dontcare$,GpioRead(nArg[0])
    rspBuf$ = rspBuf$ + "\n" + dontcare$ + "\r"

  case 1 //WRITE
    if args==2 then
      rc = SArgConvertToInt(1,0,0,0x7FFF)
      if rc!=RSP_OK then
        exitfunc rc
      endif
      //At this point rc==RSP_OK
      //#cmpif 0x00000004 :  print "\n## SIO write ";nArg[0],nArg[1]
      GpioWrite(nArg[0],nArg[1])
    else
      rc=RSP_ERROR_SYNTAX_ERROR
    endif

  case 2 //CONFIG
    if args==3 then
      rc = SArgConvertToInt(1,1,1,3)
      if rc!=RSP_OK then
        exitfunc rc
      endif
      //At this point rc==RSP_OK
      rc = SArgConvertToInt(2,0,0,255)
      if rc!=RSP_OK then
        exitfunc rc
      endif
      //At this point rc==RSP_OK
      //#cmpif 0x00000004 :  print "\n## SIO config ";nArg[0],nArg[1],nArg[2]
      rc=GpioSetFunc(nArg[0],nArg[1],nArg[2])
    else
      rc=RSP_ERROR_SYNTAX_ERROR
    endif

  case else
    rc=RSP_ERROR_GPIO_NOT_AVAILABLE
  endselect

endfunc rc

//------------------------------------------------------------------------------
//:/ at+lscn<timeout_seconds><,"escaped_pattern"><,rssi>
//:/ at+lscn<x>
//------------------------------------------------------------------------------
function _atPlusLSCN(byref cmdStr$, byref rspBuf$)
  dim args
  sArg$[0]=""
  rc=ExtractArgsCSV(cmdStr$,args, 0,3)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //#cmpif 0x00000004 : DbgMsgVal ("args=",args)
  //#cmpif 0x00000004 : DbgMsgVal$("sArg$[0]=",sArg$[0])
  //#cmpif 0x00000004 : DbgMsgVal$("sArg$[1]=",sArg$[1])
  //#cmpif 0x00000004 : DbgMsgVal$("sArg$[2]=",sArg$[2])
  //#cmpif 0x00000004 : DbgMsgVal$("sArg$[3]=",sArg$[3])

  //Check if this is to stop scanning ( AT+LSCNX )
  if (args==1) then
    StrToLower$(sArg$[0])
    if strcmp(sArg$[0],"x")==0 then
      ScanningStop()
      exitfunc RSP_OK
    endif
  endif

  //Get timeout into nArg[0]
  rc=SArgConvertToInt(0, SRegGet( CfgId_ScanTimeoutSec ), 0, SREG_ScanTimeoutSec_MAX)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  //Get Scan Pattern
  StrDeEscape(sArg$[1])  //ensure escaped characters are converted to binary

  //Get minimum RSSI threshold
  rc=SArgConvertToInt(2,-128,-128,20)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  //and now start scanning
  select curState
  case STATE_IDLE_nonVSP
    //Scan timeout has to be specified in milliseconds
    //now start scanning with new parameters
    rc = ScanningStart( (nArg[0]* 1000), sArg$[1], nArg[2])
    advPrefix$ = "\nAD0:"
    rc=RSP_OK

  case STATE_IDLE_VSP
    if nArg[0]== 0 then
      //permanent scanning requested
      rc=ScanningStart(0, sArg$[1], nArg[2])
      //change state
      advPrefix$ = "\nAD0:"
      NewState(STATE_IDLE_nonVSP)
      rc=RSP_OK
    else
      //Scan timeout has to be specified in milliseconds
      //if advertising and/or scanning in progress stop them
      AdvertsStop()
      //now start scanning with new parameters
      rc = ScanningStart( (nArg[0]* 1000), sArg$[1], nArg[2])
      if rc==0 then
        //successfully started scanning
        advPrefix$ = "\nAD1:"
        SaveState(oldIdleState)
        NewState(STATE_SCAN_VSP)
        //and suspend parser
        rc=RSP_SUSPEND
      endif
    endif

  case STATE_nonVSP_CONNECTED
    if nArg[0]== 0 then
      //do not allow unlimited timeout scanning
      rc = RSP_ERROR_VALUE_NOT_VALID
    else
      //if advertising and/or scanning in progress stop them
      AdvertsStop()
      //now start scanning with new parameters
      rc = ScanningStart( (nArg[0]* 1000), sArg$[1], nArg[2])
      if rc==0 then
        //successfully started scanning
        advPrefix$ = "\nAD2:"
        //remain in this state
      endif
    endif

  case else
    rc = RSP_ERROR_INCORRECT_MODE
  endselect

endfunc rc

//------------------------------------------------------------------------------
//:/ at+ladv<advType><,advIntervalMs>
//:/ at+ladv<x>
//------------------------------------------------------------------------------
function _atPlusLADV(byref cmdStr$, byref rspBuf$)
  dim args
  //This command has upto 2 parameters
  rc=ExtractArgsCSV(cmdStr$,args, 0,2)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  //Check if this is to stop advertising ( AT+LADVX )
  if (args==1) then
    StrToLower$(sArg$[0])
    if strcmp(sArg$[0],"x")==0 then
      AdvertsStop()
      if curState==STATE_IDLE_VSP then
        //only change state if we are in VSP Idle
        NewState(STATE_IDLE_nonVSP)
      endif
      exitfunc RSP_OK
    endif
  endif

  //Get advtype into nArg[0]
  rc=SArgConvertToInt(0,idleAdvType,SREG_IdleAdvertType_MIN,SREG_IdleAdvertType_MAX)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  if nArg[0]==1 then
    exitfunc RSP_ERROR_ADV_TYPE
  endif

  //Get adv interval milliseconds into nArg[1]
  rc=SArgConvertToInt(1,idleAdvIntvlMs,SREG_IdleAdvertIntvlMs_MIN,SREG_IdleAdvertIntvlMs_MAX)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  //if advertising in progress stop it
  AdvertsStop()
  //need to start advertising in idle
  IdleAdvCommit()
  //Start Advertising
  IdleStartAdverts(nArg[0], nArg[1])
  if curState==STATE_IDLE_VSP then
    //only change state if we are in VSP Idle
    NewState(STATE_IDLE_nonVSP)
  endif

endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+lvsp
//------------------------------------------------------------------------------
function _atPlusLVSP(byref cmdStr$, byref rspBuf$)
  dim args
  //This command has no parameters
  rc=ExtractArgsCSV(cmdStr$,args, 0,0)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  select curState
  case STATE_IDLE_nonVSP
    //if advertising or scanning in progress stop them
    #cmpif 0x00000004 : DbgMsg("VSP Connectable")
    AdvertsStop()
    ScanningStop()
    //get default parameters
    if vspAdded==0 then
      VspGetDefs()
      //open the VSP service and variable vspAdded will be updated
      rc = VspOpen()
    endif
    if vspAdded != 0 then
      //Create the VSP related Advert report and scan report and commit
      VspAdvCreateCommit()
      //Start Advertising
      VspStartAdverts()
      //change state
      NewState(STATE_IDLE_VSP)
      rc=RSP_OK
    else
      //change state to idle because we have definitely stopped adverts
      NewState(STATE_IDLE_nonVSP)
      rc=RSP_ERROR_VSP_OPENFAIL
    endif

  case STATE_IDLE_VSP
    //do nothing as already there anyway
    rc=RSP_OK

  case else
    rc = RSP_ERROR_INCORRECT_MODE

  endselect

endfunc rc

//------------------------------------------------------------------------------
//:/ at+bndt[addr]
//------------------------------------------------------------------------------
function _atPlusBNDT(byref cmdStr$, byref rspBuf$)
  rc = ExtractAddr(cmdStr$) //sArg$[0] is updated with address
  if rc != 0 then
    exitfunc rc
  endif

  dim isTrusted, keyInfo, rollAge, rollCount
  isTrusted =              BleBondingIsTrusted(sArg$[0], BOND_TRUSTED_AS_CENTRAL, keyInfo, rollAge, rollCount)
  isTrusted = isTrusted || BleBondingIsTrusted(sArg$[0], BOND_TRUSTED_AS_PERIPHERAL, keyInfo, rollAge, rollCount)
  if isTrusted then
    if rollAge <= 0 then
      rollAge=0   //persistant
    else
      rollAge=1   //rolling
    endif
    sprint #dontcare$, "\n1,";rollAge;",";StrHexize$(sArg$[0]);"\r"
  else
    dontcare$ = "\n0\r"
  endif
  rspBuf$ = rspBuf$ + dontcare$

endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+bndp[addr]
//------------------------------------------------------------------------------
function _atPlusBNDP(byref cmdStr$, byref rspBuf$)
  rc = ExtractAddr(cmdStr$) //sArg$[0] is updated with address
  if rc != 0 then
    exitfunc rc
  endif
endfunc BleBondingPersistKey(sArg$[0])

//------------------------------------------------------------------------------
//:/ at+bndd[addr]
//------------------------------------------------------------------------------
function _atPlusBNDD(byref cmdStr$, byref rspBuf$)
  rc = ExtractAddr(cmdStr$) //sArg$[0] is updated with address
  if rc != 0 then
    exitfunc rc
  endif

  rc=BleBondingEraseKey(sArg$[0])
  #cmpif 0x00000003 : AssertRC(28290)

endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+bndx
//------------------------------------------------------------------------------
function _atPlusBNDX(byref cmdStr$, byref rspBuf$)

  rc=BleBondingEraseAll()
  #cmpif 0x00000003 : AssertRC(28390)

endfunc RSP_OK

//------------------------------------------------------------------------------
// Process ATD command
//:/ATDmacaddress14hexbytes
//:/====
//:/
//:/
//------------------------------------------------------------------------------
function _atD(byref cmdStr$, byref rspBuf$)

  //Now check if we are heading for fast mode
  if (vspCmdModePin>=0) && (fLowPowerUart==0) then
    #cmpif 0x00000004 : DbgMsg("Fast Mode will be selected")
    //yes, so check state of that pin
    if GpioRead(vspCmdModePin)==0 then
      //cmd pin is incorrect state so disallow connection
      exitfunc CONN_ERROR_CMDPINSTATE
    endif
  endif

  //do not allow if we already have a connection
  if connCount > 0 then
    exitfunc CONN_ERROR_TOOMANYCONNECTIONS
  endif

  //extract address and load nArg[] with connection related parameters
  rc = ConnSetup(cmdStr$)
  if rc!=0 then
    exitfunc rc
  endif

  //save which state we got ATD in so we can return to it
  SaveState(oldIdleState)

  //assume a large default, will be reduced in the connect event from the
  //actual connection event time interval
  vspPumpToutMs = 250

  //change state
  NewState(STATE_VSP_CONNECTING)

endfunc CONN_SUSPEND

//------------------------------------------------------------------------------
// Process AT_LCON command
//:/AT_LCONmacaddress14hexbytes
//:/====
//:/
//:/
//------------------------------------------------------------------------------
function _atPlusLCON(byref cmdStr$, byref rspBuf$)

  //extract address and load nArg[] with connection related parameters
  rc = ConnSetup(cmdStr$)
  if rc!=0 then
    exitfunc rc
  endif

  if curState != STATE_nonVSP_CONNECTED then
    //save which state we got AT+LCON in so we can return to it
    SaveState(oldIdleState)
  endif

  //change state
  NewState(STATE_nonVSP_CONNECTING)

endfunc CONN_SUSPEND

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusCMD_I(cmdId, byref cmdStr$)
  dim args,hConn

  rc=ExtractArgsCSV(cmdStr$,args, 1,1)  //extract the connection handle
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert to integer and save in nArg[0]
  rc=SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  if curState != STATE_nonVSP_CONNECTED then
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif

  hConn = connHandles[nArg[0]]
  select cmdId
  // Process AT+LDSC command
  //:/AT+LDSCnn
  //:/====
  case CMD_I_LDSC
    if connHandles[nArg[0]) then
      rc=BleDisconnect(hConn)
      #cmpif 0x00000003 : AssertRC(29370)
    endif

  case CMD_I_PAIR
  // Process AT+PAIR command
  //:/AT+PAIRnn
  //:/====
    rc = BlePair(hConn,1)
    #cmpif 0x00000003 : AssertRC(29450)

  case CMD_I_LENC
  // Process AT+LENC command
  //:/AT+LENCnn
  //:/====
    rc = BleEncryptConnection(hConn, SRegGet(CfgId_MinEncryptionKeyLen), SRegGet(CfgId_MITMreqForEncryption))
    #cmpif 0x00000003 : AssertRC(29520)

#cmpif 0x00020000 :   case CMD_I_GCTM
#cmpif 0x00020000 :   // Process AT+GCTM command
#cmpif 0x00020000 :   //:/AT+GCTMnn
#cmpif 0x00020000 :   //:/====
#cmpif 0x00020000 :     rc = InitiateTableMap(hConn)
#cmpif 0x00000003 :     AssertRC(29590)


  case else
  endselect

endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusPRSP(byref cmdStr$)
  dim args,hConn

  if curState != STATE_nonVSP_CONNECTED then
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif

  rc=ExtractArgsCSV(cmdStr$,args, 2,3)  //extract the connection handle & response key
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert to integer and save in nArg[0]
  rc=SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  hConn = connHandles[nArg[0]]
  //convert the second parameter to lower case
  StrToLower$(sArg$[1])
  if strcmp(sArg$[1],"y")==0 then
    //accept pairing
    rc=BleAcceptPairing(hConn, 1)
  elseif strcmp(sArg$[1],"n")==0 then
    //reject pairing
    rc=BleAcceptPairing(hConn, 0)
  elseif strlen(sArg$[1])==32 then
    //OOB key is provided
    sArg$[1] = StrDehexize$(sArg$[1])
    if strlen(sArg$[1]) == 16 then
      rc=BleSecMngrOOBKey(hConn, sArg$[1])
    else
      rc=RSP_ERROR_INVALID_HEXSTR
    endif
  else
    rc=SArgConvertToInt(1, 0, 0, 999999)
    if rc==RSP_OK then
      rc=BleSecMngrPassKey(hConn, nArg[1])
    endif
  endif
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGCRD_WR(cmdType, byref cmdStr$)
  dim args,hConn

  if curState != STATE_nonVSP_CONNECTED then
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif

  rc=ExtractArgsCSV(cmdStr$,args, 3,3)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert connhandle to integer and save in nArg[0]
  rc=SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert attrhandle to integer and save in nArg[1]
  rc=SArgConvertToInt(1, 0, 1, 0xFFFE)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  select cmdType
  case 0  // GATTC Read
    //Convert offset to integer and save in nArg[2]
    rc=SArgConvertToInt(2, 0, 0, 511)
    if rc!=RSP_OK then
      exitfunc rc
    endif

  case 1,2
    dontcare$=strdehexize$(sArg$[2])
    if (strlen(dontcare$)*2) != strlen(sArg$[2]) then
      exitfunc RSP_ERROR_INVALID_HEXSTR
    endif

  case else
  endselect

  hConn = connHandles[nArg[0]]

  select cmdType
  case 0  // GATTC Read
    rc=BleGattcRead(hConn,nArg[1],nArg[2])

  case 1  //GATTC Write Acked
    rc=BleGattcWrite(hConn,nArg[1],dontcare$)

  case 2  //GATTC Write NOT Acked
    rc=BleGattcWriteCmd(hConn,nArg[1],dontcare$)

  case else
  endselect

endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGCFA(byref cmdStr$)
  dim args,i,hConn

  if curState != STATE_nonVSP_CONNECTED then
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif

  rc=ExtractArgsCSV(cmdStr$,args, 5,7)  //will be 7 if descriptor find
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert connection handle to integer and save in nArg[0]
  rc=SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  for i=1 to (args+1)
    //Yes, given we are using MAX_UUID_HANDLES below means that is the highest
    //instance of that object we can look for, but that is not a showstopper restriction in real life
    rc=SArgConvertToInt(i, 0, 0, (MAX_UUID_HANDLES-1))
    if rc!=RSP_OK then
      exitfunc rc
    endif
  next

  hConn = connHandles[nArg[0]]
  if args==7 then
    //find a descriptor
    rc=BleGattcFindDesc(hConn,uuidHandles[nArg[1]],nArg[2],uuidHandles[nArg[3]],nArg[4],uuidHandles[nArg[5]],nArg[6])
  else
    //find a characteristic
    rc=BleGattcFindChar(hConn,uuidHandles[nArg[1]],nArg[2],uuidHandles[nArg[3]],nArg[4])
  endif
endfunc rc

//------------------------------------------------------------------------------
// AT+UUID n,16bitUuid,m
// AT+UUID n,16bitUuid
// AT+UUID n,32bitHex
//------------------------------------------------------------------------------
function _atPlusUUID(byref cmdStr$, byref rspBuf$)
  dim args,hUuid

  rc=ExtractArgsCSV(cmdStr$,args, 2,3)  //extract up to 3 parameters
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert to uuid handle index and save in nArg[0]
  rc=SArgConvertToInt(0, 0, 0, (MAX_UUID_HANDLES-1))
  if rc!=RSP_OK then
    exitfunc rc
  endif

  if args==3 then
    //AT+UUID n,16bituuid,m

    //Convert 16 bit base offset and save in nArg[1]
    rc=SArgConvertToInt(1, 0, 0, 0xFFFF)
    if rc!=RSP_OK then
      exitfunc rc
    endif

    //Convert to uuid handle index and save in nArg[2]
    rc=SArgConvertToInt(2, 0, 0, (MAX_UUID_HANDLES-1))
    if rc!=RSP_OK then
      exitfunc rc
    endif

    hUuid = BleHandleUuidSibling(uuidHandles[nArg[2]],nArg[1])
  else
    if strlen(sArg$[1]) >= 10 then
      //AT+UUID n,32bitHex

      //get the 16 byte uuid
      sArg$[1] = StrDehexize$(sArg$[1])
      if strlen(sArg$[1]) != 16 then
        exitfunc RSP_ERROR_INVALID_HEXSTR
      endif

      hUuid = BleHandleUuid128(sArg$[1])

    else
      //AT+UUID n,16bitUuid

      //Convert 16 bit base offset and save in nArg[1]
      rc=SArgConvertToInt(1, 0, 0, 0xFFFF)
      if rc!=RSP_OK then
        exitfunc rc
      endif

      hUuid = BleHandleUuid16(nArg[1])

    endif
  endif

  if hUuid==0 then
    exitfunc RSP_ERROR_INVALID_UUID
  endif

  uuidHandles[nArg[0]] = hUuid

  sprint #dontcare$,"\n" ; integer.h' hUuid ; "\r"
  //append to buffer
  rspBuf$ = rspBuf$ + dontcare$

endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusCMD_IS(cmdType, byref cmdStr$)
  dim args,hChar

  rc=ExtractArgsCSV(cmdStr$,args, 2,2)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert first parm to integer and save in nArg[0]
  rc=SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert data to binary
  dontcare$=strdehexize$(sArg$[1])
  if (strlen(dontcare$)*2) != strlen(sArg$[1]) then
    exitfunc RSP_ERROR_INVALID_HEXSTR
  endif

  hChar = charHandles[nArg[0]]
  select cmdType
  case CMD_IS_NOTIFY
    if curState != STATE_nonVSP_CONNECTED then
      exitfunc RSP_ERROR_INCORRECT_MODE
    endif
    rc=BleCharValueNotify(hChar,dontcare$)

  case CMD_IS_INDICATE
    if curState != STATE_nonVSP_CONNECTED then
      exitfunc RSP_ERROR_INCORRECT_MODE
    endif
    rc=BleCharValueIndicate(hChar,dontcare$)

  case CMD_IS_LOCALWRITE
    rc=BleCharValueWrite(hChar,dontcare$)

  case else
    rc=RSP_ERROR_UNKNOWN_CMD
  endselect
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGSSB_E(fNew, byref cmdStr$)
  dim args

  if fNew then
    rc=ExtractArgsCSV(cmdStr$,args, 1,1)  //extract the uuid handle index
    if rc!=RSP_OK then
      exitfunc rc
    endif
    //Convert to uuid handle index and save in nArg[0]
    rc=SArgConvertToInt(0, 0, 0, (MAX_UUID_HANDLES-1))
    if rc!=RSP_OK then
      exitfunc rc
    endif

    //A new service is being defined
    if svcHandle then
      //We have not ENDed a service definition yet
      exitfunc RSP_ERROR_SVC_NOTENDED
    endif
    //Always define a primary service
    rc=BleServiceNew(1,uuidHandles[nArg[0]],svcHandle)

  else
    //The end of a service definition
    rc=BleServiceCommit(svcHandle)
    svcHandle=0

  endif
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGSMD(byref cmdStr$)
  dim args,i

  rc=ExtractArgsCSV(cmdStr$,args, 4,4)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert to metadata handle index and save in nArg[0]
  rc=SArgConvertToInt(0, 1, 1, MAX_METADATA_HANDLES)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert to read & write rights and save in nArg[]
  for i=1 to 2
    rc=SArgConvertToInt(i, 0, 0, 3)  //4&5 are not allowed.
    if rc!=RSP_OK then
      exitfunc rc
    endif
  next
  //Convert to length and save in nArg[3]
  rc=SArgConvertToInt(3, 1, 1, MAX_ATTRIBUTE_LEN)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  //Set nFlags to 0 -- No capability for authorisation exposed.
  metaHandles[nArg[0]] = BleAttrMetadataEx(nArg[1],nArg[2],nArg[3],0,rc)

endfunc rc

//------------------------------------------------------------------------------
//AT+GSCB u,pr,m{V}<,m{C}<,m{S}>>  //CharAdd m{XXX} is the metadata index and 0 means not provided.
//------------------------------------------------------------------------------
function _atPlusGSCB(byref cmdStr$)
  dim args,i

  if chrInProg then
    exitfunc RSP_ERROR_CHAR_NOTENDED
  endif

  rc=ExtractArgsCSV(cmdStr$,args,3,5)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert to uuid handle index and save in nArg[0]
  rc=SArgConvertToInt(0, 1, 1, (MAX_UUID_HANDLES-1))
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert to properties and save in nArg[1]
  rc=SArgConvertToInt(1, 1, 1, 63)  //does not allow reliable writes
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Initialise all 3 metadata in nArg[2]..nArg[4] to 0
  nArg[3]=0 : nArg[4]=0
  //Convert to read & write rights and save in nArg[]
  args = args -1
  for i=2 to args
    rc=SArgConvertToInt(i, 1, 1, MAX_METADATA_HANDLES)
    if rc!=RSP_OK then
      exitfunc rc
    endif
  next
  rc=BleCharNew(nArg[1],uuidHandles[nArg[0]],metaHandles[nArg[2]],metaHandles[nArg[3]],metaHandles[nArg[4]])
  if rc==0 then
    chrInProg=1
  endif
endfunc rc

//------------------------------------------------------------------------------
//AT+GSCE hexdata   - returns an index to identify the characteristic
//------------------------------------------------------------------------------
function _atPlusGSCE(byref cmdStr$,byref rspBuf$)
  dim args,charH,nIdx

  if chrInProg==0 then
    exitfunc RSP_OK
  endif
  if svcHandle==0 then
    exitfunc RSP_ERROR_SVC_NOTSTARTED
  endif

  rc=ExtractArgsCSV(cmdStr$,args, 1,1)
  if rc!=RSP_OK then
    exitfunc rc
  endif
  //Convert data to binary
  dontcare$=strdehexize$(sArg$[0])
  if (strlen(dontcare$)*2) != strlen(sArg$[0]) then
    exitfunc RSP_ERROR_INVALID_HEXSTR
  endif

  rc=BleCharCommit(svcHandle,dontcare$,charH)
  if rc==0 then
    chrInProg=0
    rc=AddCharHandle(charH,nIdx)
    if rc==0 then
      sprint #dontcare$,"\n" ; nIdx ; "\r"
      //append to buffer
      rspBuf$ = rspBuf$ + dontcare$
    endif
  endif

endfunc rc

//------------------------------------------------------------------------------
//AT+GSDA u,m,hexdata      //Descriptor Add
//------------------------------------------------------------------------------
//function _atPlusGSDA(byref cmdStr$)
//  dim charH,nIdx
//
//  if chrInProg==0 then
//    exitfunc RSP_ERROR_CHAR_NOTSTARTED
//  endif
//
//  rc=ExtractArgsCSV(cmdStr$,args, 3,3)
//  if rc!=RSP_OK then
//    exitfunc rc
//  endif
//  //Convert to uuid handle index and save in nArg[0]
//  rc=SArgConvertToInt(0, 1, 1, (MAX_UUID_HANDLES-1))
//  if rc!=RSP_OK then
//    exitfunc rc
//  endif
//  //Convert to metadata handle index and save in nArg[1]
//  rc=SArgConvertToInt(1, 1, 1, MAX_METADATA_HANDLES)
//  if rc!=RSP_OK then
//    exitfunc rc
//  endif
//  //Convert data to binary
//  dontcare$=strdehexize$(sArg$[2])
//  if (strlen(dontcare$)*2) != strlen(sArg$[2]) then
//    exitfunc RSP_ERROR_INVALID_HEXSTR
//  endif
//
//  DO SOMETHING HERE
//
//endfunc rc

//------------------------------------------------------------------------------
// AT% has been encountered
//------------------------------------------------------------------------------
function _atPERCENT(byref cmdStr$, byref rspBuf$)

  //Extract the command letter and process
  select GetAtCmdLetter(cmdStr$)
  case ATCMD_S,(ATCMD_S+0x20)
    rc=_atsSTR(cmdStr$,rspBuf$)

  case else
    rc=RSP_ERROR_UNKNOWN_CMD

  endselect

endfunc rc

//------------------------------------------------------------------------------
// AT& has been encountered
//------------------------------------------------------------------------------
function _atAMPERSAND(byref cmdStr$, byref rspBuf$)

  //Extract the command letter and process
  select GetAtCmdLetter(cmdStr$)
  case ATCMD_W,(ATCMD_W+0x20)
    rc=_atampW(cmdStr$,rspBuf$)

  case ATCMD_F,(ATCMD_F+0x20)
    rc=_atampF(cmdStr$,rspBuf$)

  case else
    rc=RSP_ERROR_UNKNOWN_CMD

  endselect

endfunc rc

//------------------------------------------------------------------------------
//:/ at+nopn max_buf_len <,writable>
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNOPN(byref cmdStr$)
#cmpif 0x00200000 :   dim args
#cmpif 0x00200000 :   sArg$[0]=""
#cmpif 0x00200000 :   rc=ExtractArgsCSV(cmdStr$,args, 1,2)
#cmpif 0x00200000 :   if rc!=RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   //Get max_buf_len into nArg[0]
#cmpif 0x00200000 :   rc=SArgConvertToInt(0, NFC_DEFAULT_TAG_SIZE, NFC_MIN_TAG_SIZE, NFC_MAX_TAG_SIZE)
#cmpif 0x00200000 :   if rc!=RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   //Get writable into nArg[1]
#cmpif 0x00200000 :   nArg[1]=0 //default is not writable
#cmpif 0x00200000 :   if args>1 then
#cmpif 0x00200000 :     rc=SArgConvertToInt(1, 0, 0, 1)
#cmpif 0x00200000 :     if rc!=RSP_OK then
#cmpif 0x00200000 :       exitfunc rc
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   //open nfc and allocate memory for the ndef message
#cmpif 0x00200000 :   rc=NfcOpen(0,"\00",nfcHandle)
#cmpif 0x00200000 :   if rc==0 then
#cmpif 0x00200000 :     rc=NfcNdefMsgNew(nArg[0],ndefHandle)
#cmpif 0x00200000 :     if rc!=0 then
#cmpif 0x00200000 :       NfcClose(nfcHandle)
#cmpif 0x00200000 :       nfcHandle =INVALID_NFC_HANDLE
#cmpif 0x00200000 :       ndefHandle=INVALID_NDEF_HANDLE
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+ncls
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNCLS()
#cmpif 0x00200000 :   if nfcHandle!=INVALID_NFC_HANDLE then
#cmpif 0x00200000 :     if ndefHandle!=INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :       //release the ndef message buffer
#cmpif 0x00200000 :       rc=NfcNdefMsgDelete(ndefHandle)
#cmpif 0x00200000 :       ndefHandle=INVALID_NDEF_HANDLE
#cmpif 0x00200000 :       //close the nfc
#cmpif 0x00200000 :       NfcClose(nfcHandle)
#cmpif 0x00200000 :       nfcHandle =INVALID_NFC_HANDLE
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc 0  //  rc=0


//------------------------------------------------------------------------------
//:/ at+nrst
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRST()
#cmpif 0x00200000 :   rc=RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if nfcHandle!=INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     if ndefHandle!=INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :       rc=NfcNdefMsgReset(ndefHandle)
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nrat "lang","message"
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRAT(byref cmdStr$)
#cmpif 0x00200000 :   dim args,id$,type$,lang$
#cmpif 0x00200000 :   sArg$[0]=""
#cmpif 0x00200000 :   rc=ExtractArgsCSV(cmdStr$,args, 2,2)
#cmpif 0x00200000 :   if rc!=RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   rc=RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if ndefHandle!=INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     //Add a NDEF Record of type "T" and message in language code provided
#cmpif 0x00200000 :     lang$="\00"+sArg$[0]
#cmpif 0x00200000 :     rc=strsetchr(lang$,strlen(lang$)-1,0)
#cmpif 0x00200000 :     //AssertRC(35160)
#cmpif 0x00200000 :     id$=""
#cmpif 0x00200000 :     type$="T"
#cmpif 0x00200000 :     StrDeEscape(sArg$[1])
#cmpif 0x00200000 :     rc=NfcNdefRecAddGeneric(ndefHandle,NFC_TNF_WELL_KNOWN,type$,id$,lang$,INVALID_NDEF_HANDLE,sArg$[1])
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nrag tnf,"type","id","val0"
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRAG(byref cmdStr$)
#cmpif 0x00200000 :   dim args
#cmpif 0x00200000 :   sArg$[0]=""
#cmpif 0x00200000 :   rc=ExtractArgsCSV(cmdStr$,args, 4,4)
#cmpif 0x00200000 :   if rc!=RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   //Get tnf into nArg[0]
#cmpif 0x00200000 :   rc=SArgConvertToInt(0, NFC_TNF_UNKNOWN_TYPE, NFC_TNF_EMPTY, NFC_TNF_RESERVED)
#cmpif 0x00200000 :   if rc!=RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   rc=RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if ndefHandle!=INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     //Add a NDEF Record
#cmpif 0x00200000 :     StrDeEscape(sArg$[1])
#cmpif 0x00200000 :     StrDeEscape(sArg$[2])
#cmpif 0x00200000 :     StrDeEscape(sArg$[3])
#cmpif 0x00200000 :     dontcare$=""
#cmpif 0x00200000 :     rc=NfcNdefRecAddGeneric(ndefHandle,nArg[0],sArg$[1],sArg$[2],sArg$[3],INVALID_NDEF_HANDLE,dontcare$)
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+ncmt
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNCMT()
#cmpif 0x00200000 :   dim records,memTotal,memUsed
#cmpif 0x00200000 :   rc=RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if nfcHandle!=INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     rc=NfcNdefMsgGetInfo(ndefHandle,records,memTotal,memUsed)
#cmpif 0x00200000 :     if rc==0 then
#cmpif 0x00200000 :       if records>0 then
#cmpif 0x00200000 :         rc=NfcNdefMsgCommit(nfcHandle,ndefHandle)
#cmpif 0x00200000 :       else
#cmpif 0x00200000 :         rc=RSP_ERROR_NFC_NDEF_EMPTY
#cmpif 0x00200000 :       endif
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nsen
//:/ at+nsds
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNS_EN_DS( onOff )
#cmpif 0x00200000 :   rc=RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if nfcHandle!=INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     rc=NfcFieldSense(nfcHandle,onOff)
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+acmt    //Commit NonVspo advert & scan reports if not in VSP  mode
//------------------------------------------------------------------------------
function _atPlusACMT()
  if (curState==STATE_IDLE_nonVSP)||(curState==STATE_nonVSP_CONNECTED) then
    //only allow reports to be commited if in non-vsp idle mode or non-vsp connected
    IdleAdvCommit()
  else
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif
endfunc 0

//------------------------------------------------------------------------------
//:/ at+aara tag,"data"  //Append AD to NonVsp Advert report
//:/ at+asra tag,"data"  //Append AD to NonVsp Scan report
//------------------------------------------------------------------------------
function _atPlusAxRA(cmdStr$, rpt$)
  dim args
  rc = ExtractArgsCSV(cmdStr$,args,2,2)
  if rc == 0 then
    //convert the tag to an integer
    rc = SArgConvertToInt(0,-1,0,255)  //-1 will result in an error
    if rc!=RSP_OK then
      exitfunc rc
    endif
    //de-escape the data
    StrDeEscape(sArg$[1])
    //finally append to the report
    rc=BleAdvRptAppendAD(rpt$,nArg[0],sArg$[1])
  endif
endfunc rc

//------------------------------------------------------------------------------
//:/ at+arst <conn>   //Non Vsp Advert reports reset ( conn==0 or 1) default = 1
//:/ at+sfmt <fmt>    //scan advert report format type, default fmt=0
//------------------------------------------------------------------------------
function _atPlusM0O1(byref cmdStr$,cmdId,defval,mn,mx)
  dim args
  rc=ExtractArgsCSV(cmdStr$,args, 0,1)
  if rc!=RSP_OK then
    exitfunc rc
  endif

  //extract optional parameter
  if args==1 then
    rc = SArgConvertToInt(0,defval,mn,mx)
    if rc!=RSP_OK then
      exitfunc rc
    endif
  else
    nArg[0]=defval
  endif

  select cmdId
  case 0 //arst
    GenAdvCreateMinimal(idleAdvRpt$, idleScnRpt$)
    if nArg[0]==0 then
      //not connectable advert so we can remove all AD elements from the ADV report
      idleAdvRpt$ = idleScnRpt$
    endif

  case 1 //sfmt
    scnFmt = nArg[0]

  case else
  endselect

endfunc rc

//------------------------------------------------------------------------------
// AT+ has been encountered
//------------------------------------------------------------------------------
function _atPLUS(byref cmdStr$, byref rspBuf$)
  dim tmp$

  //extract the first 4 characters
  tmp$=StrSplitLeft$(cmdStr$,4)
  //convert all data to lower case
  StrToLower$(tmp$)
  //check what command it is
  if strcmp(tmp$,"sior")==0 then
    rc=_atPlusSIO(0,cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"siow")==0 then
    rc=_atPlusSIO(1,cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"sioc")==0 then
    rc=_atPlusSIO(2,cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"lscn")==0 then
    rc=_atPlusLSCN(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"lvsp")==0 then
    rc=_atPlusLVSP(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"ladv")==0 then
    rc=_atPlusLADV(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"bndt")==0 then
    rc=_atPlusBNDT(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"bndp")==0 then
    rc=_atPlusBNDP(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"bndd")==0 then
    rc=_atPlusBNDD(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"bndx")==0 then
    rc=_atPlusBNDX(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"lcon")==0 then
    rc=_atPlusLCON(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"ldsc")==0 then
    rc=_atPlusCMD_I(CMD_I_LDSC, cmdStr$)

  elseif strcmp(tmp$,"pair")==0 then
    rc=_atPlusCMD_I(CMD_I_PAIR, cmdStr$)

  elseif strcmp(tmp$,"lenc")==0 then
    rc=_atPlusCMD_I(CMD_I_LENC, cmdStr$)

  elseif strcmp(tmp$,"prsp")==0 then
    rc=_atPlusPRSP(cmdStr$)

  elseif strcmp(tmp$,"gcrd")==0 then
    rc=_atPlusGCRD_WR(0,cmdStr$)

  elseif strcmp(tmp$,"gcwa")==0 then    //write acked
    rc=_atPlusGCRD_WR(1,cmdStr$)

  elseif strcmp(tmp$,"gcwc")==0 then    //write cmd (not acked)
    rc=_atPlusGCRD_WR(2,cmdStr$)

  elseif strcmp(tmp$,"gcfa")==0 then    //find attribute of characteristic value or descriptor
    rc=_atPlusGCFA(cmdStr$)

  elseif strcmp(tmp$,"uuid")==0 then
    rc=_atPlusUUID(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"gsno")==0 then
    rc=_atPlusCMD_IS(CMD_IS_NOTIFY,cmdStr$)

  elseif strcmp(tmp$,"gsic")==0 then
    rc=_atPlusCMD_IS(CMD_IS_INDICATE,cmdStr$)

  elseif strcmp(tmp$,"gssb")==0 then
    rc=_atPlusGSSB_E(1,cmdStr$)

  elseif strcmp(tmp$,"gsse")==0 then
    rc=_atPlusGSSB_E(0,cmdStr$)

  elseif strcmp(tmp$,"gsmd")==0 then
    rc=_atPlusGSMD(cmdStr$)

  elseif strcmp(tmp$,"gscb")==0 then
    rc=_atPlusGSCB(cmdStr$)

  elseif strcmp(tmp$,"gsce")==0 then
    rc=_atPlusGSCE(cmdStr$,rspBuf$)

  elseif strcmp(tmp$,"gswc")==0 then
    rc=_atPlusCMD_IS(CMD_IS_LOCALWRITE,cmdStr$)

  elseif strcmp(tmp$,"arst")==0 then
    rc=_atPlusM0O1(cmdStr$,0,1,0,1)

  elseif strcmp(tmp$,"acmt")==0 then
    rc=_atPlusACMT()

  elseif strcmp(tmp$,"aara")==0 then
    rc=_atPlusAxRA(cmdStr$, idleAdvRpt$)

  elseif strcmp(tmp$,"asra")==0 then
    rc=_atPlusAxRA(cmdStr$, idleScnRpt$)

  elseif strcmp(tmp$,"sfmt")==0 then
    rc=_atPlusM0O1(cmdStr$,1,0,0,1)

//  --------------------------------------------------
// Following only to be added when custom descriptor requirement
// asked for.
//  --------------------------------------------------
//  elseif strcmp(tmp$,"gsda")==0 then
//    rc=_atPlusGSDA(cmdStr$)
//  --------------------------------------------------

  //Optional Tablemap command
#cmpif 0x00020000 :   elseif strcmp(tmp$,"gctm")==0 then  //tablemap
#cmpif 0x00020000 :     rc=_atPlusCMD_I(CMD_I_GCTM, cmdStr$)

  //Optional NFC related commands
#cmpif 0x00200000 :   elseif strcmp(tmp$,"nopn")==0 then
#cmpif 0x00200000 :     rc=_atPlusNOPN(cmdStr$)
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$,"ncls")==0 then
#cmpif 0x00200000 :     rc=_atPlusNCLS()
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$,"nrst")==0 then
#cmpif 0x00200000 :     rc=_atPlusNRST()
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$,"nrat")==0 then
#cmpif 0x00200000 :     rc=_atPlusNRAT(cmdStr$)
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$,"nrag")==0 then
#cmpif 0x00200000 :     rc=_atPlusNRAG(cmdStr$)
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$,"ncmt")==0 then
#cmpif 0x00200000 :     rc=_atPlusNCMT()
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$,"nsen")==0 then
#cmpif 0x00200000 :     rc=_atPlusNS_EN_DS(1)
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$,"nsds")==0 then
#cmpif 0x00200000 :     rc=_atPlusNS_EN_DS(0)

  else
    //Not a known 'at+' command
    rc = RSP_ERROR_UNKNOWN_CMD
  endif
endfunc rc

//------------------------------------------------------------------------------
// Function for parsing commands when in application command mode and cmdStr$
// is at least 3 characters
//------------------------------------------------------------------------------
sub ParseAtCommand(byref cmdStr$, byref rspBuf$)
  dim tmp$

  //extract the first 2 characters
  tmp$=StrSplitLeft$(cmdStr$,2)
  //convert all data to lower case
  StrToLower$(tmp$)
  //check that it is "at"
  if strcmp(tmp$,"at")!=0 then
    //Not an 'at' command
    rc = RSP_ERROR_SYNTAX_ERROR
  else
    //Extract the command letter and process
    select GetAtCmdLetter(cmdStr$)
    case ATCMD_EMPTY
      rc=RSP_OK

    case ATCMD_I,(ATCMD_I+0x20)
      rc=_ati(cmdStr$,rspBuf$)

    case ATCMD_S,(ATCMD_S+0x20)
      rc=_ats(cmdStr$,rspBuf$)

    case ATCMD_D,(ATCMD_D+0x20)
      rc=_atD(cmdStr$,rspBuf$)
      AppendConnRspEnd(rc,rspBuf$)
      exitsub //becuase we don't want to hit the AppendRspEnd() at the end of this routine

    case ATCMD_Z,(ATCMD_Z+0x20)
      reset(0)

    case ATCMD_PERCENT
      rc=_atPERCENT(cmdStr$,rspBuf$)

    case ATCMD_AMPERSAND
      rc=_atAMPERSAND(cmdStr$,rspBuf$)

    case ATCMD_PLUS
      rc=_atPLUS(cmdStr$,rspBuf$)

    case else
      rc=RSP_ERROR_UNKNOWN_CMD

    endselect
  endif

  // Add an OK or ERROR to the response
  AppendRspEnd(rc,rspBuf$)

endsub

//------------------------------------------------------------------------------
// Routine to service command mode, if it returns 0, then it implies exit the application
//------------------------------------------------------------------------------
sub ProcessCommands(byref ORIGRecBuf$,byref RSPSndBuf$)
  dim termPos, cmdStr$

  //find position of the first \r in the string
  termPos = StrPos(ORIGRecBuf$, termStr$, 0)
  while (atParse)&&(termPos >= 0)
    if (termPos == 0) then
      //empty string so just send OK
      AppendRspEnd(RSP_OK,RSPSndBuf$)
      cmdStr$=StrSplitLeft$(ORIGRecBuf$, 1)
    else
      //non empty string
      termPos = termPos + 1
      cmdStr$=StrSplitLeft$(ORIGRecBuf$, termPos)

      //Parse and run AT command
      ParseAtCommand(cmdStr$,RSPSndBuf$)
    endif
    //Send out data waiting in buffer
    SendUartData()
    //find position of the first \r in the string
    termPos = StrPos(ORIGRecBuf$, termStr$, 0)
  endwhile
endsub

//------------------------------------------------------------------------------
// Startup
//------------------------------------------------------------------------------
sub Startup()
  dim scanPat$,i

  //initial nonVsp connection handle array
  for i = 0 to MAX_CONNECTIONS
    connHandles[i]=INVALID_CONN_HANDLE
  next

  //initial uuid handle array
  for i = 0 to (MAX_UUID_HANDLES-1)
    uuidHandles[i]=INVALID_UUID_HANDLE
  next

  //Initialise the first metadata handle to 0 and will remain that way
  metaHandles[0]=0

  //set SRegister Defaults
  SReg8SetCache()
  SReg16SetCache()
  SReg32SetCache()
  SRegStrSetCache()

  //Wait for tx buffer to flush
  #cmpif 0x00000001 : while UartInfo(5)>0
  #cmpif 0x00000001 : endwhile

  //get startup flags
  startflags=SRegGet(CfgId_StartupFlags)

  //Update config keys and reset if required
  dim nUpdated,newVal : nUpdated=0

  //Configure for high bandwidth
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  #cmpif 0x00100000 : if (((startflags>>5) & 0x00000003) == 0x01) then
  #cmpif 0x00100000 :   //if long range is enabled then highbandwidth needs to be forced to enabled
  #cmpif 0x00100000 :   newVal = 1
  #cmpif 0x00100000 : else
    //Else use bit 3 of startflags to define highbandwidth
    //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
    newVal = ((startflags>>3) & 0x00000001)
  #cmpif 0x00100000 : endif
  SetConfigKey(ENABLE_HIGH_BANDWIDTH_KEY_ID,newVal,nUpdated)       //Bandwidth set

  //Update Data Length Extension related config keys
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  if ((startflags>>4)&0x00000001) then
    vspAttrMaxLen = DLE_ATTRIBUTE_SIZE
  else
    vspAttrMaxLen = DEFAULT_ATTRIBUTE_SIZE
  endif
  SetConfigKey(ATTRIBUTE_DATA_LENGTH_KEY_ID, vspAttrMaxLen,     nUpdated) //Maximum size of attibutes
  SetConfigKey(ATTRIBUTE_MTU_KEY_ID,        (vspAttrMaxLen+3),  nUpdated) //Maximum size of ATT_MTU
  SetConfigKey(BLE_MAX_PACKET_LENGTH_KEY_ID,(vspAttrMaxLen+3+4),nUpdated) //Maximum size of on-air packet length

  //If any config keys were changed then reset module so they come into effect
  if nUpdated>0 then
    reset(0)
  endif

  vspChunkLen = DEFAULT_ATTRIBUTE_SIZE

  //Setup the uart
  InitUART()
  //If we came alive because of a reset() call earlier, then send an OK
  if sysinfo(2000)==10 then
    AppendRspEnd(RSP_OK,UARTSndBuf$)
    //Send out data waiting in buffer
    SendUartData()
  endif

  #cmpif 0x00000001 : print "\n## startFlags = 0x";integer.h' startflags
  #cmpif 0x00000004 : DbgMsgVal("AttrMaxLen =",vspAttrMaxLen)
  #cmpif 0x00000200 : rc=GpioBindEvent(0,BUTTON2,1)
  #cmpif 0x00000200 : rc=GpioBindEvent(1,BUTTON1,1)

  //Initialise the GPIO
  InitGPIO()

  //Configure Pairing Capability
  PairingConfig()

  //Initialise the GAP Service
  GapServiceGetDefs()  //into sArg$[] and nArg[]
  rc=GapServiceUpdate()

  //Cache & Config Scanning Paramters
  CacheConfigScanParms()

  //Precreate the idle more advert reports
  IdleAdvCreate()
  CacheAdvertType() //Cache variable idleAdvType with SReg value
  idleAdvIntvlMs = SRegGet(CfgId_IdleAdvertIntvlMs)

  //Cache the max ^ count
  vspEscCountMax = SRegGet(CfgId_VspEscChrCountMax)
  //Cache the min ^ interval
  vspEscMinIntrvl = SRegGet(CfgId_VspEscChrIntrvlMinMs)

  //Vsp escape string in slow connection mode
  vspEscString$ = "^"
  vspEscStringLen = strlen(vspEscString$)+1 //Added 1 to ensure that if we get 1 more byte then
                                            //we have NOT received the escape sequence

  //Get startup flags
  vspAdded = 0
  //Check if need to make connectable for VSP
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  if (startflags & 0x00000001) then
    #cmpif 0x00000004 : DbgMsg("VSP Connectable")
    //get default parameters
    VspGetDefs()
    //open the VSP service and variable vspAdded will be updated
    rc = VspOpen()
    if vspAdded != 0 then
      //Create the VSP related Advert report and scan report and commit
      VspAdvCreateCommit()
      //Start Advertising
      VspStartAdverts()
      //change state
      NewState(STATE_IDLE_VSP)
    endif
  endif
  if vspAdded == 0 then
    //VSP was not added
    //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
    if ((startflags & 0x00000006)==0) then
      //do not start advertising or scanning
      NewState(STATE_IDLE_nonVSP)
      exitsub
    endif
    //Check if adverts to be started
    //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
    if ((startflags & 0x00000002)==0x00000002) then
      //need to start advertising in idle
      IdleAdvCommit()
      //Start Advertising
      IdleStartAdverts(idleAdvType, idleAdvIntvlMs)
      //#cmpif 0x00000004 : DbgMsg("IDLE_ADV_SCN adverts started")
    endif
    //Check if scanning to be started
    //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
    if ((startflags & 0x00000004)==0x00000004) then
      //need to start scanning in idle
      scanPat$=SRegGetStr$( CfgIdStr_ScanPattern )
      rc = ScanningStart(0,scanPat$,SRegGet(CfgId_ScanRssiMinimum))
      //#cmpif 0x00000004 : DbgMsg("IDLE_ADV_SCN scanning started")
    endif
    //change state
    advPrefix$ = "\nAD0:"
    NewState(STATE_IDLE_nonVSP)
  endif

endsub

//******************************************************************************
// Handlers
//******************************************************************************

//------------------------------------------------------------------------------
// In Command mode and data has arrived from the uart
//------------------------------------------------------------------------------
function HndlrUartCommand()
  //Data received from UART
  dontcare = UARTReadN(UARTRecBuf$, MaxCmdStringSize)
  ProcessCommands(UARTRecBuf$,UARTSndBuf$)
endfunc 1

//------------------------------------------------------------------------------
// Called when scanning has timedout
//------------------------------------------------------------------------------
function HndlrScanTimeout() as integer
  #cmpif 0x00000004 : DbgMsg("Scan Timeout")

  if curState==STATE_SCAN_VSP then
    rc=BleScanAbort()

    IdleReturnAction()

    //send an OK response
    AppendRspEnd(RSP_OK,UARTSndBuf$)
    //Send out data waiting in buffer
    SendUartData()
    //also trigger a reprocessing of the uart buffer just in case
    rc=SendMsgApp(MSGAPP_PROCESS_UART, DONTCARE_CTX)
  else
    //send a 'scanend' response
    SendScanEnd(UARTSndBuf$)
  endif
endfunc 1

//------------------------------------------------------------------------------
// This handler is called when a connection attempt has timeout
//------------------------------------------------------------------------------
function HndlrConnTout()
  #cmpif 0x00000004 : DbgMsg("Connect Timeout")
  select curState
  case STATE_VSP_CONNECTING
    VspNoCarrierRet(CONN_ERROR_TIMEOUT)

  case STATE_nonVSP_CONNECTING
    if connCount<=0 then
      //first outgoing nonvsp connection
      NonVspDisconRet(CONN_ERROR_TIMEOUT, 0)  //will take us back to the idle state
    else
      //multiple nonvsp connections
      //send an DISCON response
      SendNonVspDiscon(CONN_ERROR_TIMEOUT,0,UARTSndBuf$)
      //change state
      NewState(STATE_nonVSP_CONNECTED)
      //also trigger a reprocessing of the uart buffer just in case
      rc=SendMsgApp(MSGAPP_PROCESS_UART, DONTCARE_CTX)
    endif

  case else
  endselect
endfunc 1

//------------------------------------------------------------------------------
// This handler is called when there at least one scan response waiting to be read
dim _display, _adType  //To only be used by the following functions
//------------------------------------------------------------------------------
function HndlrAdvReport()
  //Read all cached advert reports
  rc=BleScanGetAdvReportEx(_adType,periphAddr$, advData$, nDiscarded, nRssi, dontcare)
  while (rc == 0)
    #cmpif 0x00000400 : print "\n## Adv=";strhexize$(advData$)
    _display=0
    if nRssi > scnRssi then
      if scnPatternLen>0 then
        if strpos(advData$,scnPattern$,0) >= 0 then
          //rssi is above threshold and pattern found
          _display=1
        endif
      else
        //rssi is above threshold and no pattern specified
        _display=1
      endif
    endif
    if _display then
      #cmpif 0x00400000 : UartReOpen()
      print advPrefix$;_adType;" ";StrHexize$(periphAddr$);" ";nRssi
      select scnFmt
      case 1
        print " \22"; StrHexize$(advData$);"\22\r"

      case else
        rc = BleGetADBytag(advData$, 0x09, nme$)
        print " \22"; nme$ ; "\22\r";
      endselect
    endif
    rc=BleScanGetAdvReport(periphAddr$, advData$, nDiscarded, nRssi)
  endwhile
endfunc 1

//------------------------------------------------------------------------------
//Disconnect
//------------------------------------------------------------------------------
function HndlrDisCon(hndl as integer, rsn as integer)
  #cmpif 0x00000004 : DbgMsg("Disconnect")

  select curState
  case STATE_VSP_DISCONNECTING, STATE_VSP_PAIRING, STATE_VSP_CARET_CONNECTED,STATE_VSP_FAST_CONNECTED
    //Some other error while writing to a cccd
    if vspDisconSts<=0 then
      //assume a normal disconnection has happenned
      vspDisconSts=CONN_ERROR_USER_DISCON
    endif
    //Deassert DCD
    VspDcdDeassert()
    //Send response
    VspNoCarrierRet(vspDisconSts)
    connHandles[HCONN_VSP] = INVALID_CONN_HANDLE

  case STATE_nonVSP_CONNECTING, STATE_nonVSP_CONNECTED
    dim nodeIdx : nodeIdx = GetIdxFromHConn(hndl)
    if nodeIdx==0 then
      //ignore this because we were not track that connection
    else
      if connCount<=1 then  //comparing against 1 because it decremented at the end of this routine
        //first outgoing nonvsp connection
        NonVspDisconRet(rsn, nodeIdx)  //will take us back to the idle state
      else
        //multiple nonvsp connections
        //send an DISCON response
        SendNonVspDiscon(rsn,nodeIdx,UARTSndBuf$)
        //also trigger a reprocessing of the uart buffer just in case
        rc=SendMsgApp(MSGAPP_PROCESS_UART, DONTCARE_CTX)
      endif
      connHandles[nodeIdx]=INVALID_CONN_HANDLE
    endif

  case else
    //Deassert DCD
    VspDcdDeassert()
    //Send response
    VspNoCarrierRet(rsn)
    connHandles[HCONN_VSP] = INVALID_CONN_HANDLE
  endselect

  if connCount>0 then
    //decrement the connection count
    connCount=connCount-1
  endif

endfunc 1

//------------------------------------------------------------------------------
//CCCD Descriptor found via BleGattcFindDesc()
//------------------------------------------------------------------------------
function HndlrFindDesc(hConn, hAttr)
  //#cmpif 0x00000004 : DbgMsgVal("EvFindDesc hAttr=",hAttr)

  select curState
  case STATE_VSP_GET_HANDLES
    SvcFindCharDescEv(hConn,hAttr)

  case STATE_nonVSP_CONNECTED
    //get connection index from conn handle
    dontcare = GetIdxFromHConn(hConn)
    sprint #dontcare$, "\nFD:";dontcare;",";hAttr;"\r"
    SendUartDataEx(dontcare$)

  case else
  endselect
endfunc 1

//------------------------------------------------------------------------------
//Characteristic found via BleGattcFindChar()
//------------------------------------------------------------------------------
function HndlrFindChar(hConn,cProp,hAttr,hIncSvcUuid)
  //#cmpif 0x00000004 : DbgMsgVal("EvFindChar hAttr=",hAttr)

  select curState
  case STATE_VSP_GET_HANDLES
    SvcFindCharDescEv(hConn,hAttr)

  case STATE_nonVSP_CONNECTED
    //get connection index from conn handle
    dontcare = GetIdxFromHConn(hConn)
    sprint #dontcare$, "\nFC:";dontcare;",";hAttr;",";cProp;"\r"
    SendUartDataEx(dontcare$)

  case else
  endselect
endfunc 1

//------------------------------------------------------------------------------
//UART data received in vsp fast connected state (as master)
//------------------------------------------------------------------------------
function HndlrUartRxVspOutFC()
  //Read data that has arrived through via the UART
  if (vspAllowTx == 1) then
    do
      dontcare = UartReadN(UARTRecBuf$, vspAttrMaxLen)
      if dontcare > 0 then
        rc = BleGattcWriteCmd(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_RX], UARTRecBuf$)

        select rc

        //0000 = UWRESULTCODE_SUCCESS
        case 0
          StrShiftLeft(UARTRecBuf$,dontcare)
          #cmpif 0x00000040 : vtxcnt=vtxcnt+dontcare

        //6804 = UWRESULTCODE_BLE_NO_TX_BUFFERS
        //6213 = UWRESULTCODE_BLE_RESOURCES - too many writes without responses queued
        //          Wait for a BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event and retry which is EVNOTIFYBUF in sb
        case 0x6804,0x6213
          TimerStart(TMRNUM_DATA_PUMP,vspPumpToutMs,0)
          exitfunc 1

        //620C = UWRESULTCODE_BLE_DATA_SIZE
        case 0x620C
          dontcare$= StrSplitLeft$(UARTRecBuf$,vspAttrMaxLen)
          rc = BleGattcWriteCmd(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_RX], dontcare$)
          if rc!=0 then
            //did not manage to sent it, so put it back in the original buffer (at the beginning)
            UARTRecBuf$ = dontcare$+UARTRecBuf$
            if (rc==0x6804)||(rc==0x6213) then //BLE_NO_TX_BUFFERS or BLE_RESOURCES
              TimerStart(TMRNUM_DATA_PUMP,vspPumpToutMs,0)
              exitfunc 1
            endif
            #cmpif 0x00000040 : else
            #cmpif 0x00000040 :   vtxcnt=vtxcnt+dontcare
          endif

        //Some other error, so just exit
        case else
          exitfunc 1

        endselect
      endif
    dowhile dontcare
  endif
endfunc 1

//------------------------------------------------------------------------------
//UART data received in vsp slow connected state (as master)
//------------------------------------------------------------------------------
function HndlrUartRxVspOutSC()
  //check number of bytes in receive buffer
  dontcare=UartInfo(3)
  if dontcare==1 then
    PollForEscapeSeq()  //on exit dontcare$ contains what was read
    UARTRecBuf$ = UARTRecBuf$+dontcare$
  endif
endfunc HndlrUartRxVspOutFC()

//------------------------------------------------------------------------------
//This timer was started when notify buffers ran out while calling WriteCmd
//------------------------------------------------------------------------------
function HndlrTmrVspPump()
  select curState
  case STATE_VSP_CARET_CONNECTED, STATE_VSP_FAST_CONNECTED
    rc = HndlrUartRxVspOutFC()

  case else
  endselect
endfunc 1

//------------------------------------------------------------------------------
//A write to an attribute has been acked/nacked
//------------------------------------------------------------------------------
function HandlerAttrWrite(hConn,hAttr,xSts)
  //#cmpif 0x00000004 : print "\n## EvAttrWrite hAttr=";hAttr;" sts=";xSts

  select curState
  case STATE_VSP_WRITE_CCCDS
    //save status for later use
    vspDisconSts=nSts
    //check status
    if xSts==0 then
      //#cmpif 0x00000004 : DbgMsg("EvAttrWrite OK")
      //a cccd was successfuly written, so check for next
      vspFindIndex=vspFindIndex+1
      if vspFindIndex>=VSP_ATTR_MAX_INDEXES then
        //all cccd's written
        vspIsOutGoing=TRUE
        VspEnterConnState(MSGAPP_ENTER_VSPOUT_CONN_STATE)
      else
        //there could be more cccd's to enable
        rc=CccdsEnable()
        if rc==0 then
          //there were no more cccd's to enable
          vspIsOutGoing=TRUE
          VspEnterConnState(MSGAPP_ENTER_VSPOUT_CONN_STATE)
        else
          //a write has been sent to a cccd, remain in this state
          //NOTHING TO DO
        endif
      endif
    elseif (Is_Encr_Required(xSts) != 0) && (pairIoCapCache==0) then
      #cmpif 0x00000004 : DbgMsg("EvAttrWrite Encr Req ** Start PAIRING")
      //the link requires encryption, and configured for just works
      rc = BlePair(hConn,1)
      #cmpif 0x00000003 : AssertRC(40710)
      //change state
      NewState(STATE_VSP_PAIRING)
    else
      #cmpif 0x00000004 : DbgMsgVal("EvAttrWrite other err",xSts)
      //some other error, so just drop the connection
      vspDisconSts=CONN_ERROR_AUTHLINK_REQUIRED
      rc=BleDisconnect(hConn)
      //change state
      NewState(STATE_VSP_DISCONNECTING)
    endif

  case STATE_VSP_FAST_CONNECTED,STATE_VSP_CARET_CONNECTED
    //and immeditaly send more data if we can
    rc = HndlrUartRxVspOutFC()

  case STATE_nonVSP_CONNECTED
    dim nIdx
    //get connection index from conn handle
    nIdx = GetIdxFromHConn(hConn)
    sprint #dontcare$, "\nAW:";nIdx;",";xSts;"\r"
    SendUartDataEx(dontcare$)

  case else
  endselect
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function HndlrAttrRead(hConn,hAttr,xSts) as integer
  dim a$,ofst,nIdx
  //get connection index from conn handle
  nIdx = GetIdxFromHConn(hConn)
  if xSts == 0 then
    //we have a successful read
    rc = BleGattcReadData(hConn,hAttr,ofst,a$)
    if rc==0 then
      sprint #dontcare$, "\nAR:";nIdx;",";ofst;",";StrHexize$(a$);"\r"
    else
      sprint #dontcare$, "\nAB:";nIdx;",";integer.h' rc;"\r"
    endif
  else
    //failed to read
    sprint #dontcare$, "\nAS:";nIdx;",";xSts;"\r"
  endif
  SendUartDataEx(dontcare$)
endfunc 1

//------------------------------------------------------------------------------
// Called wheh uart tx buffer is empty in vsp fast mode
//------------------------------------------------------------------------------
function HndlrUartTxEmptyOut()
  VspMasterRtsSend(1)
  SendUartData()
endfunc 1

//------------------------------------------------------------------------------
//Vsp (air-side) data received in vsp fast connected state
//------------------------------------------------------------------------------
function HndlrNotifyVspOut()
  dim hConn, hAttr, aData$, discard, wrLen
  rc=BleGattcNotifyRead(hConn, hAttr, aData$, discard)
  while (rc == 0)
    if (hAttr == hVspAttr[VSP_ATTR_INDEX_TX]) then
      //Data has arrived
      SendUartDataEx(aData$)
      if strlen(UARTSndBuf$) > 0 then
        VspMasterRtsSend(0)
      endif
    elseif (hAttr == hVspAttr[VSP_ATTR_INDEX_MDMOUT]) then
      //Modem Out from peer changed
      if (strcmp(aData$, "\01") == 0) then
        #cmpif 0x00000040 : print "\n+MDM+ ";vtxcnt
        vspAllowTx = 1
        rc = HndlrUartRxVspOutFC()
      else
        #cmpif 0x00000040 : print "\n-MDM- ";vtxcnt
        vspAllowTx = 0
      endif
    endif
    rc=BleGattcNotifyRead(hConn, hAttr, aData$, discard)
  endwhile
endfunc 1

//------------------------------------------------------------------------------
//NonVsp connection received a notify
//------------------------------------------------------------------------------
function HndlrNotifyNonVsp()
  dim hConn, hAttr, aData$, discard, wrLen, nIdx
  do
    rc=BleGattcNotifyRead(hConn, hAttr, aData$, discard)
    if rc!=0 then
      exitfunc 1
    endif
    nIdx = GetIdxFromHConn(hConn)
    if nIdx>0 then
      sprint #dontcare$,"\nIN:";nIdx;",";hAttr;",";StrHexize$(aData$);"\r"
      SendUartDataEx(dontcare$)
    endif
  dowhile(1)
endfunc 1

//------------------------------------------------------------------------------
// Waited too long for Vsp connection to be encrypted do just drop the connection
//------------------------------------------------------------------------------
function HndlrTmrWaitEncr()
  if curState==STATE_VSP_IN_WAIT_ENCR then
    vspDisconSts=CONN_ERROR_UNENCRYPTED
    //some other error, so just drop the connection
    rc=BleDisconnect(connHandles[HCONN_VSP])
    //change state
    NewState(STATE_VSP_DISCONNECTING)
  endif
endfunc 1

//------------------------------------------------------------------------------
// Function called when there is a VSP overrun
//------------------------------------------------------------------------------
function HndlrVspRxOverrun()
  #cmpif 0x00000080 :   print "\n## VspRx Overrun, uarttx space=";uartinfo(4);"\n"
endfunc 1

//------------------------------------------------------------------------------
// Function for bridging data between the VSP service and the UART in FAST mode
//------------------------------------------------------------------------------
function HndlrBridgeInF()
    //Pass data between UART and VSP service
    BleVspUartBridge()
endfunc 1

//------------------------------------------------------------------------------
// Function for bridging data between the VSP service and the UART in SLOW mode
//------------------------------------------------------------------------------
function HndlrBridgeInS()
  //Pass data between UART and VSP service
  dim uLen

  #cmpif 0x00400000 : //if there is data in the VSP rx buffer then it will get transferred to
  #cmpif 0x00400000 : //the uart so we need to reopen uart just in case
  #cmpif 0x00400000 : if BleVspInfo(3) then
  #cmpif 0x00400000 :   UartReOpen()
  #cmpif 0x00400000 : endif

  //check space in vsp tx buffer
  if BleVspInfo(4) >= MIN_SPACE_IN_VSPTXBUF_TO_CHECK_FOR_CARETS then
    //check number of bytes in receive buffer
    uLen=UartInfo(3)
    if uLen==1 then
      PollForEscapeSeq()  //on exit dontcare$ contains what was read from uart
      rc=BleVspWrite(dontcare$)
    endif
  endif
  BleVspUartBridge()
endfunc 1

//------------------------------------------------------------------------------
// This will be called with the cmd mode pin transitions from 0 to 1
//------------------------------------------------------------------------------
function HndlrVspCmdMode()
  select curState
  case STATE_VSP_FAST_CONNECTED
    //disconnect
    vspDisconSts=CONN_ERROR_USER_DISCON
    //some other error, so just drop the connection
    rc=BleDisconnect(connHandles[HCONN_VSP])
    //change state
    NewState(STATE_VSP_DISCONNECTING)

  case else
  endselect
endfunc 1

//------------------------------------------------------------------------------
// This will be called with the cmd mode pin transitions from 0 to 1 which is
// repurposed in low power mode to reopen the uart
//------------------------------------------------------------------------------
#cmpif    0x00400000 : function HndlrReopenUart()
#cmpif    0x00400000 :   UartReOpen()
#cmpifand 0x00400104 :   DbgMsg("Uart reopened")
#cmpif    0x00400000 : endfunc 1

//------------------------------------------------------------------------------
//BLE message
//------------------------------------------------------------------------------
function HndlrBleMsg(nMsgId, nCtx)
  select nMsgId
  case BLE_EVBLEMSGID_CONNECT
    OnConnect(nCtx)

  case BLE_EVBLEMSGID_ENCRYPTED
    OnEncrypted(nCtx)

  case BLE_EVBLEMSGID_UNENCRYPTED
    OnUnencrypted(nCtx)

  case BLE_EVBLEMSGID_DISCONNECT
    //Disconnected see HndlrDisCon

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_NEW_BOND
  #cmpif 0x00000004 :   DbgMsg("New Bond")

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_UPDATED_BOND
  #cmpif 0x00000004 :   DbgMsg("Updated Bond")

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_LESC_PAIRING
  #cmpif 0x00000004 :   DbgMsg("LESC Pairing")

  case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    OnDisplayPasskey(nCtx)

  case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    #cmpif 0x00000004 :   DbgMsgVal("Auth Key Request, type=",nCtx)
    OnAuthKeyRequest(nCtx)

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
  #cmpif 0x00000004 :   DbgMsg("Conn to Bonded Master ")

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
  #cmpif 0x00000004 :   ShowConnParms(nCtx)

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
  #cmpif 0x00000004 :   DbgMsg("Conn Parm Negotiation FAILED")

  case else
    #cmpif 0x00000004 : DbgMsgVal("Unprocessed nMsgId",nMsgId)
  endselect
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x00020000 : function HandlerPrimSvc(hConn,hUuid,hStart,hEnd) as integer
#cmpif 0x00020000 :   if hStart!=0 then
#cmpif 0x00020000 :     //S: hStart,(hEnd),hUuid
#cmpif 0x00020000 :     sprint #dontcare$, "\nTM:S:";hStart;" ,(";hEnd;") ,";integer.h' hUuid;"\r"
#cmpif 0x00020000 :     SendUartDataEx(dontcare$)
#cmpif 0x00020000 :     if hStart == hEnd then
#cmpif 0x00020000 :       //the service is empty so move on to next service
#cmpif 0x00020000 :       rc=BleDiscServiceFirst(hConn,(hEnd+1),0)
#cmpif 0x00020000 :       if rc!=0 then
#cmpif 0x00020000 :         TerminateTableMap(rc)
#cmpif 0x00020000 :       endif
#cmpif 0x00020000 :     else
#cmpif 0x00020000 :       //And get all characteristics of this service
#cmpif 0x00020000 :       rc=BleDiscCharFirst(hConn,0,hStart,hEnd)
#cmpif 0x00020000 :       if rc!=0 then
#cmpif 0x00020000 :         TerminateTableMap(rc)
#cmpif 0x00020000 :       endif
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :   else
#cmpif 0x00020000 :     //Reached end of remote gatt table
#cmpif 0x00020000 :     TerminateTableMap(0)
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 : endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x00020000 : function HandlerCharDisc(hConn,hUuid,cProp,hVal,hiUuid) as integer
#cmpif 0x00020000 :   if hVal!=0 then
#cmpif 0x00020000 :     //C: hVal,cProp,hUuid,hiUuid
#cmpif 0x00020000 :     sprint #dontcare$,"\nTM: C:";hVal;" ,";integer.h' cProp;" ,";integer.h' hUuid;" ,";hiUuid;"\r"     //use SendUartData instead
#cmpif 0x00020000 :     SendUartDataEx(dontcare$)
#cmpif 0x00020000 :     //And get all descriptors of this characteristics
#cmpif 0x00020000 :     rc=BleDiscDescFirst(hConn,0,hVal)
#cmpif 0x00020000 :     if rc!=0 then
#cmpif 0x00020000 :       TerminateTableMap(rc)
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :   else
#cmpif 0x00020000 :     //No more chars in this service, so go for next service
#cmpif 0x00020000 :     rc = BleDiscServiceNext(hConn)
#cmpif 0x00020000 :     if rc!=0 then
#cmpif 0x00020000 :       TerminateTableMap(rc)
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 : endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x00020000 : function HandlerDescDisc(hConn,hUuid,hDesc) as integer
#cmpif 0x00020000 :   if hDesc!=0 then
#cmpif 0x00020000 :     //D: hDesc,hUuid
#cmpif 0x00020000 :     sprint #dontcare$,"\nTM:  D:";hDesc;" ,";integer.h' hUuid;"\r"     //use SendUartData instead
#cmpif 0x00020000 :     SendUartDataEx(dontcare$)
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 :   //And get all descriptors of this characteristics
#cmpif 0x00020000 :   rc=BleDiscDescNext(hConn)
#cmpif 0x00020000 :   if rc!=0 then
#cmpif 0x00020000 :     //No more descc in this char, so go for next char
#cmpif 0x00020000 :     rc = BleDiscCharNext(hConn)
#cmpif 0x00020000 :     if rc!=0 then
#cmpif 0x00020000 :       rc = BleDiscServiceNext(hConn)
#cmpif 0x00020000 :       if rc!=0 then
#cmpif 0x00020000 :         TerminateTableMap(rc)
#cmpif 0x00020000 :       endif
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 : endfunc 1

//------------------------------------------------------------------------------
// This handler is called when there when an Indicate is acknowledged
//------------------------------------------------------------------------------
function HndlrCharHvc(BYVAL hChar AS INTEGER) as integer
  charIdx=GetIdxFromHChar(hChar)
  if charIdx>0 then
    sprint #dontcare$,"\nAK:";charIdx;"\r"
    SendUartDataEx(dontcare$)
  endif
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function HndlrCharVal(BYVAL hChar AS INTEGER, byval offset, byval len) as integer
  charIdx=GetIdxFromHChar(hChar)
  if charIdx>0 then
    rc=BleCharValueRead(hChar,tmpDta$)
    sprint #dontcare$,"\nWR:";charIdx;",";StrHexize$(tmpDta$);"\r"
    SendUartDataEx(dontcare$)
  endif
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function HndlrCharCccd(BYVAL hChar AS INTEGER, BYVAL nVal AS INTEGER) as integer
  charIdx=GetIdxFromHChar(hChar)
  if charIdx>0 then
    sprint #dontcare$,"\nCC:";charIdx;",";nVal;"\r"
    SendUartDataEx(dontcare$)
  endif
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function HndlrCharSccd(BYVAL hChar AS INTEGER, BYVAL nVal AS INTEGER) as integer
  charIdx=GetIdxFromHChar(hChar)
  if charIdx>0 then
    sprint #dontcare$,"\nSC:";charIdx;",";nVal;"\r"
    SendUartDataEx(dontcare$)
  endif
endfunc 1

//------------------------------------------------------------------------------
// This handler is called process an event thrown by this application used
// for serialisation
//------------------------------------------------------------------------------
function HndlrMessageApp(nMsgId, nCtx)
  select nMsgId
  case MSGAPP_PROCESS_UART
    //process the uart as if we just got some uart activity
    OnEvent EVUARTRX              Call HndlrUartCommand
    rc=HndlrUartCommand()

  case MSGAPP_ENTER_NONVSP_CONN_STATE
    OnEvent EVATTRNOTIFY          Call HndlrNotifyNonVsp
    //also trigger a reprocessing of the uart buffer just in case
    rc=SendMsgApp(MSGAPP_PROCESS_UART, DONTCARE_CTX)

  case MSGAPP_ENTER_VSPOUT_CONN_STATE  //nCtx is the new state to enter
    #cmpif 0x00000004 :   DbgMsg("Going For VSPOUT")
    //Allow TX
    vspAllowTx=1
    //Assert DCD
    VspDcdAssert()
    //send the connect response
    AppendConnRspEnd(CONN_OK, UARTSndBuf$ )
    //Send out data waiting in buffer
    SendUartData()
    //change uart and vsp handlers
    if nCtx==STATE_VSP_FAST_CONNECTED then
      #cmpif 0x00000004 :   DbgMsg("HndlrUartRxVspOutFC")
      OnEvent EVUARTRX            Call HndlrUartRxVspOutFC
      OnEvent EVNOTIFYBUF         Call HndlrUartRxVspOutFC
    else
      #cmpif 0x00000004 :   DbgMsg("HndlrUartRxVspOutSC")
      OnEvent EVUARTRX            Call HndlrUartRxVspOutSC
      OnEvent EVNOTIFYBUF         Call HndlrUartRxVspOutFC  //not HndlrUartRxVspOutSC because escape seq cannot be sent by peer
    endif
    OnEvent EVATTRNOTIFY          Call HndlrNotifyVspOut
    OnEvent EVUARTTXEMPTY         Call HndlrUartTxEmptyOut
    //enable incoming data from peer
    VspMasterRtsSend(1)
    //change state
    NewState(nCtx)

  case MSGAPP_ENTER_VSPIN_CONN_STATE  //nCtx is the new state to enter
    #cmpif 0x00000004 :   DbgMsg("Going For VSPIN")
    //Assert DCD
    VspDcdAssert()
    //send the connect response
    AppendConnRspEnd(CONN_OK, UARTSndBuf$ )
    //Send out data waiting in buffer
    SendUartData()
    //change uart and vsp handlers
    #cmpif 0x00080000 : OnEvent EVVSPRXOVRN           Call HndlrVspRxOverrun
    if nCtx==STATE_VSP_FAST_CONNECTED then
      #cmpif 0x00000004 :   DbgMsg("HndlrUartRxVspInFC")
      OnEvent EVVSPRX             Call HndlrBridgeInF
      OnEvent EVUARTRX            Call HndlrBridgeInF
      OnEvent EVVSPTXEMPTY        Call HndlrBridgeInF
      OnEvent EVUARTTXEMPTY       Call HndlrBridgeInF
      //start bridging cached data
      rc=HndlrBridgeInF()
    else
      #cmpif 0x00000004 :   DbgMsg("HndlrUartRxVspInSC")
      OnEvent EVVSPRX             Call HndlrBridgeInS
      OnEvent EVUARTRX            Call HndlrBridgeInS
      OnEvent EVVSPTXEMPTY        Call HndlrBridgeInS
      OnEvent EVUARTTXEMPTY       Call HndlrBridgeInS
      //start bridging cached data
      rc=HndlrBridgeInS()
    endif
    //change state
    NewState(nCtx)

  case else
    //do nothing
  endselect
endfunc 1

//==============================================================================
// This handler is called when the packet length is changed
//==============================================================================
function HandlerPacketLength(BYVAL hConn, BYVAL Tx_Octets, BYVAL Tx_Time, BYVAL Rx_Octets, BYVAL Rx_Time)
  #cmpif 0x00000010 :  print "\n## Pkt-Len_Chg: Tx(Len=";Tx_Octets;" Time=";Tx_Time;"us) Rx(Len=";Rx_Octets;" Time=";Rx_Time;"us)"
  //not vspChunkLen is == Tx_Octets-7

  //If this is a VSP connection then update the PHY if not 1MPHY
  if hConn==connHandles[HCONN_VSP] then
    if vspIsOutGoing != FALSE then
      rc = ChangePhy( hConn )
      #cmpif 0x00000001 :  print "\n## ChangePhy() ret:";integer.h' rc
    endif
  endif

endfunc 1

//==============================================================================
// This handler is called when there is an event that the attribute MTU has changed
//==============================================================================
function HandlerAttrMTU(BYVAL hCOnn AS INTEGER, BYVAL nSize AS INTEGER)
  #cmpif 0x00000010 :  print "\n## Attribute MTU Changed to Size:";nSize
  vspChunkLen = nSize-3
endfunc 1

//==============================================================================
// This handler is called when remote is requesting a switch to a different PHY
//==============================================================================
function  HandlerPhyRequest(BYVAL hConn, BYVAL PhyTx, BYVAL PhyRx)
#cmpif 0x00000010 :    print "\n## BLE PHY REQUEST: (PhyTx=";PhyTx;" PhyRx =";PhyRx;")"
endfunc 1

//==============================================================================
// This handler is called when the BLE PHY is updated
//==============================================================================
function  HandlerPhyUpdated(BYVAL hConn, BYVAL nStatus, BYVAL PhyTx, BYVAL PhyRx)
#cmpif 0x00000010 :     if nStatus==0 then
#cmpif 0x00000010 :       print "\n## BLE PHY UPDATED: (PhyTx=";PhyTx;" PhyRx=";PhyRx;")"
#cmpif 0x00000010 :     else
#cmpif 0x00000010 :       print "\n## BLE PHY UPDATE FAIL: ";integer.h' nStatus
#cmpif 0x00000010 :     endif
endfunc 1

//==============================================================================
// On ERROR handler
//==============================================================================
sub HandlerOnErr()
#cmpif 0x00400000 :   UartReOpen()
#cmpif 0x00000001 :     print "\nOnErr - ";GetLastError();"\n"
#cmpif 0x00000001 :     //Wait for tx buffer to flush
#cmpif 0x00000001 :     while UartInfo(5)>0
#cmpif 0x00000001 :     endwhile
#cmpif 0x00040000 :   reset(0)
endsub

//==============================================================================
// This handler is called when there is an NFC event
//==============================================================================
#cmpif 0x00020000 : function HandlerNfc(msgid) as integer
#cmpif 0x00020000 : // Send an asynchronous response only in certain states and certainly
#cmpif 0x00020000 : // not when in a VSP connection.
#cmpif 0x00020000 :   select curState
#cmpif 0x00020000 :   case STATE_IDLE_nonVSP,STATE_IDLE_VSP,STATE_SCAN_VSP,STATE_nonVSP_CONNECTED
#cmpif 0x00020000 :     select(msgid)
#cmpif 0x00020000 :     case NFC_MSGIN_NFCFIELDOFF
#cmpif 0x00020000 :       dontcare$="\nNS:0\r"
#cmpif 0x00200000 :       nfcSenseCnt = nfcSenseCnt+1
#cmpif 0x00020000 :
#cmpif 0x00020000 :     case NFC_MSGIN_NFCFIELDON
#cmpif 0x00020000 :       dontcare$="\nNS:1\r"
#cmpif 0x00200000 :       nfcSenseCnt = nfcSenseCnt+1
#cmpif 0x00020000 :
#cmpif 0x00020000 :     case NFC_MSGIN_NFCTAGREAD
#cmpif 0x00020000 :       dontcare$="\nNR\r"
#cmpif 0x00200000 :       nfcReadCnt = nfcReadCnt+1
#cmpif 0x00020000 :
#cmpif 0x00020000 :     case else
#cmpif 0x00020000 :       exitfunc 1
#cmpif 0x00020000 :     endselect
#cmpif 0x00020000 :     SendUartDataEx(dontcare$)
#cmpif 0x00020000 :   case else
#cmpif 0x00020000 :   endselect
#cmpif 0x00020000 : endfunc 1

//------------------------------------------------------------------------------
// The uart low power operation timer has expired
//------------------------------------------------------------------------------
#cmpif 0x00400000 : function HndlrTmrLowPwrUart()
#cmpifand 0x00400104 :   DbgMsg("Uart Tmr EXPIRE")
#cmpif 0x00400000 :   //If in the meantime the timer was restarted do nothing
#cmpif 0x00400000 :   if TimerRunning(TMRNUM_LOWPWR_UART) == 0 then
#cmpif 0x00400000 :     //the buffers have to empty and transmit register should be empty too
#cmpif 0x00400000 :     UartCloseConditional()
#cmpif 0x00400000 :   endif
#cmpif 0x00400000 : endfunc 1


//==============================================================================
// Use Button1 for debugging
//==============================================================================
#cmpif 0x00000200 : function HandlerButton1() as integer
#cmpif 0x00000200 :   print "\n## B1:"
#cmpif 0x00000200 :   //The following empty line is just to make it easier to add new debugging lines
#cmpif 0x00000200 :
#cmpif 0x00000200 :
#cmpif 0x00000200 :
#cmpif 0x00000200 :
#cmpif 0x00000200 :
#cmpif 0x00000200 : endfunc 1

//==============================================================================
// Use Button2 for debugging
//==============================================================================
#cmpif 0x00000200 : function HandlerButton2() as integer
#cmpif 0x00000200 :   print "\n## B2:";curState;",";UARTRecBuf$
#cmpif 0x00000200 :
#cmpif 0x00000200 :   //print "\n=BTN= ";vtxcnt
#cmpif 0x00000200 :   //vtxcnt=0
#cmpif 0x00000200 :   //vrxcnt=0
#cmpif 0x00000200 :
#cmpif 0x00000200 : endfunc 1

//******************************************************************************
//Setup event handlers
//******************************************************************************
OnError NEXT                    HandlerOnErr

OnEvent EVBLEMSG                Call HndlrBleMsg
OnEvent EVUARTRX                Call HndlrUartCommand
OnEvent EVBLE_SCAN_TIMEOUT      Call HndlrScanTimeout
OnEvent EVBLE_ADV_REPORT        Call HndlrAdvReport
OnEvent EVMSGAPP                Call HndlrMessageApp
OnEvent EVBLE_CONN_TIMEOUT      Call HndlrConnTout
OnEvent EVDISCON                call HndlrDisCon
OnEvent EVFINDDESC              call HndlrFindDesc
OnEvent EVFINDCHAR              call HndlrFindChar
OnEvent EVATTRWRITE             call HandlerAttrWrite
OnEvent EVATTRREAD              call HndlrAttrRead
OnEvent EVTMR0                  call HndlrTmrWaitEncr
OnEvent EVDETECTCHAN0           call HndlrVspCmdMode
OnEvent EVCHARHVC               call HndlrCharHvc
OnEvent EVCHARVAL               call HndlrCharVal
OnEvent EVCHARCCCD              call HndlrCharCccd
OnEvent EVCHARSCCD              call HndlrCharSccd
//OnEvent EVCHARDESC              call HndlrCharDesc   //FUTURE

OnEvent EVTMR1                  call HndlrTmrVspPump

#cmpif 0x00020000 : OnEvent EVDISCPRIMSVC           call HandlerPrimSvc
#cmpif 0x00020000 : OnEvent EVDISCCHAR              call HandlerCharDisc
#cmpif 0x00020000 : OnEvent EVDISCDESC              call HandlerDescDisc

OnEvent EVPACKETLENGTH          call HandlerPacketLength
OnEvent EVATTRIBUTEMTU          call HandlerAttrMTU
OnEvent EVBLE_PHY_REQUEST       call HandlerPhyRequest
OnEvent EVBLE_PHY_UPDATED       call HandlerPhyUpdated

#cmpif 0x00200000 : OnEvent EVNFC                   call HandlerNfc

//Override gpio detect change handler if uart low operation is enabled
#cmpif 0x00400000 : OnEvent EVDETECTCHAN0           call HndlrReopenUart
#cmpif 0x00400000 : OnEvent EVTMR2                  call HndlrTmrLowPwrUart

#cmpif 0x00000200 : OnEvent EVGPIOCHAN0           call HandlerButton2
#cmpif 0x00000200 : OnEvent EVGPIOCHAN1           call HandlerButton1

//******************************************************************************
// Start up code from here -equivalent to main() in a 'C' application
//******************************************************************************

Startup()


//******************************************************************************
//Wait in a lower-power mode for an event to occur
//******************************************************************************
WAITEVENT
