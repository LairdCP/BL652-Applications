// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Copyright (c) 2018-2022, Laird Connectivity                                ++
//                                                                            ++
// Permission to use, copy, modify, and/or distribute this software for any   ++
// purpose with or without fee is hereby granted, provided that the above     ++
// copyright notice and this permission notice appear in all copies.          ++
//                                                                            ++
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES   ++
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF           ++
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR    ++
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES     ++
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN      ++
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR ++
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.                ++
//                                                                            ++
// SPDX-License-Identifier:ISC                                                ++
//                                                                            ++
// ************************************************************************** ++
// A smartBASIC library that exposes an AT Interface to control a VSP         ++
// or non-VSP connection and advertise or scan that will run on a Laird       ++
// Connectivity module with the following compile time optional features:-    ++
//    + AT+GCTM command enabled to query peer's GATT table schema             ++
//    + If the error handler is called then module will reset and restart     ++
//    + VSP Overrun Event is enabled when there is a VSP incoming overrun     ++
//    + long-range Connection capability enabled                              ++
//    + NFC related commands enabled                                          ++
//    + Low Power UART operation - port closed when there is no activity      ++
// ************************************************************************** ++
//                                                                            ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminalX downloads the app to the module it will be saved   ++
// +++++  as a file with filename $autorun$ which means it will run           ++
// +++++  automatically on reset.                                             ++
// +++++  The File System can be queried using the command AT+DIR             ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// -------------------
// ATinterface Library Version
// -------------------
#define LibVer                 "5.04"  //Library version  (ATI23)
//
//******************************************************************************
// Compiler/Debug options
//******************************************************************************
//   ======================================================
//   Conditional Compile Masks (they can be additive)
//   ------------------------------------------------------
//
// Higher 16 bits used for feature set
//   0x80000000 : PALNA supported
//
// Lower 16 bits used for debugging (Collectively == DebugMessages)
//   0x00000001 : Enable debugging messages
//   0x00000002 : Enable Asserts printed out of UART
//   0x00000004 : Enable DbgXXX messages
//   0x00000008 : Enable Conn Parameters display
//   0x00000010 : Enable PHY Change debugging (+PHYchng)
//   0x00000040 : Enable VSP MDM change activity for debugging (+MDMCHNG)
//   0x00000080 : Enable VSPRXOVRN debug print
//   0x00000100 : Enable low power UART debugging
//   0x00000200 : Enable BUTTON1 & BUTTON2 related debugging
//   0x00000400 : Enable printing of all adverts for debugging
//   0x00004000 : Enable S Register interface debugging
//   0x00008000 : Enable arg parsing prints
//
// Upper 16 bits for features (Collectively == AllFeatures)
//   0x00010000 : Include Verbose Code for setting defaults (VerboseDefRegisterCreation)
//   0x00020000 : Enable TableMap command AT+GCTM
//   0x00040000 : On ERROR call reset
//   0x00080000 : Enable the EVVSPRXOVRN event handler  +VSPOVRN
//   0x00100000 : Enable long-range Capability  +LRANGE
//   0x00200000 : Enable NFC  +NFC
//   0x00400000 : Enable LowPower UART Operation  +LOWPWR
//   0x00800000 : Disable auto accept of 2MPHY request
//   ======================================================
// -------------------
// Application History
// -------------------
//
//  5.04
//    * Fixed connection to extended adverts on 1MPhy
//
//  5.03
//    * Fixed missing connect message on incoming connection as peripheral
//      when already connected as central
//
//  5.02
//    * Implemented GPIO indication for active and encrypted connections
//      according to S registers 138/139 and polarity by S register 137
//
//  5.01
//    * Added AT+BNDL command to show stats of trusted rolling/persistent
//      database plus list of devices in both databases
//
//  5.00
//    * Removed VSP data pump timer as it served no purpose
//    * Switched from write without response to write with response for modem
//      characteristic writes
//    * Increased BL654 default DLE attribute size to 160 bytes to increase
//      throughput
//    * Fixed issues with switching between client and server VSP modes whereby
//      link would be unusable or firmware would enter an infinite loop
//    * Fixed issues with writing VSP data that would sit in an inifite loop if
//      the other side had a smaller MTU
//    * Fixed issues with trying to write 0 byte of data to remote devices
//    * Fixed issue with AT&F not erasing bonds
//
//  4.10
//    * Fixed issue with AT+LSCN0 and AT+LSCNX keeping the module advertising a
//      VSP service but being in non-VSP idle mode
//
//  4.09
//    * Fixed issue with advertising interval and type overwriting cached values
//      upon advertising when a SReg update and reboot should be required
//
//  4.08
//    * Fixed issue with array limits not being validated
//    * Fixed issue with characteristic array limit being wrongly checked
//      against the connection count
//
//  4.07
//    * Add support for setting LESC with MITM protection for characteristic
//      permissions
//
//  4.06
//    * Fixed issue with different output formats, all outputs are now in
//      "A, B, C" formatting
//
//  4.05
//    * Fixed issue with MT: output missing a comma between parameters
//
//  4.04
//    * Fixed issue with at+ladv not using correct interval parameter
//
//  4.03
//    * Fixed issue with at+csec not returning the correct data
//
//  4.02
//    * Fixed issue with VSP modem changes not being sent when transmission
//      buffers are full
//
//  4.01
//    * Fixed issue with upper case characters not being made lower case
//      properly
//
//  4.00
//    * Fixed issue with receive buffer becoming full without a newline
//      character and preventing module operating
//    * Updates with new smartBASIC events and messages from (BL654) firmware
//      29.5.7.2
//    * Change output of some functions to include connection handles
//    * Replace connection set aside limit configuration with event length
//      configuration
//    * Added SReg 127 : CfgId_TransmissionBuffers
//    * Reformatted files
//
//  3.12
//    * Fixed max TX power so BL654PA can be used at +18dBm
//
//  3.11
//    * Fixed static passkey not being set properly
//
//  3.10
//    * Added correction for number of parameters for AT+EADV command
//    * Added support for static passkey handling 
//
//  3.02
//    * Added LESC OOB pairing capability
//
//  3.00
//    * Added extended advert commands and long-range connection capability
//
//  2.40
//    * Added more configuration options to assist with throughput on VSP
//      connections
//     - Added SReg 118 : CfgId_VspMaxCachedRxPkts
//     - Added SReg 219 : CfgId_DleAttributeSize
//     - Update SReg related regression tests
//     - Added SReg 125 : CfgId_MaxConnsAsSlave
//     - Added SReg 126 : CfgId_MaxConnsAsMaster
//     - Added SReg 307 : CfgId_SetAsideTimeForPktsInConn
//
//  2.33
//    * Prevent change to 2MPHY if SReg100 bits 5&6 are not 11  -- this works now
//      and tested with iPhoneX
//
//  2.32
//    * Prevent change to 2MPHY if SReg100 bits 5&6 are not 11
//
//  2.30
//    * Added AT+LMTU and AT+LPHY commands for changing MTU and PHY respectively
//      in non-VSP mode. For +LMTU, async response MT: has been added and for
//      +LPHY, the async response PU or PF messages have been added.
//
//  2.20
//    * Max device name is now 20 instead of 12 which is accessed via AT%S0
//
//  2.10
//    * Max limit for SReg 109 is 31 for 652 and 47 for 654
//    * Added SReg117 to add DCD output for VSP operation (Low for connection)
//
//  2.00
//    * Added low power UART operation
//    * Added NFC AT commands for Type 2 functionality
//    * Converted filename to $LIB$.AT.interface.sb so that we can include in
//        $autorun$.AT.interface.BL652._.sb  and $autorun$.AT.interface.BL654._.sb
//    * AssertRC changed so that it does not take rc argument to reduce code size
//    * Cater for BLE_RESOURCES return code from BLGATTCWRITECMD() function
//    * SReg100 now allows DLE and PHY specification
//        Data Length Extension to increase throughput
//
//  1.50
//    New firmware returns a different resultcode when there are no more writecmd buffers
//    so routine HndlrUartRxVspOutFC() updated so that it looks for it.
//    Also the 'case else' in that same select exits the function
//
//  1.40
//    Merged 1.10 and 1.30 changes into one file
//
//  1.30
//    When getting tablemap with the GCTM command, it copes if a service is empty
//
//  1.10
//    Allow scanning in STATE_nonVSP_CONNECTED state - but only if timeout
//    value is nonzero
//
//  1.00 "22/June/2017"
//    BL652 First public deployment via the BL652 apps repository in github
//
//  0.20 "1/June/2017"
//    Throughput 127kbps bi-directional (total 254kbps) without data length
//    extension, SRreg100 enhanced with extra bit to allow 6 packets per
//    connection interval. By default, that bit is set to give 6 pkts
//
//  0.10 "24/May/2017"
//    Initial Release. @7.5ms conn interval
//       Throughput : 10.5kbps  Client->Server
//                    64kbps    Server->Client
//
//******************************************************************************

//******************************************************************************
// Definitions
//******************************************************************************

//------------------------------------------------------------------------------
//It is NOT recommended that the following be modified for customisation - do so 
//with care, and it is suggested it is fed back to Laird Connectivity to ease
//your maintenance in the future if Laird Connectivity modifies and enhances
//this application
//------------------------------------------------------------------------------

//This defines the maximum number of UUID handles
#define MAX_UUID_HANDLES                            16

//This defines the maximum number of elements in metadata array
#define MAX_METADATA_HANDLES                        4

//Maximum comma separated arguments allowed in an AT command
#define MAX_ARGS_IN_ATCMD                           10

//ASCII characters
#define CHR_ASCII_SPACE                             0x20
#define CHR_ASCII_QUOTE                             0x22
#define CHR_ASCII_0                                 0x30
#define CHR_ASCII_9                                 0x39
#define CHR_ASCII_LOWER_L                           0x6C
#define CHR_ASCII_UPPER_A                           0x41
#define CHR_ASCII_UPPER_L                           0x4C
#define CHR_ASCII_UPPER_Z                           0x5A
#define ASCII_LOWER_TO_UPPER_DIFFERENCE             0x20

//Invalid connection handle
#define INVALID_CONN_HANDLE                         0

//Invalid UUID handle
#define INVALID_UUID_HANDLE                         -1

//Index for the handle for the VSP connection
#define HCONN_VSP                                   0

//Timer used for encryption timeout
#define TMRNUM_ENCR_WAIT                            0
#define TMRNUM_LOWPWR_UART                          1

//Maximum length of attribute length in metadata when creating the GATT table
#define MAX_ATTRIBUTE_LEN                           250

//Default event length per connection event per connection
#define DEFAULT_EVENT_LENGTH                        12

//Only check for carets in UART buffer if there is at least this
//much space in the VSP Tx buffer
#define MIN_SPACE_IN_VSPTXBUF_TO_CHECK_FOR_CARETS   20

//AT Command letter
#define ATCMD_EMPTY                                 0
#define ATCMD_D                                     0x44
#define ATCMD_F                                     0x46
#define ATCMD_I                                     0x49
#define ATCMD_S                                     0x53
#define ATCMD_W                                     0x57
#define ATCMD_X                                     0x58
#define ATCMD_Z                                     0x5A
#define ATCMD_PERCENT                               0x25
#define ATCMD_AMPERSAND                             0x26
#define ATCMD_PLUS                                  0x2B

#define VSP_PUMP_TIMEOUT_ADD                        2500

//AT Responses for VSP connect (starts at 80 because HSI reason is up to 64)
#define CONN_OK                                     0
#define CONN_ERROR_BLECONNECT                       80
#define CONN_ERROR_INVALID_ADDRESS                  81
#define CONN_ERROR_CMDPINSTATE                      82
#define CONN_ERROR_TOOMANYCONNECTIONS               83
#define CONN_ERROR_TIMEOUT                          84
#define CONN_ERROR_OUTOFMEM                         85
#define CONN_ERROR_UNENCRYPTED                      86
#define CONN_ERROR_NOVSPSERVICE                     87
#define CONN_ERROR_PAIRUI                           88
#define CONN_ERROR_USER_DISCON                      90
#define CONN_ERROR_AUTHLINK_REQUIRED                91
#define CONN_SUSPEND                                -1

//Types of adverts
#define ADV_IND                                     0
#define ADV_DIRECT_IND                              1
#define ADV_SCAN_IND                                2
#define ADV_NONCONN_IND                             3

//Bonding KeyInfo
#define BONDING_KEYINFO_MITM_AUTHENTICATED          1
#define BONDING_KEYINFO_AUTO_DELETE_ROLLING         2
#define BONDING_KEYINFO_IRK_EXISTS                  4
#define BONDING_KEYINFO_CSRK_EXISTS                 8
#define BONDING_KEYINFO_LTK_AS_SLAVE_EXISTS         16
#define BONDING_KEYINFO_LTK_AS_MASTER_EXISTS        32

//Bond trust context
#define BOND_TRUSTED_AS_PERIPHERAL                  0
#define BOND_TRUSTED_AS_CENTRAL                     1

//MITM requirement bit masks
#define BLE_ENCRYPT_MITM_NOT_REQUIRED               0
#define BLE_ENCRYPT_MITM_REQUIRED                   1

//Minimum LTK size requirement
#define LTK_MINIMUM_SIZE                            7

//Values in curState variable
#define STATE_INIT                                  0
#define STATE_IDLE_nonVSP                           10
#define STATE_IDLE_VSP                              20
#define STATE_SCAN_VSP                              30
#define STATE_VSP_FAST_CONNECTED                    40
#define STATE_VSP_CONNECTING                        50
#define STATE_VSP_WAIT_ENCRYPT                      51
#define STATE_VSP_GET_HANDLES                       52
#define STATE_VSP_WRITE_CCCDS                       53
#define STATE_VSP_PAIRING                           54
#define STATE_VSP_DISCONNECTING                     55
#define STATE_nonVSP_CONNECTING                     60
#define STATE_nonVSP_CONNECTED                      80
#define STATE_VSP_IN_WAIT_ENCR                      70
#define STATE_VSP_CARET_CONNECTED                   90

//MsgID for SendMsgApp so that we can serialise processes and also used
//to invoke functionality which is not compiled yet
#define MSGAPP_PROCESS_UART                         0
#define MSGAPP_ENTER_VSPOUT_CONN_STATE              1
#define MSGAPP_ENTER_VSPIN_CONN_STATE               2
#define MSGAPP_ENTER_NONVSP_CONN_STATE              3
#define NULL_CTX                                    0

//Defines associated with UART low power operation
#define UART_SIONUM_RX                              8
#define UART_SIONUM_CTS                             7
#define UART_SIONUM_TX                              6
#define UART_SIONUM_RTS                             5
#define UART_IDLE_REPOLL_TIMEOUT_MS                 1000
#define UART_DEFAULT_LOWPWR_CMDPIN                  24

//These are ID's used to help with reuse of helper functions
#define CMD_I_LDSC                                  0
#define CMD_I_PAIR                                  1
#define CMD_I_LENC                                  2
#define CMD_I_GCTM                                  3
#define CMD_I_LMTU                                  4
#define CMD_I_LPHY                                  5

#define CMD_GCRDWR_GCRD                             0
#define CMD_GCRDWR_GCWA                             1
#define CMD_GCRDWR_GCWC                             2

#define CMD_GSSBE_GSSE                              0
#define CMD_GSSBE_GSSB                              1

#define CMD_MO01_ARST                               0
#define CMD_MO01_SFMT                               1

#define CMD_ACTTYPE_SIOR                            0
#define CMD_ACTTYPE_SIOW                            1
#define CMD_ACTTYPE_SIOC                            2

#define CMD_IS_NOTIFY                               0
#define CMD_IS_INDICATE                             1
#define CMD_IS_LOCALWRITE                           2

#define DEFAULT_ATT_MTU                             23
#define DEFAULT_ATTRIBUTE_SIZE                      (DEFAULT_ATT_MTU-3)

//NFC related
#define INVALID_NFC_HANDLE                          0xFFFFFFFF
#define INVALID_NDEF_HANDLE                         0xFFFFFFFF
#define NFC_DEFAULT_TAG_SIZE                        128
#define NFC_MIN_TAG_SIZE                            128
#define NFC_MAX_TAG_SIZE                            512

#define NFC_TNF_EMPTY                               0x00 //The value indicates that there is no type or payload associated with this record.
#define NFC_TNF_WELL_KNOWN                          0x01 //NFC Forum well-known type [NFC RTD].
#define NFC_TNF_MEDIA_TYPE                          0x02 //Media-type as defined in RFC 2046 [RFC 2046].
#define NFC_TNF_ABSOLUTE_URI                        0x03 //Absolute URI as defined in RFC 3986 [RFC 3986].
#define NFC_TNF_EXTERNAL_TYPE                       0x04 //NFC Forum external type [NFC RTD].
#define NFC_TNF_UNKNOWN_TYPE                        0x05 //The value indicates that there is no type associated with this record.
#define NFC_TNF_UNCHANGED                           0x06 //The value is used for the record chunks used in chunked payload.
#define NFC_TNF_RESERVED                            0x07 //The value is reserved for future use.
#define NFC_MSGIN_NFCFIELDOFF                       2
#define NFC_MSGIN_NFCFIELDON                        3
#define NFC_MSGIN_NFCTAGREAD                        7

#define SIOTYPE_DIN                                 1
#define SIOTYPE_DOUT                                2
#define SIOTYPE_AIN                                 3

#define INPUT_PULL_NONE                             0
#define INPUT_PULL_DOWN                             1
#define INPUT_PULL_UP                               2

#define OUTPUT_INIT_LOW                             0
#define OUTPUT_INIT_HI                              1

#define DCD_ASSERT_STATE                            0
#define DCD_DEASSERT_STATE                          1

#define PHY_AUTO                                    0
#define PHY_1M                                      1
#define PHY_2M                                      2
#define PHY_CODED                                   4
 
//Following just assist with documentation
#define IDX_MAX_CONN_AS_SLAVE                       0
#define IDX_MAX_CONN_AS_MASTER                      1
#define IDX_EVENT_LENGTH                            2
#define IDX_TRANSMISSION_BUFFERS                    3

#define MAX_EXTADV_PROPERTY_VALUE                   b'11111111111
#define MAX_EXTADV_PROPERTY_DEFAULT                 0
#define MAX_EXTADV_PRISECPHY                        b'111
#define MAX_EXTADV_PRISECPHY_DEFAULT                b'000
#define EXTADV_MAXCOUNT_NONE                        0
#define EXTADV_MAXCOUNT_DEFAULT                     0
#define EXTADV_MAXCOUNT_MAXIMUM                     255
#define EXTADV_FILTER_NONE                          0
#define ADV_FILTER_NONE                             0

#define EXTADVPROP_CONNECTABLE                      b'0001
#define EXTADVPROP_SCANNABLE                        b'0010
#define EXTADVPROP_DIRECTED                         b'0100
#define EXTADVPROP_EXTENDED                         b'1000
#define EXTADVPROP_CONNpEXT                         b'1001

#define EXTADVPRIPHY_1MPHY                          0
#define EXTADVPRIPHY_LECODED                        1

#define SIZE_OF_BLE_ADDRESS                         7
#define SIZE_OF_CHANNEL_MASK                        5
#define SETID_DEFAULT                               0
#define ADV_DURATION_FOREVER                        0
#define AUXOFFSET_DEFAULT                           0

//Bitmasks used for scanning using new API
#define SCANTYPE_1MPHY                              b'0001
#define SCANTYPE_LECODED                            b'0010
#define SCANTYPE_EXTENDED                           b'0100
#define SCANTYPE_PASSIVE_SCANNING                   b'1000

//Outgoing VSP char/desc query array and array element definition is as per the
#define VSP_ATTR_INDEX_RX                           0
#define VSP_ATTR_INDEX_TX                           1
#define VSP_ATTR_INDEX_MDMIN                        2
#define VSP_ATTR_INDEX_MDMOUT                       3
#define VSP_ATTR_INDEX_TX_CCCD                      4
#define VSP_ATTR_INDEX_MDMOUT_CCCD                  5
#define VSP_ATTR_MAX_INDEXES                        6

//Bit values, masks and shift amounts, values correspond to entries in user manual and should not be changed
#define CONFIG_PHY_BIT_SHIFT                        5
#define CONFIG_PHY_BIT_MASK                         0x00000003
#define CONFIG_VSP_BIT_MASK                         0x78
#define CONFIG_VSP_OPTIMISED_BIT_SHIFT              3
#define CONFIG_VSP_OPTIMISED_BIT_MASK               0x00000001
#define CONFIG_VSP_DLE_BIT_SHIFT                    4
#define CONFIG_VSP_DLE_BIT_MASK                     0x00000001
#define CONFIG_VSP_ENABLED                          0x00000001
#define CONFIG_ADVERTS_ENABLED                      0x00000002
#define CONFIG_SCANNING_ENABLED                     0x00000004
#define CONFIG_ENCRYPTION_ENABLED                   0x1
#define CONFIG_MITM_ENABLED                         0x2

#define VSP_OPEN_MITM_REQUIRED                      0xC
#define VSP_OPEN_MITM_NOT_REQUIRED                  0x8

#define VSP_MDM_FAIL_CACHE_DEASSERTED               0
#define VSP_MDM_FAIL_CACHE_ASSERTED                 1
#define VSP_MDM_FAIL_CACHE_NONE                     2

//******************************************************************************
// Global Variable Declarations
//******************************************************************************

//Result code variable (used for checking if a function completed successfully or not)
dim rc

//Temporary variables
dim tmpVar
dim tmpVar$
dim tmpDta$
dim tmpDta

//Contains number of arguments extracted from a command
dim args

//******************************************************************************
//******************************************************************************
//******************************************************************************
// Initialisation values for SRegister caches ...
//
// These values are created by running the application "sreg.defaults.creation.sb"
// and then copy/pasting its output here - verbatim.
//
// This technique is used to reduce the size of the .uwc file of the main sb file
//******************************************************************************
//******************************************************************************
//******************************************************************************
#include "$LIB$.debug.code.sb"
#include "$LIB$.SRegInterface.sb"
//******************************************************************************
//******************************************************************************
//******************************************************************************

//Contains current state, see STATE_XXX
dim curState : curState = STATE_INIT
//Contains the state as we will need it later before entering a non-idle state
dim oldIdleState

//UART send/receive buffer (for application command mode)
dim UARTSndBuf$ : UARTSndBuf$ = ""
dim UARTRecBuf$ : UARTRecBuf$ = ""
dim UARTbaud, UARTTxBuf, UARTRxBuf, UARTFlags$

//Terminator for commands in command mode
dim termStr$ : termStr$ = "\r"
dim termlen  : termlen = strlen(termStr$)

//OK or ERROR response strings
dim ok$ : ok$ = "\nOK"
dim er$ : er$ = "\nERROR "
//If the following is zero then the AT parser is suspended
dim atParse : atParse = 1

//This array is updated by ExtractXxxxx() functions
dim sArg$[MAX_ARGS_IN_ATCMD]
//This array is updated if an integer needs to be extracted from sArg$
dim nArg[MAX_ARGS_IN_ATCMD]

//Cache of SReg 100
dim startflags

//Holds the timeout value that will disconnect a device that connects but doesn't
//encrypt the connection within the time (if the encryption flag is enabled)
dim encDisconTime   //if 0 then encryption via S102 is not requested

//This is the service UUID that was submitted to BleVspOpen
dim handleVspServiceUuid : handleVspServiceUuid = 0

//When scanning using AT+BLS, this is the pattern to search for in each advert report
dim scnPattern$
//This contains the length of the pattern$ string
dim scnPatternLen
//When scanning using AT+BLS, this is the minimum RSSI to allow
dim scnRssi

//These variables are used in the adv_report handler and are defined as globals
//to improve speed
dim periphAddr$, advData$, nDiscarded, nRssi, nme$

//This is the most recent i/o capability submitted to the stack
dim pairIoCapCache

//The following is nonzero if BleVspOpen() was successful and it implies that the
//VSP service has been added to the GATT table
dim vspAdded

//These are advert and scan reports that will be submitted when not in VSP mode
//and advertising
dim idleAdvRpt$, idleScnRpt$, idleAdvType, idleAdvIntvlMs

//These are the cache for the Scan related parameters
dim scanIntervalMs, scanWindowMs, scanType

//This is the pin to use to enter command mode when in FAST mode. If <0 then it
//implies FAST mode has been disabled
dim vspCmdModePin

//This is the pin to use the connection status of VSP like the DCD pin in modems.
//Which means 0 is for -- there is a connection and 1 is for no connection
dim vspDcdPin

//These are the pins from S registers 138 (indicates an active connection)
//and 139 (indicates an encrypted connection) and the polarity from S register 137
dim sioConnActivePin, sioConnEncryptedPin
dim sioConnAssertState, sioEncrAssertState

//Total number of connections active
dim connCount

//This is nonzero if the GATT client is open
dim fGattClient : fGattClient = 0

//UUID handles.
dim uuidHandles[MAX_UUID_HANDLES]

//Metadata handles
dim metaHandles[MAX_METADATA_HANDLES + 1]

//Connection handles. Index 0 is used for VSP Connection (as they are mutually exclusive)
dim connHandles[MAX_CONNECTIONS + 1]

//Connection encryption status (0=non, 1=encr).
//Used for encrypted connection indication pin
dim connIsEncrypted[MAX_CONNECTIONS + 1]

//Char Handles that we manage - only index is sent to host
dim charHandles[MAX_CHARACTERISTICS + 1]  //index 0 is never used
dim numOfChars : numOfChars = 0

//Scan advert report display format
// 0 : default (abbreviated)
// 1 : full in hex format
dim scnFmt

dim vspSvcUuid, hVspCccdUuids[VSP_ATTR_MAX_INDEXES], hVspAttr[VSP_ATTR_MAX_INDEXES]  //NArg[] i used to store CharUuid Handles

//This is the array index into hVspCccdUuids & hVspAttr when querying for attribute handles
dim vspFindIndex

//If a cccd write results in an error then this contains the status code
dim vspDisconSts
//If this is 1 then we are waiting for an ack from the VSP peer
dim vspAllowTx
//If this is 1 then we are waiting for an ack from the VSP peer
dim vspAllowRx
//This is the maximum attribute length for VSP
dim vspAttrMaxLen
//This is the maximum data chunk length based on negotiated ATT_MTU
dim vspChunkLen
//This is used to count the number of ^ in slow mode to drop the connection
dim vspEscCount
//This is the tick count when a ^ is received in slow mode
dim vspEscStart
//This is the max count of received ^ chrs to trigger a disconnect
dim vspEscCountMax
//This is the min interval between two ^ to count towards escaping towards a disconnect
dim vspEscMinIntrvl
//The following is the escape string that needs to entered vspEscCountMax times to disconnect
dim vspEscString$
dim vspEscStringLen
//Following will be nonzero if the VSP connection is outgoing
dim vspIsOutGoing
//This is the maximum number of VSP Rx packets that can be cached
dim vspCachedPkts : vspCachedPkts = 8
//Set to 1 if long-range VSP connections required which is specified by SReg100
dim vspLongRange

//Define an address string which is always empty
dim emptyAddr$ : emptyAddr$ = ""

//This is the advert report prefix
dim advPrefix$

//GATT Server use - current service handle being defined, non-0 if in the middle of
//entering a service
dim svcHandle : svcHandle = 0

//GATT Server use - current characteristic handle being defined, non-0 if in the middle of
//entering a characteristic
dim chrInProg : chrInProg = 0

//Made this a global variable for various handlers & functions to use so that
//code size if reduced
dim charIdx

//This is used to improve the datapump when sending data out to the slave in VSP mode
//It is used to start a timer so that BleGattcWriteCmd() can be called again.
dim vspPumpToutMs

//This is the DLE Attribute Size cache read for SReg 219
dim dleAttrSz

//Following used to help debug VSP MODEM change activity
#cmpif 0x00000040 : dim vtxcnt : vtxcnt = 0
#cmpif 0x00000040 : dim vrxcnt : vrxcnt = 0

//NFC related
#cmpif 0x00200000 : dim nfcHandle    //returned by NfcOpoen
#cmpif 0x00200000 : dim ndefHandle   //returned by NfcNdefMsgNew
#cmpif 0x00200000 : dim nfcSenseCnt  //ATI50
#cmpif 0x00200000 : dim nfcReadCnt   //ATI51

dim fLowPowerUart : fLowPowerUart = 0
#cmpif 0x00400000 : fLowPowerUart = 1
#cmpif 0x00400000 : dim UARTIdleToutMs

//Define the prefix identifiers for extended advert and extended scan response async
//messages to the host
dim eadvpfx$: eadvpfx$ = "\nADE:"
dim escnpfx$: escnpfx$ = "\nADS:"

//Following is updated after a successive call of either BleAdvSetStart() or BleAdvertStart()
dim fExtAdvertising : fExtAdvertising = FALSE

//Following used to cache if a modem characteristic cannot be sent due to a full buffer
dim vspMdmSendFail : vspMdmSendFail = VSP_MDM_FAIL_CACHE_NONE

//******************************************************************************
// Initialise Global Variable
//******************************************************************************

#cmpif 0x00200000 : nfcHandle   = INVALID_NFC_HANDLE
#cmpif 0x00200000 : ndefHandle  = INVALID_NDEF_HANDLE
#cmpif 0x00200000 : nfcSenseCnt = 0
#cmpif 0x00200000 : nfcReadCnt  = 0

//******************************************************************************
// Function and Subroutine definitions
//******************************************************************************

//------------------------------------------------------------------------------
// Removes leading 0s from the front of a string
//------------------------------------------------------------------------------
sub RemoveZeros(byref Data$)
    dim i : i = 0
    while (i < strlen(Data$))
        if StrGetChr(Data$, i) != CHR_ASCII_0 then
            //Found first nonzero digit
            Data$ = Right$(Data$, strlen(Data$) - i)
            exitsub
        endif
        i = i + 1
    endwhile

    //At this point, the whole string is 0's, shorten to one
    Data$ = "0"
endsub

//------------------------------------------------------------------------------
// Change state
//------------------------------------------------------------------------------
sub NewState(nState)
    if nState != curState then
        #cmpif 0x00000004 : sprint #dbgmsg$, "NewState = "; nState
        #cmpif 0x00000004 : DbgMsg(dbgmsg$)
        curstate = nState
    endif
endsub

//------------------------------------------------------------------------------
// Save state info
//------------------------------------------------------------------------------
sub SaveState(byref prState)
    prState = curstate
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub GetFirmwareVersion(tmpVar$)
    dim val, p, mj, mn, b

    val = sysinfo(3)
    b   = (val      ) & b'111111
    mn  = (val >>  6) & b'111111111111
    mj  = (val >> 18) & b'111111
    p   = (val >> 24)

    sprint #tmpVar$, p;".";mj;".";mn;".";b
endsub

//------------------------------------------------------------------------------
// Function that will convert a string to lowercase - insitu
//------------------------------------------------------------------------------
sub StrToLower$(byref Text$)
    //Takes a string and replaces uppercase letters with lowercase letters
    dim i, chr
    i = strlen(Text$) - 1
    while (i >= 0)
        chr = StrGetChr(Text$, i)

        if (chr >= CHR_ASCII_UPPER_A && chr <= CHR_ASCII_UPPER_Z) then
            rc = StrSetChr(Text$, chr + ASCII_LOWER_TO_UPPER_DIFFERENCE, i)
        endif
        i = i-1
    endwhile
endsub

//------------------------------------------------------------------------------
// Drop all characters with ascii value less than CHR_ASCII_SPACE and >=0
//------------------------------------------------------------------------------
sub DropWhiteSpace(byref cmdStr$)
    dim drop : drop = 0

    tmpDta = StrGetChr(cmdStr$, drop)
    while (tmpDta >= 0) && (tmpDta <= CHR_ASCII_SPACE)
        drop = drop + 1
        tmpDta = StrGetChr(cmdStr$, drop)
    endwhile
    StrShiftLeft(cmdStr$, drop)
endsub

//------------------------------------------------------------------------------
// Returns the single letter AT command from the string or a -ve value
//------------------------------------------------------------------------------
function GetAtCmdLetter(byref cmdStr$) as integer
    dim retVal

    DropWhiteSpace(cmdStr$)

    //At this point cmdStr$ is either empty or has a first character that
    //is > CHR_ASCII_SPACE
    retVal = StrGetChr(cmdStr$, 0)
    if retVal >= CHR_ASCII_SPACE then
        //String was not empty so drop the single character
        StrShiftLeft(cmdStr$, 1)
    else
        //Assume the string was empty
        retVal = 0
    endif
endfunc retVal

//------------------------------------------------------------------------------
// Strip "" from str$ if they exist
//------------------------------------------------------------------------------
sub TrimQuotes(str$)
    dim len
    if strgetchr(str$, 0) == CHR_ASCII_QUOTE then    //Check for beginning "
        len = strlen(str$)
        if len > 2 then
            if strgetchr(str$, (len-1)) == CHR_ASCII_QUOTE then //Check for ending "
                str$ = mid$(str$, 1, (len-2))
            endif
        elseif len == 2 then
            str$ = ""
        endif
    endif
endsub

//------------------------------------------------------------------------------
// Checks if the string is quoted
//------------------------------------------------------------------------------
function IsQuoted(str$)
    dim len
    if strgetchr(str$, 0) == CHR_ASCII_QUOTE then    //Check for beginning "
        len = strlen(str$) - 1
        if len >= 1 then
            if strgetchr(str$, len) == CHR_ASCII_QUOTE then //Check for ending "
                exitfunc 1
            endif
        endif
    endif
endfunc 0

//------------------------------------------------------------------------------
// Returns 0 if the value is outside min and max
//------------------------------------------------------------------------------
function InRange(newVal, minVal, maxVal) as integer
    if newVal<minVal then
        exitfunc 0
    elseif newVal>maxVal then
        exitfunc 0
    endif
endfunc 1

//------------------------------------------------------------------------------
// If the config value was different and got updated successfully, then the
// variable nUpdated is incremented
//------------------------------------------------------------------------------
sub SetConfigKey(keyId, newVal, byref nUpdated)
    dim curVal
    rc = NvCfgKeyGet(keyId, curVal)
    if rc == 0 then
        if newVal != curVal then
            rc = NvCfgKeySet(keyId, newVal)
            if rc == 0 then
                nUpdated = nUpdated + 1
            endif
        endif
    endif
endsub

//------------------------------------------------------------------------------
// Get node index number from connection handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CONNECTIONS
//------------------------------------------------------------------------------
function GetIdxFromHConn(hConn as integer) as integer
    dim i
    //Search for the address through the node cache which will also unconnected
    for i = 1 to MAX_CONNECTIONS    //start from index 1 because 0 is dedicated for VspConnection
        if connHandles[i] == hConn then
            exitfunc i
        endif
    next
endfunc 0

//------------------------------------------------------------------------------
// Get free node index number for connection handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CONNECTIONS
//------------------------------------------------------------------------------
function GetFreeIdx() as integer
    dim i
    //Search for an empty handle
    for i = 1 to MAX_CONNECTIONS
        if connHandles[i] == INVALID_CONN_HANDLE then
            exitfunc i
        endif
    next
endfunc 0

//------------------------------------------------------------------------------
// Save a characteristic handle to the managed array so that we can report an
// index number to the host.
//------------------------------------------------------------------------------
function AddCharHandle(charH, byref nIdx) as integer
    if numOfChars<MAX_CHARACTERISTICS then
        numOfChars = numOfChars + 1
        nIdx = numOfChars
        charHandles[nIdx] = charH
        exitfunc RSP_OK
    endif
endfunc RSP_TOO_MANY_CHARACTERISTICS

//------------------------------------------------------------------------------
// Get node index number from characteristic handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CHARACTERISTICS
//------------------------------------------------------------------------------
function GetIdxFromHChar(hChar as integer) as integer
    dim i
    //Search for the address through the node cache which will also unconnected
    for i = 1 to MAX_CHARACTERISTICS    //start from index 1 because 0 is dedicated for VspConnection
        if charHandles[i] == hChar then
            exitfunc i
        endif
    next
endfunc 0

//------------------------------------------------------------------------------
// The rest of the str$ should be up to MAX_ARGS_IN_ATCMD arguments separated by ','
// returns RSP_OK if ok and 'args' is updated with number of args and the global
// string array sArg$[] contains the arguments (but not the ',')
// If any arguments have "" delimiters they are removed
//------------------------------------------------------------------------------
function ExtractArgsCSV(str$, byref args, minargs, maxargs)
    dim tlen, commaExp, chr

    #cmpif 0x00000003 : AssertBound(minargs, 0, MAX_ARGS_IN_ATCMD, 923)
    #cmpif 0x00000003 : AssertBound(maxargs, minargs, MAX_ARGS_IN_ATCMD, 924)

    args = 0
    commaExp = 0    //1 for expected

    //Clear up to maxargs
    for chr = 0 to maxargs
        sArg$[chr] = ""
    next

    //Special case check if maxargs is 0 and the line is not empty
    tlen = ExtractStrToken(str$, tmpVar$)
    if tlen > 0 then
        //First argument will not have a preceding comma, unless it is missing
        if strcmp(tmpVar$, ",") == 0 then
            //Unexpected comma so empty string
            sArg$[0] = ""
        else
            //Remove delimiting "" quotes
            TrimQuotes(tmpVar$)
            //Save it in the args array
            sArg$[0] = tmpVar$
            //Now extract another token and that could be a comma
            tlen = ExtractStrToken(str$, tmpVar$)
        endif
        args = 1
    endif

    //At this point tmpVar$ has to be comma or empty

    //Now parse the string further
    while tlen > 0
        //Check if too many args already encountered
        if args >= maxargs then
            exitfunc RSP_ERROR_TOOMANYARGS
        endif

        //This has to be a comma
        if strcmp(tmpVar$, ",") == 0 then
            //Increment the count
            sArg$[args] = ""
        else
            exitfunc RSP_ERROR_SYNTAX_ERROR
        endif

        //Now extract another token and that should be an arg, a comma, or empty
        tlen = ExtractStrToken(str$, tmpVar$)
        if tlen > 0 then
            if strcmp(tmpVar$, ",") == 0 then
                //Got an empty parameter so do nothing here, args count incremented later
            elseif strcmp(tmpVar$, "-") == 0 then
                //Looks like there could be a negative number
                if strlen(str$) > 0 then
                    chr = StrGetChr(str$, 0)
                    if (chr >= CHR_ASCII_0) && (chr <= CHR_ASCII_9) then
                        //It is a decimal digit
                        tlen = ExtractStrToken(str$, tmpVar$)
                        //Save it in the args array
                        sArg$[args] = "-" + tmpVar$
                        //Now extract another token and that should be a comma or empty
                        tlen = ExtractStrToken(str$, tmpVar$)
                    endif
                else
                    //There are no more characters
                    sArg$[args] = tmpVar$
                    tlen = 0
                endif
            else
                //Remove delimiting "" quotes
                TrimQuotes(tmpVar$)
                //Save it in the args array
                sArg$[args] = tmpVar$
                //Now extract another token and that should be a comma or empty
                tlen = ExtractStrToken(str$, tmpVar$)
            endif
        endif
        args = args + 1
    endwhile

    //#cmpif 0x00000004 : dim i
    //#cmpif 0x00000004 : DbgMsgVal("args=", args)
    //#cmpif 0x00000004 : for i = 0 to (MAX_ARGS_IN_ATCMD-1)
    //#cmpif 0x00000004 :     print "\n## sArg$[";i;"]=";sArg$[i]
    //#cmpif 0x00000004 : next

    //Check if too few args parsed
    if args < minargs then
        exitfunc RSP_ERROR_TOOFEWARGS
    endif
endfunc RSP_OK

////------------------------------------------------------------------------------
//// The rest of the str$ should not be up to MAX_ARGS_IN_ATCMD arguments which are
//// whitespace delimited as opposed to ',' delimited as in ExtractArgsCSV()
////
//// As it is not currently called, but could be in the future, it is commented out
////------------------------------------------------------------------------------
//function ExtractArgsStr(str$, byref args, minargs, maxargs)
//    dim tlen
//
//    #cmpif 0x00000003 : AssertBound(minargs, 0, MAX_ARGS_IN_ATCMD, 1024)
//    #cmpif 0x00000003 : AssertBound(maxargs, minargs, MAX_ARGS_IN_ATCMD, 1025)
//
//    args = 0
//
//    //Extract first token
//    tlen = ExtractStrToken(str$, tmpVar$)
//    //then loop until max done
//    while tlen > 0
//        //check if too many args already encountered
//        if args >= maxargs then
//            exitfunc RSP_ERROR_TOOMANYARGS
//        endif
//
//        //remove delimiting "" quotes
//        TrimQuotes(tmpVar$)
//        //save it in the args array
//        sArg$[args] = tmpVar$
//        #cmpif 0x00008000 : print "\narg=";tmpVar$
//        //increment
//        args = args + 1
//        //now extract another token and that should be a comma or empty
//        tlen = ExtractStrToken(str$, tmpVar$)
//
//    endwhile
//
//    //check if too few args parsed
//    if args < minargs then
//        exitfunc RSP_ERROR_TOOFEWARGS
//    endif
//endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function SArgConvertToInt(ndx, defval, mn, mx)
    dim val

    #cmpif 0x00000003 : AssertBound(ndx, 0, (MAX_ARGS_IN_ATCMD - 1), 1061)

    if strlen(sArg$[ndx]) == 0 then
        //Not specified so set to default
        val = defval
    else
        //A threshold has been specified so attempt to convert to an integer
        if ExtractIntToken(sArg$[ndx], val) == 0 then
            exitfunc RSP_ERROR_SYNTAX_ERROR
        endif
    endif
    if (val < mn) || (val > mx) then
        exitfunc RSP_ERROR_VALUE_NOT_VALID
    endif
    nArg[ndx] = val
endfunc RSP_OK

//------------------------------------------------------------------------------
// Close the UART if Rx/Tx buffers are empty
//------------------------------------------------------------------------------
#cmpif    0x00400000 : sub UartCloseConditional()
#cmpif    0x00400000 :     //Close only if the cmdpin is deasserted
#cmpif    0x00400000 :     if GpioRead(vspCmdModePin) == 0 then
#cmpif    0x00400000 :         //Host does not care if we close the UART
#cmpifand 0x00400104 :         DbgMsg("Uart closing     ")
#cmpifand 0x00400104 :         //Wait for Tx buffer to flush
#cmpifand 0x00400104 :         while UartInfo(5) > 0
#cmpifand 0x00400104 :         endwhile
#cmpif    0x00400000 :
#cmpif    0x00400000 :         if UartInfo(0) then
#cmpif    0x00400000 :             //UART is open so try to close it if rx/Tx ring buffers are empty
#cmpif    0x00400000 :             rc = UartCloseEx(1)
#cmpif    0x00400000 :         endif
#cmpif    0x00400000 :
#cmpif    0x00400000 :         if UartInfo(0) then
#cmpif    0x00400000 :             //The UART is still open so restart the time
#cmpif    0x00400000 :             TimerStart(TMRNUM_LOWPWR_UART, UART_IDLE_REPOLL_TIMEOUT_MS, 0)
#cmpifand 0x00400104 :             DbgMsg("Uart Tmr STARTp")
#cmpif    0x00400000 :         else
#cmpif    0x00400000 :             //Closed, so configure the TX and RTS as outputs and adjust outputs
#cmpif    0x00400000 :             rc = gpiosetfunc(UART_SIONUM_TX, SIOTYPE_DOUT, OUTPUT_INIT_HI)     //TX set high on default
#cmpifand 0x00400103 :             AssertRC(1155)
#cmpif    0x00400000 :             rc = gpiosetfunc(UART_SIONUM_RTS, SIOTYPE_DOUT, OUTPUT_INIT_HI)    //RTS set high to de-assert
#cmpifand 0x00400103 :             AssertRC(1157)
#cmpif    0x00400000 :             rc = GpioSetFunc(UART_SIONUM_RX, SIOTYPE_DIN, INPUT_PULL_UP)        //RX Pull high
#cmpifand 0x00400103 :             AssertRC(1159)
#cmpif    0x00400000 :             rc = GpioSetFunc(UART_SIONUM_CTS, SIOTYPE_DIN, INPUT_PULL_DOWN) //CTS Pull low
#cmpifand 0x00400103 :             AssertRC(1161)
#cmpif    0x00400000 :         endif
#cmpif    0x00400000 :     else
#cmpif    0x00400000 :         //Start the UART inactivity timer
#cmpif    0x00400000 :         TimerStart(TMRNUM_LOWPWR_UART, UARTIdleToutMs, 0)
#cmpifand 0x00400104 :         DbgMsg("Uart Tmr STARTv")
#cmpif    0x00400000 :     endif
#cmpif    0x00400000 : endsub

//------------------------------------------------------------------------------
// Reopen the UART and if it was closed
// unconditionally restarts the idle timer
//------------------------------------------------------------------------------
#cmpif    0x00400000 : sub UartReOpen()
#cmpif    0x00400000 :     if UartInfo(0) == 0 then
#cmpif    0x00400000 :         //UART was actually closed so open it
#cmpif    0x00400000 :         rc = UartOpen(UARTbaud, UARTTxBuf, UARTRxBuf, UARTFlags$)
#cmpifand 0x00400103 :         AssertRC(1178)
#cmpif    0x00400000 :     endif
#cmpif    0x00400000 :     //Start the UART inactivity timer
#cmpif    0x00400000 :     TimerStart(TMRNUM_LOWPWR_UART, UARTIdleToutMs, 0)
#cmpifand 0x00400104 :     DbgMsg("Uart Tmr STARTr")
#cmpif    0x00400000 : endsub

//------------------------------------------------------------------------------
// Routine for sending buffered data for the UART
//------------------------------------------------------------------------------
sub SendUartData()
    if (StrLen(UARTSndBuf$) > 0) then
        //Send UART data
        #cmpif 0x00400000 :    UartReOpen()
        rc = UARTWrite(UARTSndBuf$)
        StrShiftLeft(UARTSndBuf$, rc)
    endif
endsub

//------------------------------------------------------------------------------
// Routine for sending buffered data for the UART
//------------------------------------------------------------------------------
sub SendUartDataEx(byref appData$)
    UARTSndBuf$ = UARTSndBuf$ + appData$
    if (StrLen(UARTSndBuf$) > 0) then
        //Send UART data
        #cmpif 0x00400000 : UartReOpen()
        rc = UARTWrite(UARTSndBuf$)
        StrShiftLeft(UARTSndBuf$, rc)
    endif
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub AppendRspEnd(rsp as integer, byref bufferStr$)
    dim tmpStr$
    if rsp == 0 then
        tmpStr$ = ok$
    elseif rsp > 99 then
        sprint #tmpStr$, integer.h' rsp
        tmpStr$ = er$ + right$(tmpStr$, 4)
    elseif rsp > 0 then
        sprint #tmpStr$, "0";rsp
        tmpStr$ = er$ + right$(tmpStr$, 2)
    else
        atParse = 0
        exitsub
    endif
    bufferStr$ = bufferStr$ + tmpStr$ + "\r"
    atParse = 1
endsub

//------------------------------------------------------------------------------
// For valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub GetConnInfoRsp(hConn, byref rsp$, byref intrvl)
    dim addr$, sprvto, slat

    rc = BleGetCurConnParms(hConn, intrvl, sprvto, slat)
    #cmpif 0x00000003 : AssertRC(1237)

    rc = BleGetAddrFromConnHandle(hConn, addr$)
    #cmpif 0x00000003 : AssertRC(1240)

    sprint #rsp$, StrHexize$(addr$);", ";intrvl;", ";sprvto;", ";slat
endsub

//------------------------------------------------------------------------------
// For valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub AppendConnRspEnd(rsp as integer, byref bufferStr$)
    dim tmpStr$, info$, intrvl
    if rsp == 0 then
        GetConnInfoRsp(connHandles[HCONN_VSP], info$, intrvl)
        sprint #tmpStr$, "\nCONNECT 0, ";info$;"\r"
        //Set the data pump timer for when BleGattcWriteCmd fails due to lack of buffers
        vspPumpToutMs = (intrvl + VSP_PUMP_TIMEOUT_ADD) / MS_IN_SECONDS
    elseif rsp > 0 then
        sprint #tmpStr$, "\nNOCARRIER ";rsp;"\r"
    else
        atParse = 0
        exitsub
    endif
    bufferStr$ = bufferStr$ + tmpStr$
    atParse = 1
endsub

//------------------------------------------------------------------------------
// Cache idleAdvType with Sreg value
//------------------------------------------------------------------------------
sub CacheAdvertType()
    idleAdvType    = SRegGet(CfgId_IdleAdvertType)
    if idleAdvType == ADV_DIRECT_IND then
        //Idle mode adverts are not allowed to be ADV_DIRECT_IND
        idleAdvType = ADV_IND
    endif
endsub

//------------------------------------------------------------------------------
// On non VSP connection, this is used to send the confirming 'connect' message
//------------------------------------------------------------------------------
sub SendNonVspConnect(ndx as integer, byref bufferStr$)
    dim tmpStr$, info$, intrvl

    GetConnInfoRsp(connHandles[ndx], info$, intrvl)
    sprint #tmpStr$, "\nconnect ";ndx;", ";info$;"\r"

    bufferStr$ = bufferStr$ + tmpStr$
    atParse = 1

    //Send out data waiting in buffer
    SendUartData()
endsub

//------------------------------------------------------------------------------
// Used to send "RING " response on an incoming VSP connection
//------------------------------------------------------------------------------
sub SendRingRsp(hConn as integer, byref bufferStr$)
    dim addr$, isTrusted, keyInfo, rollAge, rollCount
    rc = BleGetAddrFromConnHandle(hConn, addr$)
    #cmpif 0x00000003 : AssertRC(1298)

    isTrusted = BleBondingIsTrusted(addr$, BOND_TRUSTED_AS_CENTRAL, keyInfo, rollAge, rollCount)

    addr$ = StrHexize$(addr$)
    bufferStr$ = bufferStr$ + "\nRING " + addr$

    if isTrusted then
        addr$ = ", T\r"
    else
        addr$ = ", U\r"
    endif

    bufferStr$ = bufferStr$ + addr$

    //Send out data waiting in buffer
    SendUartData()
endsub

//------------------------------------------------------------------------------
// For valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub SendNonVspDiscon(rsp as integer, ndx as integer, byref bufferStr$)
    sprint #tmpVar$, "\ndiscon ";ndx;", ";rsp;"\r"
    bufferStr$ = bufferStr$ + tmpVar$

    atParse = 1

    //Send out data waiting in buffer
    SendUartData()
endsub

//------------------------------------------------------------------------------
// This is sent on non_vsp states when scanning times out
//------------------------------------------------------------------------------
sub SendScanEnd(byref bufferStr$)
    bufferStr$ = bufferStr$ + "\nscanend\r"

    //Send out data waiting in buffer
    SendUartData()
endsub

//------------------------------------------------------------------------------
// This is sent when a passcode needs to be displayed
//------------------------------------------------------------------------------
sub SendDispPassKey(nCtx, npsky, Flags, byref bufferStr$)
    dim tmp$

    sprint #tmp$, "000000";npsky;"\r"

    //Get connection index from conn handle
    tmpVar = GetIdxFromHConn(nCtx)
    if tmpVar != HCONN_VSP then
        sprint #tmpVar$, tmpVar
    endif

    if (Flags == BLE_GAP_PASS_KEY_TYPE_PASSKEY) then
        bufferStr$ = bufferStr$ + "\nshowcode "
    elseif (Flags == BLE_GAP_PASS_KEY_TYPE_NUMERICAL_COMPARE) then
        bufferStr$ = bufferStr$ + "\ncomparecode "
    endif

    bufferStr$ = bufferStr$ + tmpVar$ + ", " + right$(tmp$, 7)

    //Send out data waiting in buffer
    SendUartData()
endsub

//------------------------------------------------------------------------------
// This is sent when an authkey is required and
// keytype = 1 for passcode (0 to 999999)
// keytype = 2 for 32 hex digit OOB key
//------------------------------------------------------------------------------
sub SendAuthInfoReq(nCtx, keyType, byref bufferStr$)
    dim tmp$

    //Get connection index from conn handle
    tmpVar = GetIdxFromHConn(nCtx)
    if tmpVar != HCONN_VSP then
        sprint #tmpVar$, tmpVar
    endif

    select keyType
    case BLE_GAP_AUTH_KEY_TYPE_PASSKEY
        tmp$ = "\npasskey?"

    case BLE_GAP_AUTH_KEY_TYPE_OOB
        tmp$ = "\noobkey?"

    case BLE_GAP_AUTH_KEY_TYPE_LESC_OOB
        tmp$ = "\nlescoob?"

    case else
        tmp$ = "\nxxkey?"
    endselect

    bufferStr$ = bufferStr$ + tmp$ + " " + tmpVar$ + "\r"

    //Send out data waiting in buffer
    SendUartData()
endsub

//------------------------------------------------------------------------------
// This is sent when OOB data is requested by the peer during LESC OOB pairing
// This data will be retrieved from the UART previously or during pairing attempt
// using the AT+OOBR command
//------------------------------------------------------------------------------
function SubmitRemoteOobData(byref srAddr$, byref srHash$, byref srRand$)
    if strlen(srAddr$) == 7 && strlen(srHash$) == 16 && strlen(srRand$) == 16 then
        rc = BleSecMngrLescPeerOobDataSet(srAddr$, srHash$, srRand$)
        if rc != RSP_OK then
            exitfunc rc
        endif
    else
        exitfunc RSP_ERROR_INVALID_OOBDATA
    endif
endfunc RSP_OK

//------------------------------------------------------------------------------
// Send 'Encrypt' message
//------------------------------------------------------------------------------
sub SendEncryptRsp(ndx, sendMsg, byref bufferStr$)
    dim msg$
    select sendMsg
    case 1
        msg$ = "\nENCRYPT\r"

    case 2
        sprint #msg$, "\nencrypt ";ndx;"\r"

    case else
    endselect
    if sendMsg > 0 then
        bufferStr$ = bufferStr$ + msg$
        //Send out data waiting in buffer
        SendUartData()
    endif
endsub

//------------------------------------------------------------------------------
//  8-bit S-Registers are 100-199
// 16-bit S-Registers are 200-299
// 32-bit S-Registers are 300-399
//------------------------------------------------------------------------------
function ATSRegGetValue(regnum, byref rspBuf$)
    if (regnum >= SREGNUM_START_8BIT) && (regnum < (SREGNUM_START_8BIT + SREG_MAXREGISTERS_8)) then
        //This is 8-bit register access
        regnum = regnum-SREGNUM_START_8BIT
    elseif (regnum >= SREGNUM_START_16BIT) && (regnum < (SREGNUM_START_16BIT + SREG_MAXREGISTERS_16)) then
        //This is 16-bit register access
        regnum = regnum + SREGNUM_OFFSET_16BIT - SREGNUM_START_16BIT
    elseif (regnum >= SREGNUM_START_32BIT) && (regnum < (SREGNUM_START_32BIT + SREG_MAXREGISTERS_32)) then
        //This is 32-bit register access
        regnum = regnum + SREGNUM_OFFSET_32BIT - SREGNUM_START_32BIT
    else
        exitfunc RSP_ERROR_INVALID_S_REG
    endif

    dim regval$
    sprint #regval$, SRegGet(regnum)
    rspBuf$ = rspBuf$ + "\n" + regval$ + "\r"
endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegSetValue(regnum, regVal)
    if (regnum >= SREGNUM_START_8BIT) && (regnum < (SREGNUM_START_8BIT + SREG_MAXREGISTERS_8)) then
        //This is 8-bit register access
        regnum = regnum-SREGNUM_START_8BIT
    elseif (regnum >= SREGNUM_START_16BIT) && (regnum < (SREGNUM_START_16BIT + SREG_MAXREGISTERS_16)) then
        //This is 16-bit register access
        regnum = regnum + SREGNUM_OFFSET_16BIT - SREGNUM_START_16BIT
    elseif (regnum >= SREGNUM_START_32BIT) && (regnum < (SREGNUM_START_32BIT + SREG_MAXREGISTERS_32)) then
        //This is 32-bit register access
        regnum = regnum + SREGNUM_OFFSET_32BIT - SREGNUM_START_32BIT
    else
        exitfunc RSP_ERROR_INVALID_S_REG
    endif

    //Check if valid range
    dim mn, mx
    mn = SRegGetRange(regnum, mx)
    if (regVal<mn) || (regVal>mx) then
        exitfunc RSP_ERROR_VALUE_OUT_OF_RANGE
    endif

    SRegSet(regnum, regVal)
endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegGetRange(regnum, byref rspBuf$)
    if (regnum >= SREGNUM_START_8BIT) && (regnum < (SREGNUM_START_8BIT + SREG_MAXREGISTERS_8)) then
        //This is 8-bit register access
        regnum = regnum-SREGNUM_START_8BIT
    elseif (regnum >= SREGNUM_START_16BIT) && (regnum < (SREGNUM_START_16BIT + SREG_MAXREGISTERS_16)) then
        //This is 16-bit register access
        regnum = regnum + SREGNUM_OFFSET_16BIT - SREGNUM_START_16BIT
    elseif (regnum >= SREGNUM_START_32BIT) && (regnum < (SREGNUM_START_32BIT + SREG_MAXREGISTERS_32)) then
        //This is 32-bit register access
        regnum = regnum + SREGNUM_OFFSET_32BIT - SREGNUM_START_32BIT
    else
        exitfunc RSP_ERROR_INVALID_S_REG
    endif

    dim regval$, mn, mx
    mn = SRegGetRange(regnum, mx)
    sprint #regval$, mn;"..";mx
    rspBuf$ = rspBuf$ + "\n" + regval$ + "\r"
endfunc RSP_OK

//------------------------------------------------------------------------------
// String S-Registers start at 0
//------------------------------------------------------------------------------
function ATSRegGetValueStr(regnum, byref rspBuf$)
    if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
        tmpVar$ = SRegGetStr$((regnum-SREGNUM_START_STR))
        rspBuf$ = rspBuf$ + "\n" + StrEscape$(tmpVar$) + "\r"
        exitfunc RSP_OK
    endif
endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegSetValueStr(regnum, regVal$)
    if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
        //Check if valid range
        dim mn, mx, len

        regnum = regnum - SREGNUM_START_STR

        //Get the valid min/max for this register
        mn = SRegGetStrSizeRange(regnum, mx)
        //De-escape the string
        StrDeEscape(regVal$)    //ensure escaped characters are converted to single binary values

        //Check for valid length
        len = strlen(regVal$)
        if (len<mn) || (len>mx) then
            exitfunc RSP_ERROR_VALUE_OUT_OF_RANGE
        endif

        //Perform further checking
        select regnum
        case CfgIdStr_VspServiceUUID128
            //This must only contain hex characters
            tmpVar$ = strdehexize$(regVal$)
            if strlen(tmpVar$) != 16 then
                exitfunc RSP_ERROR_INVALID_HEXSTR
            endif

        case else
        endselect

        SRegSet$(regnum, regVal$)
        exitfunc RSP_OK

    endif
endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegGetLenRangeStr(regnum, byref rspBuf$)
    if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
        dim tmp$, mn, mx
        mn = SRegGetStrSizeRange((regnum-SREGNUM_START_STR), mx)
        sprint #tmp$, mn;", ";mx
        rspBuf$ = rspBuf$ + "\n" + tmp$ + "\r"
        exitfunc RSP_OK
    endif
endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
// Change PHY per start-up flag
//------------------------------------------------------------------------------
function ChangePhy(connHandle)
    dim nPhyReq
    nPhyReq = ((startflags >> CONFIG_PHY_BIT_SHIFT) & CONFIG_PHY_BIT_MASK)
    select nPhyReq
        #cmpif 0x00100000 : case 1    // long-range 125 kbps
        #cmpif 0x00100000 :     nPhyReq = 4

    case 3     // 2MPHY
        nPhyReq = 2

    case else  // 1MPHY
        exitfunc 0

    endselect
    #cmpif 0x00000001 : print "\n## nPhyReq = ";nPhyReq
endfunc BlePhySet(connHandle, nPhyReq, nPhyReq, 0)

//------------------------------------------------------------------------------
// If advertising then return nonzero
//------------------------------------------------------------------------------
function IsAdvertising()
    if (sysinfo(2016) & 0x1) then
        exitfunc 1
    endif
endfunc 0

//------------------------------------------------------------------------------
// If scanning then return nonzero
//------------------------------------------------------------------------------
function IsScanning()
    if (sysinfo(2016) & 0x8) then
        exitfunc 1
    endif
endfunc 0

//------------------------------------------------------------------------------
// If advertising in progress stop it
//------------------------------------------------------------------------------
sub AdvertsStop()
    #cmpif 0x00000004 : DbgMsg("Called AdvertsStop()")
    if IsAdvertising() then
        rc = BleAdvertStop()
        #cmpif 0x00000003 : AssertRC(1615)
        #cmpif 0x00000004 : DbgMsg("Adverts Stopped")
    endif
endsub

//------------------------------------------------------------------------------
// If scanning in progress stop it
//------------------------------------------------------------------------------
sub ScanningStop()
    #cmpif 0x00000004 : DbgMsg("Called ScanningStop()")
    if IsScanning() then
        rc = BleScanStop()
        #cmpif 0x00000003 : AssertRC(1627)
        #cmpif 0x00000004 : DbgMsg("Scanning Stopped")
    endif
endsub

//------------------------------------------------------------------------------
// Stop & restart scanning
//------------------------------------------------------------------------------
function ScanningStart(tout, filter$, rsi, scntype)
    ScanningStop()
    if scntype & SCANTYPE_USE_SCANEX_FUNC_BITMASK then
        //Use the extended scanning function
        rc = BleScanStartEx(tout, scntype, "", EXTADV_FILTER_NONE)
    else
        //Use the legacy scanning function
        rc = BleScanStart(tout, ADV_FILTER_NONE)
    endif
    #cmpif 0x00000008 :     AssertRC(1644)

    //Set up the filtering parameters for the scan reporting
    if rc == 0 then
        scnPattern$     = filter$
        scnPatternLen = strlen(filter$)
        scnRssi             = rsi
    endif

//    #cmpif 0x00000004 : if rc == 0 then
//    #cmpif 0x00000004 :     DbgMsg    ("Scanning Started")
//    #cmpif 0x00000004 :     DbgMsgVal ("    Scan Tout (sec)=", tout)
//    #cmpif 0x00000004 :     DbgMsgVal$("    Scan Pattern   =", filter$)
//    #cmpif 0x00000004 :     DbgMsgVal ("    Scan Rssi (dBm)=", rsi)
//    #cmpif 0x00000004 : else
//    #cmpif 0x00000004 :     DbgMsg("Failed to start Scanning")
//    #cmpif 0x00000004 : endif
endfunc rc

//------------------------------------------------------------------------------
// Load VSP service defaults into sArg$[] and nArg[] to set things up as follows
//   sArg$[0] =
//   nArg[1]  = TxBufLen
//   nArg[2]  = RxBufLen
//   nArg[3]  = VspServiceUuid
//   nArg[4]  = RxUUID
//   nArg[5]  = TxUUID
//   nArg[6]  = MdmInUUID
//   nArg[7]  = MdmOutUUID
//   nArg[8]  = EncryptionReq (bit 0 set to encrypt, 1 set for MITM)
//------------------------------------------------------------------------------
sub VspGetDefs()
    dim tmpStr$

    //Get Tx & Rx buffer sizes
    nArg[ArgIDTxBufLen] = SRegGet(CfgId_VspTxBufSize)
    nArg[ArgIDRxBufLen] = SRegGet(CfgId_VspRxBufSize)

    //If DLE is enabled or 2MPHY is selected, testing has shown that we need to
    //increase the size of the VSP Rx buffer otherwise things go pear shaped because we need to cater to
    // up to 6 (or more) packets to arrive in a single connection interval. In that case if there is no
    //space to save the new data, then then only option is to just dump it which is seen as a loss of data.
    //In future we can refactor the VSP functionality in this app by NOT using the BleVspXXX() helper functions
    //but leverage the fact that we now have the ability to send STRING data in event messages and so this
    //issue can only arise if the heap is running low.
    if (startflags & CONFIG_VSP_BIT_MASK) != 0 then
        //We need to increase the size of the VSP rxbuffer if it is too small
        tmpVar = vspCachedPkts * dleAttrSz
        if tmpVar > nArg[ArgIDRxBufLen] then
            nArg[ArgIDRxBufLen] = tmpVar
            //#cmpif 0x00000004 : DbgMsgVal("Increased VSP Rxbuf Size to ", tmpVar)
        endif
    endif

    //Get UUID handles for Service and the 4 Characteristics
    tmpStr$ = SRegGetStr$(CfgIdStr_VspServiceUUID128)
    tmpStr$ = StrDehexize$(tmpStr$)
    nArg[ArgIDVspServiceUuid] = BleHandleUuid128(tmpStr$)    //VspServiceUuid
    nArg[ArgIDRxUUID] = BleHandleUuidSibling(nArg[ArgIDVspServiceUuid], SRegGet(CfgId_VspRxUUID))
    nArg[ArgIDTxUUID] = BleHandleUuidSibling(nArg[ArgIDVspServiceUuid], SRegGet(CfgId_VspTxUUID))
    nArg[ArgIDMdmInUUID] = BleHandleUuidSibling(nArg[ArgIDVspServiceUuid], SRegGet(CfgId_VspMdmInUUID))
    nArg[ArgIDMdmOutUUID] = BleHandleUuidSibling(nArg[ArgIDVspServiceUuid], SRegGet(CfgId_VspMdmOutUUID))

    //Get EncryptionReq
    nArg[ArgIDEncryptionReq] = SRegGet(CfgId_Encrypt)
endsub

//------------------------------------------------------------------------------
// Open VSP service using sArg$[] and nArg[] as per VspGetDefs()
//------------------------------------------------------------------------------
function VspOpen()
    dim vspFlags

    //Update VSP flags variable
    if ((nArg[ArgIDEncryptionReq] & CONFIG_ENCRYPTION_ENABLED) == CONFIG_ENCRYPTION_ENABLED) then
        //Connection encryption is enabled, get timer value
        encDisconTime = SRegGet(CfgId_EncrDisconToutMs)
        if ((nArg[ArgIDEncryptionReq] & CONFIG_MITM_ENABLED) == CONFIG_MITM_ENABLED) then
            //MITM required
            vspFlags = VSP_OPEN_MITM_REQUIRED
        else
            //MITM not required
            vspFlags = VSP_OPEN_MITM_NOT_REQUIRED
        endif
    else
        //VSP encryption is disabled, disable timer
        encDisconTime = 0
        vspFlags = 0
    endif

    //Save the service UUID handle so that we can use it when creating the advert report
    handleVspServiceUuid = nArg[ArgIDVspServiceUuid]

    //Open the VSP service with the provided configuration
    //#cmpif 0x00000004 : DbgMsgVal("VSP Txbuf Size ", nArg[1])
    //#cmpif 0x00000004 : DbgMsgVal("VSP Rxbuf Size ", nArg[2])
    rc = BleVSPOpenEx(nArg[ArgIDTxBufLen], nArg[ArgIDRxBufLen], vspFlags, nArg[ArgIDVspServiceUuid], nArg[ArgIDRxUUID], nArg[ArgIDTxUUID], nArg[ArgIDMdmInUUID], nArg[ArgIDMdmOutUUID])
    #cmpif 0x00000003 : AssertRC(1741)
    if rc == 0 then
        vspAdded = 1
    endif
endfunc rc

//------------------------------------------------------------------------------
// Create a generic minimal advert
//------------------------------------------------------------------------------
sub GenAdvCreateMinimal(byref advRpt$, byref scRpt$)
    dim flgsAD, nAppearance

    flgsAD      = SRegGet(CfgId_VspFlagsAD)
    nAppearance = SRegGet(CfgId_Appearance)

    rc = BleAdvRptInit(advRpt$, flgsAD, nAppearance, MaxDevNameSize)
    #cmpif 0x00000003 : AssertRC(1757)

    rc = BleScanRptInit(scRpt$)
    #cmpif 0x00000003 : AssertRC(1760)
endsub

//------------------------------------------------------------------------------
// The advert report for the VSP service
//------------------------------------------------------------------------------
sub VspAdvCreateCommit()
    //Add device name to advert report and service UUID to scan report
    dim advRpt$, scRpt$

    GenAdvCreateMinimal(advRpt$, scRpt$)

    #cmpif 0x00000003 : AssertNE(handleVspServiceUuid, 0, 1719)

    if vspLongRange then
        //Advertise for VSP on LE_CODED
        rc = BleAdvSetCreate(SETID_DEFAULT , EXTADVPROP_CONNpEXT , EXTADVPRIPHY_LECODED , EXTADV_FILTER_NONE , emptyAddr$ , "")
        #cmpif 0x00000003 : AssertRC(1777)
        rc = BleExtAdvRptAddUuid128(advRpt$, handleVspServiceUuid, INVALID_UUID_HANDLE, INVALID_UUID_HANDLE, INVALID_UUID_HANDLE, INVALID_UUID_HANDLE, INVALID_UUID_HANDLE)
        #cmpif 0x00000003 : AssertRC(1779)
        rc = BleAdvSetNewData(SETID_DEFAULT, advRpt$, scRpt$)
    else
        //Advertise for VSP on 1MPHY
        rc = BleAdvRptAddUuid128(scRpt$, handleVspServiceUuid)
        #cmpif 0x00000003 : AssertRC(1784)
        rc = BleAdvRptsCommit(advRpt$, scRpt$)
    endif
    #cmpif 0x00000003 : AssertRC(1787)

    #cmpif 0x00000001 : print "\n## VspAdv ";strhexize$(advRpt$)
    #cmpif 0x00000001 : print "\n## VspScn ";strhexize$(scRpt$)
endsub

//------------------------------------------------------------------------------
// BLE advertising for central devices to connect to for VSP service
//------------------------------------------------------------------------------
sub VspStartAdverts()
    tmpDta = SRegGet(CfgId_VspAdvertIntvlMs)
    if vspLongRange then
        //Advertise for VSP on LE_CODED
        rc = BleAdvSetStart(SETID_DEFAULT , tmpDta , ADV_DURATION_FOREVER , EXTADV_MAXCOUNT_NONE , AUXOFFSET_DEFAULT)
        if rc == 0 then
            fExtAdvertising = TRUE
        endif
    else
        //Advertise for VSP on 1MPHY
        rc = BleAdvertStart(ADV_IND, emptyAddr$, tmpDta, ADV_DURATION_FOREVER, ADV_FILTER_NONE)
        if rc == 0 then
            fExtAdvertising = FALSE
        endif
    endif
    #cmpif 0x00000003 : AssertRC(1811)
    #cmpif 0x00000004 : DbgMsg("Vsp Adverts Started")
endsub

//------------------------------------------------------------------------------
// Create minimal idle advert/scan reports
//------------------------------------------------------------------------------
sub IdleAdvCreate()
    GenAdvCreateMinimal(idleAdvRpt$, idleScnRpt$)
endsub

//------------------------------------------------------------------------------
// Commit the idle mode advert reports
//------------------------------------------------------------------------------
sub IdleAdvCommit()

    #cmpif 0x00000001 : print "\n## IdlAdv ";strhexize$(idleAdvRpt$)
    #cmpif 0x00000001 : print "\n## IdlScn ";strhexize$(idleScnRpt$)

    if fExtAdvertising then
        rc = BleAdvSetNewData(SETID_DEFAULT, idleAdvRpt$, idleScnRpt$)
    else
        rc = BleAdvRptsCommit(idleAdvRpt$, idleScnRpt$)
    endif
    #cmpif 0x00000003 : AssertRC(1835)
endsub

//------------------------------------------------------------------------------
// BLE advertising for central devices to connect to for VSP service
//------------------------------------------------------------------------------
sub IdleStartAdverts(advType, adIntervalMs)
    rc = BleAdvertStart(advType, emptyAddr$, adIntervalMs, ADV_DURATION_FOREVER, ADV_FILTER_NONE)
    #cmpif 0x00000003 : AssertRC(1843)
    #cmpif 0x00000004 : DbgMsg("Idle Adverts Started")
    if rc == 0 then
        fExtAdvertising = FALSE
    endif
endsub

//------------------------------------------------------------------------------
// Call this to assert the DCD state when there is a VSP connection
//------------------------------------------------------------------------------
sub VspDcdAssert()
    if vspDcdPin >= 0 then
        GpioWrite(vspDcdPin, DCD_ASSERT_STATE)
    endif
endsub

//------------------------------------------------------------------------------
// Call this to de-assert the DCD state when there is a VSP disconnection
//------------------------------------------------------------------------------
sub VspDcdDeassert()
    if vspDcdPin >= 0 then
        GpioWrite(vspDcdPin, DCD_DEASSERT_STATE)
    endif
endsub

//------------------------------------------------------------------------------
// Call this to assert the active conn pin
//------------------------------------------------------------------------------
sub SioConnAssert()
    if sioConnActivePin >= 0 then
        GpioWrite(sioConnActivePin, sioConnAssertState)
    endif
endsub

//------------------------------------------------------------------------------
// Call this to deassert the active conn pin
//------------------------------------------------------------------------------
sub SioConnDeassert()
    if sioConnActivePin >= 0 then
        GpioWrite(sioConnActivePin, !sioConnAssertState)
    endif
endsub

//------------------------------------------------------------------------------
// Call this to assert the encrypted conn pin
//------------------------------------------------------------------------------
sub SioEncrAssert()
    if sioConnEncryptedPin >= 0 then
        GpioWrite(sioConnEncryptedPin, sioEncrAssertState)
    endif
endsub

//------------------------------------------------------------------------------
// Call this to deassert the encrypted conn pin
//------------------------------------------------------------------------------
sub SioEncrDeassert()
    dim i, enc
    if sioConnEncryptedPin >= 0 then
        enc = FALSE  //We start assuming no encrypted connections
        for i = 1 to MAX_CONNECTIONS
            if connIsEncrypted[i] == TRUE then
                enc = TRUE  //We found one encrypted connection
                break
            endif
        next
        if enc == FALSE then  //If loop ended without encrypted connection
            GpioWrite(sioConnEncryptedPin, !sioEncrAssertState)
        endif
    endif
endsub

//------------------------------------------------------------------------------
// Currently only need to initialise the GPIO for vspCmdMode Pin in Fast mode
// or when low power UART operation is compile time enabled then the same pin
// is used by the host to reopen the UART
//------------------------------------------------------------------------------
sub InitGPIO()
    //Cache the command mode pin
    vspCmdModePin = SRegGet(CfgId_VspCmdModePin)

    #cmpif 0x00400000 : //Set Lowpower pin to default if not overriden in SReg
    #cmpif 0x00400000 : if vspCmdModePin<0 then
    #cmpif 0x00400000 :     vspCmdModePin = UART_DEFAULT_LOWPWR_CMDPIN
    #cmpif 0x00400000 : endif

    if vspCmdModePin >= 0 then
        //Set it as input
        rc = GpioSetFunc(vspCmdModePin, SIOTYPE_DIN, INPUT_PULL_UP)
        #cmpif 0x00000003 : AssertRC(1931)

        if fLowPowerUart then
            //And arrange so that we will get an event each time it goes from 0 to 1
            //because when that pin is high, it means host wants to force the UART to
            //be open
            rc = GpioSetFunc(vspCmdModePin, SIOTYPE_DIN, INPUT_PULL_DOWN)
            #cmpif 0x00000003 : AssertRC(1938)

            rc = GpioAssignEvent(0, vspCmdModePin, 0)
        else
            //And arrange so that we will get an event each time it goes from 1 to 0
            rc = GpioSetFunc(vspCmdModePin, SIOTYPE_DIN, INPUT_PULL_UP) //pullup resistor
            #cmpif 0x00000003 : AssertRC(1944)

            rc = GpioAssignEvent(0, vspCmdModePin, 1)
        endif
        #cmpif 0x00000003 : AssertRC(1948)

    endif

    //Cache the command mode pin and set as output if one specified
    vspDcdPin = SRegGet(CfgId_VspDcdPin)
    if vspDcdPin >= 0 then
        //Set it as an output
        rc = GpioSetFunc(vspDcdPin, SIOTYPE_DOUT, DCD_DEASSERT_STATE)
        #cmpif 0x00000003 : AssertRC(1957)
    endif

    //Cache the connection indication pins polarity
    tmpVar = SRegGet(CfgId_CONNENCRPol)
    sioConnAssertState = (tmpVar & 0x01) >> 0
    sioEncrAssertState = (tmpVar & 0x02) >> 1

    //Cache the active connection indication pin and set as output if one specified
    sioConnActivePin = SRegGet(CfgId_CONNPin)
    if sioConnActivePin >= 0 then
        rc = GpioSetFunc(sioConnActivePin, SIOTYPE_DOUT, !sioConnAssertState)
        #cmpif 0x00000003 : AssertRC(1969)
    endif

    //Cache the encrypted connection indication pin and set as output if one specified
    sioConnEncryptedPin = SRegGet(CfgId_ENCRPin)
    if sioConnEncryptedPin >= 0 then
        rc = GpioSetFunc(sioConnEncryptedPin, SIOTYPE_DOUT, !sioEncrAssertState)
        #cmpif 0x00000003 : AssertRC(1976)
    endif
endsub

//------------------------------------------------------------------------------
// Common code when returning to one of the idle states
//------------------------------------------------------------------------------
sub IdleReturnAction()
    dim scanPat$
    //#cmpif 0x00000004 : DbgMsgVal("IdleReturn - Radio", sysinfo(2016))
    //#cmpif 0x00000004 : DbgMsgVal("OldIdleState=", oldIdleState)

    select oldIdleState
    case STATE_IDLE_VSP
        //Create the VSP related Advert report and scan report and commit
        VspAdvCreateCommit()
        //Start Advertising
        VspStartAdverts()

    case STATE_IDLE_nonVSP
        advPrefix$ = "\nAD0:"

    case else
        //Nothing to do
        //#cmpif 0x00000004 : DbgMsg("IdleReturn - unknown")
    endselect

    //Change state
    NewState(oldIdleState)
endsub

//------------------------------------------------------------------------------
// Called from a handler when VSP connection fails
//------------------------------------------------------------------------------
sub VspNoCarrierRet(rsp)
    IdleReturnAction()  //Will change state to one of IDLE, IDLE_VSP, IDLE_ADV

    //Send an NOCARRIER response
    AppendConnRspEnd(rsp, UARTSndBuf$)
    //Send out data waiting in buffer
    SendUartData()
    //Also trigger a reprocessing of the UART buffer just in case
    rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
endsub

//------------------------------------------------------------------------------
// Called from a handler when nonVSP connection fails
//------------------------------------------------------------------------------
sub NonVspDisconRet(rsp, ndx)
    IdleReturnAction()  //Will change state to one of IDLE, IDLE_VSP, IDLE_ADV

    //Send an DISCON response
    SendNonVspDiscon(rsp, ndx, UARTSndBuf$)

    //Also trigger a reprocessing of the UART buffer just in case
    rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
endsub

//--------------------------------------------------------------------------
// Given a connection handle, returns 0 if not connected to a trusted device
// otherwise 1 for unauthenticated pairing and 2 for authenticated
// This is called on when making an outgoing VSP Connection
//--------------------------------------------------------------------------
function IsTrustedPeer(hConn)
    dim kInfo, rAge, rCount, klen
    dim curAddr$

    //Get address of connected device
    rc = BleGetAddrFromConnHandle(hConn, curAddr$)
    #cmpif 0x00000003 : AssertRC(2045)
    #cmpif 0x00000004 : dim a$ : a$ = StrHexize$(curAddr$)
    #cmpif 0x00000004 : DbgMsgVal$("Master Addr = ", a$)

    //Check if device is trusted
    klen = BleBondingIsTrusted(curAddr$, BOND_TRUSTED_AS_CENTRAL, kInfo, rAge, rCount)

    if klen > 0 then
        //It is trusted and for Phase 1 ignore the authentication stuff
        //#cmpif 0x00000004 : print "\n## Peer is trusted "
        //#cmpif 0x00000004 : if (kInfo & BONDING_KEYINFO_MITM_AUTHENTICATED) != 0 then
        //#cmpif 0x00000004 :     print "(Authenticated)"
        //#cmpif 0x00000004 : endif

        if (kInfo & BONDING_KEYINFO_MITM_AUTHENTICATED) != 0 then
            //It is an authenticated bond, reuse kInfo variable for return value
            kInfo = 2
        else
            //It is not an authenticated bond, reuse kInfo variable for return value
            kInfo = 1
        endif
    else
        //Not trusted, reuse kInfo variable for return value
        #cmpif 0x00000004 : print "\n## Peer is NOT trusted "
        kInfo = 0
    endif
endfunc kInfo

//------------------------------------------------------------------------------
// Open the GATT client, returns a nonzero error code
//------------------------------------------------------------------------------
function GattClientOpen()
    if fGattClient == 0 then
        rc = BleGattcOpen(SRegGet(CfgId_GattClientMemSize), 0)
        if rc > 0 then
            rc = CONN_ERROR_OUTOFMEM
        else
            fGattClient = 1
            //#cmpif 0x00000004 : DbgMsg("GattClientOpen")
        endif
    else
        rc = RSP_OK
        //#cmpif 0x00000004 : DbgMsg("GattClient was Open")
    endif
endfunc rc

//------------------------------------------------------------------------------
// vspFindIndex is the index into the query array
//------------------------------------------------------------------------------
function FindCharOrDesc()
    //#cmpif 0x00000004 : DbgMsgVal("FindCharOrDesc Idx=", vspFindIndex)

    dim cccdUuid : cccdUuid = hVspCccdUuids[vspFindIndex]
    dim charUuid : charUuid = nArg[vspFindIndex]

    if cccdUuid == 0 then
        //Find char
        //#cmpif 0x00000004 : DbgMsg("BleGattcFindChar")
        rc = BleGattcFindChar(connHandles[HCONN_VSP], vspSvcUuid, 0, charUuid, 0)
    else
        //Find desc
        //#cmpif 0x00000004 : DbgMsg("BleGattcFindDesc")
        rc = BleGattcFindDesc(connHandles[HCONN_VSP], vspSvcUuid, 0, charUuid, 0, cccdUuid, 0)
    endif
    #cmpif 0x00000003 : AssertRC(2109)
endfunc rc

//------------------------------------------------------------------------------
// vspFindIndex is the index into the query array
// returns 0 if no more cccd's in the array
//------------------------------------------------------------------------------
function CccdsEnable()
    //#cmpif 0x00000004 : DbgMsgVal("CccdsEnable, idx=", vspFindIndex)
    dim i, hAttr
    //First find the first cccd
    for i = vspFindIndex to (VSP_ATTR_MAX_INDEXES-1)
        if hVspCccdUuids[i] != 0 then
            //This array index is for a cccd so get the attribute handle for it
            hAttr = hVspAttr[i]
            if hAttr != 0 then
                #cmpif 0x00000004 : print "\n## BleGattcWrite, hAttr =";hAttr;" i=";i
                //Found attr handle for a cccd
                tmpVar$ = "\01\00"
                rc = BleGattcWrite(connHandles[HCONN_VSP], hAttr, tmpVar$)
                #cmpif 0x00000003 : AssertRC(2129)
                vspFindIndex = i
                exitfunc 1
            endif
        endif
    next
    //Reaching here means no more cccd's to enable
endfunc 0

//------------------------------------------------------------------------------
// Setup array of chars+ desc that need to be found in the slave
//------------------------------------------------------------------------------
function GetVspHandles()
    dim i
    //Get VSP uuids and other values into nArg[]
    VspGetDefs()
    //   nArg[3]  = VspServiceUuid
    //   nArg[4]  = RxUUID          //0
    //   nArg[5]  = TxUUID          //1
    //   nArg[6]  = MdmInUUID       //2
    //   nArg[7]  = MdmOutUUID      //3
    vspSvcUuid = nArg[3]
    //Shuffle values in the nArg arrays as we are going to reuse it.
    for i = 0 to 3
        nArg[i] = nArg[i + 4]
    next
    //   nArg[0]  = RxUUID/0        //0
    //   nArg[1]  = TxUUID/0        //1
    //   nArg[2]  = MdmInUUID/0     //2
    //   nArg[3]  = MdmOutUUID/0    //3
    //   nArg[4]  = TxUUID/CCCD     //4
    //   nArg[5]  = MdmOutUUID/CCCD //5
    for i = 0 to (VSP_ATTR_MAX_INDEXES-1)
        hVspCccdUuids[i] = 0
        hVspAttr[i] = 0  //Assume all are optional
    next
    //The RX and TX characteristic are mandatory
    hVspAttr[VSP_ATTR_INDEX_RX]      = 1
    hVspAttr[VSP_ATTR_INDEX_TX]      = 1
    hVspAttr[VSP_ATTR_INDEX_TX_CCCD] = 1
    //The TX is capable of being notified
    nArg[VSP_ATTR_INDEX_TX_CCCD]     = nArg[VSP_ATTR_INDEX_TX]   //UUID handle
    hVspCccdUuids[VSP_ATTR_INDEX_TX_CCCD] = BleHandleUuid16(0x2902)
    //The MdmOut is capable of being notified
    nArg[VSP_ATTR_INDEX_MDMOUT_CCCD] = nArg[VSP_ATTR_INDEX_MDMOUT]  //UUID handle
    hVspCccdUuids[VSP_ATTR_INDEX_MDMOUT_CCCD] = hVspCccdUuids[VSP_ATTR_INDEX_TX_CCCD]

    //Now trigger the query to find the chars and descriptors
    vspFindIndex = 0
endfunc FindCharOrDesc()

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub VspEnterConnState(msgId)
    if (vspCmdModePin >= 0) && (fLowPowerUart == 0) then
        //We want fast mode of operation and not in low power operation
        if GpioRead(vspCmdModePin) == 0 then
            //Just disconnect
            vspDisconSts = CONN_ERROR_CMDPINSTATE
            //Some other error, so just drop the connection
            rc = BleDisconnect(connHandles[HCONN_VSP])
            //Change state
            NewState(STATE_VSP_DISCONNECTING)
            exitsub
        else
            #cmpif 0x00000004 : DbgMsg("Going For FAST")
            rc = SendMsgApp(msgId, STATE_VSP_FAST_CONNECTED)
        endif
    else
        //We want ^^^ mode of operation
        #cmpif 0x00000004 : DbgMsg("Going For CARET")
        rc = SendMsgApp(msgId, STATE_VSP_CARET_CONNECTED)
    endif
    #cmpif 0x00000003 : AssertRC(2202)

    //Negotiate ATT_MTU if ATS213 is not the default minimum value
    if vspIsOutGoing != FALSE then
        if vspAttrMaxLen > DEFAULT_ATTRIBUTE_SIZE then
            rc = BleGattcAttributeMtuRequest(connHandles[HCONN_VSP])
            #cmpif 0x00000001 : print "\n## BleGattcAttributeMtuRequest() ret:";integer.h' rc
        else
            rc = ChangePhy(connHandles[HCONN_VSP])
            #cmpif 0x00000001 : print "\n## ChangePhy() ret:";integer.h' rc
        endif
    endif
    #cmpif 0x00000040 : vtxcnt = 0 : vrxcnt = 0
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub OnVspConnCommon(hConn)
    connHandles[HCONN_VSP] = hConn

    vspDisconSts = CONN_SUSPEND //Assume normal disconnection will happen
    vspEscCount = 0

    //Set default chuck size, it will be negotiated and updated after there is a VSP connection
    vspChunkLen = DEFAULT_ATTRIBUTE_SIZE
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub OnNonVspConnection(hConn)
    dim nodeIdx

    nodeIdx = GetFreeIdx()
    if nodeIdx == 0 then
        //Disconnect immediately
        rc = BleDisconnect(hConn)
        #cmpif 0x00000003 : AssertRC(2238)
    else
        //Cache the connection handle
        connHandles[nodeIdx] = hConn
        connIsEncrypted[nodeIdx] = FALSE
        //Send an CONNECT response
        SendNonVspConnect(nodeIdx, UARTSndBuf$)
        //Change state
        NewState(STATE_nonVSP_CONNECTED)
        //For now, do not process any incoming
             //
             //OnEvent EVATTRNOTIFY Disable
             //
        //need to process more
        rc = SendMsgApp(MSGAPP_ENTER_NONVSP_CONN_STATE, NULL_CTX)
    endif
endsub

//------------------------------------------------------------------------------
// Called on Connection
//------------------------------------------------------------------------------
sub OnConnect(hConn)
    #cmpif 0x00000004 : DbgMsg("Connect")
    #cmpif 0x00000008 : ShowConnParms(hConn)

    //Increment the connection count
    connCount = connCount + 1

    select curState
    case STATE_IDLE_VSP
        //Send a RING response
        SendRingRsp(hConn, UARTSndBuf$)
        //Action common stuff for VSP whether in our outgoing
        OnVspConnCommon(hConn)
        //Flush the VSP buffers just in case there is stuff from previous connections
        BleVspFlush(3)
        //Incoming VSP connection
        SaveState(oldIdleState)
        if encDisconTime != 0 then
            //We expect an encrypted connection
            #cmpif 0x00000004 : DbgMsgVal("Enc Required, Timer(ms)=", encDisconTime)
            TimerStart(TMRNUM_ENCR_WAIT, encDisconTime, 0)
            NewState(STATE_VSP_IN_WAIT_ENCR)
        else
            //No encryption required for this connection
            #cmpif 0x00000004 : DbgMsg("Enc NOT Required")
            vspIsOutGoing = FALSE
            VspEnterConnState(MSGAPP_ENTER_VSPIN_CONN_STATE)
        endif

    case STATE_VSP_CONNECTING
        //Action common stuff for VSP whether in our outgoing
        OnVspConnCommon(hConn)
        //Is this a trusted peer
        if IsTrustedPeer(hConn) > 0 then
            //Peer is trusted
            rc = BleEncryptConnection(hConn, LTK_MINIMUM_SIZE, BLE_ENCRYPT_MITM_NOT_REQUIRED)
            #cmpif 0x00000004 : DbgMsg("Encrypting..")
            //Change state
            NewState(STATE_VSP_WAIT_ENCRYPT)
        else
            //Peer is not trusted
            rc = GetVspHandles()
            //Change state
            NewState(STATE_VSP_GET_HANDLES)
        endif

    case STATE_IDLE_nonVSP
        //New connection so need to create a indx handle
        //incoming nonVSP connection
        SaveState(oldIdleState)
        OnNonVspConnection(hConn)

    case STATE_nonVSP_CONNECTING
        //New connection so need to create a indx handle
        OnNonVspConnection(hConn)

	case STATE_nonVSP_CONNECTED
        //Already connected but new incoming connection so need to create a indx handle
        OnNonVspConnection(hConn)

    case else
    endselect
endsub

//------------------------------------------------------------------------------
// Called on connection going encrypted
//------------------------------------------------------------------------------
sub OnEncrypted(hConn)
    dim sendMsg : sendMsg = 1
    dim nIdx : nIdx = HCONN_VSP
    #cmpif 0x00000004 : DbgMsg("Encrypted")

    select curState
    case STATE_VSP_IN_WAIT_ENCR
        vspIsOutGoing = FALSE
        VspEnterConnState(MSGAPP_ENTER_VSPIN_CONN_STATE)

    case STATE_VSP_WAIT_ENCRYPT
        //Peer is not trusted
        rc = GetVspHandles()
        //Change state
        NewState(STATE_VSP_GET_HANDLES)

    case STATE_VSP_PAIRING
        //Successful just works pairing
        rc = CccdsEnable()
        //Change state
        NewState(STATE_VSP_WRITE_CCCDS)

    case STATE_nonVSP_CONNECTED
        nIdx = GetIdxFromHConn(hConn)
        connIsEncrypted[nIdx] = TRUE
        sioEncrAssert()
        sendMsg = 2

    case else
        sendMsg = 0
    endselect

    //Conditionally send "ENCRYPT" message
    SendEncryptRsp(nIdx, sendMsg, UARTSndBuf$)
endsub

//------------------------------------------------------------------------------
// Called when connection failed to encrypt
//------------------------------------------------------------------------------
sub OnUnencrypted(hConn)
    #cmpif 0x00000004 : DbgMsg("Failed to Encrypt")

    select curState
    case STATE_VSP_WAIT_ENCRYPT, STATE_VSP_PAIRING
        vspDisconSts = CONN_ERROR_UNENCRYPTED
        //Some other error, so just drop the connection
        rc = BleDisconnect(hConn)
        //Change state
        NewState(STATE_VSP_DISCONNECTING)

    case STATE_nonVSP_CONNECTED
        //Some other error, so just drop the connection
        rc = BleDisconnect(hConn)
        //Remain in state

    case else
    endselect
endsub

//------------------------------------------------------------------------------
// Called when asked to display passkey which is in nCTx
//------------------------------------------------------------------------------
function HandlerPassKey(nCtx, PassKey, Flags)
    #cmpif 0x00000004 : DbgMsgVal("Display Passkey = ", Passkey)

    select curState
    case STATE_VSP_IN_WAIT_ENCR
        vspDisconSts = CONN_ERROR_PAIRUI
        //Some other error, so just drop the connection
        rc = BleDisconnect(connHandles[HCONN_VSP])
        //Change state
        NewState(STATE_VSP_DISCONNECTING)

    case STATE_nonVSP_CONNECTED
        SendDispPassKey(nCtx, Passkey, Flags, UARTSndBuf$)

    case else
    endselect
endfunc 1

//------------------------------------------------------------------------------
// Called when asked for auth key request. nCTx is type of key requested
//------------------------------------------------------------------------------
function HandlerAuthKey(nCtx, Type, Flags)
    #cmpif 0x00000004 : DbgMsgVal("Auth Key Request, type = ", nCtx)
    #cmpif 0x00000004 : DbgMsgVal("Auth Key Request = ", nCtx)

    select curState
    case STATE_VSP_IN_WAIT_ENCR
        vspDisconSts = CONN_ERROR_PAIRUI
        //Some other error, so just drop the connection
        rc = BleDisconnect(connHandles[HCONN_VSP])
        //Change state
        NewState(STATE_VSP_DISCONNECTING)

    case STATE_nonVSP_CONNECTED
        SendAuthInfoReq(nCtx, Type, UARTSndBuf$)

    case else
    endselect
endfunc 1

//------------------------------------------------------------------------------
// Called when packet length is limited from an MTU exchange
//------------------------------------------------------------------------------
function HandlerPacketLengthLimited(nCtx, TxRxTimeReducedBy, TxSizeReducedBy, RxSizeReducedBy)
    #cmpif 0x00000010 : print "\n## BLE PACKET LENGTH LIMITED: (TxRxTimeReducedBy = ";TxRxTimeReducedBy;" TxSizeReducedBy = ";TxSizeReducedBy;" RxSizeReducedBy = ";RxSizeReducedBy;")"

    //Get connection index from conn handle and send async response if non-VSP
    tmpVar = GetIdxFromHConn(nCtx)
    if tmpVar != HCONN_VSP then
        sprint #tmpVar$, "\nLL:";tmpVar;", ";TxRxTimeReducedBy;", ";TxSizeReducedBy;", ";RxSizeReducedBy;"\r"
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//------------------------------------------------------------------------------
// Called when Tx power is limited due to regulatory requirements
//------------------------------------------------------------------------------
#cmpif    0x80000000 : function HandlerTxPowerLimited(nCtx, TxPower)
#cmpifand 0x80000010 :     print "\n## BLE TX POWER LIMITED: (TxPower = ";TxPower;")"
#cmpif    0x80000000 : 
#cmpif    0x80000000 :     //Get connection index from conn handle and send async response if non-VSP
#cmpif    0x80000000 :     tmpVar = GetIdxFromHConn(nCtx)
#cmpif    0x80000000 :     if tmpVar != HCONN_VSP then
#cmpif    0x80000000 :         sprint #tmpVar$, "\nPL:";tmpVar;", ";TxPower;"\r"
#cmpif    0x80000000 :         SendUartDataEx(tmpVar$)
#cmpif    0x80000000 :     endif
#cmpif    0x80000000 : endfunc 1

//------------------------------------------------------------------------------
// Called when authorisation information from a pairing occurs
//------------------------------------------------------------------------------
function HandlerAuthInfo(nCtx, Code, Source, Flags, KeyExchange, SecurityModeLevels)
    #cmpif 0x00000010 : print "\n## BLE AUTHORISATION INFO: (Code = ";Code;" Source = ";Source;" Flags = ";integer.h'Flags;" KeyExchange = ";integer.h'KeyExchange;" SecurityModeLevels = ";integer.h'SecurityModeLevels;")"

    //Get connection index from conn handle and send async response if non-VSP
    tmpVar = GetIdxFromHConn(nCtx)
    if tmpVar != HCONN_VSP then
        sprint #tmpDta$, integer.h'Flags
        RemoveZeros(tmpDta$)
        sprint #tmpVar$, "\nPI:";tmpVar;", ";Code;", ";Source;", ";tmpDta$;", "

        sprint #tmpDta$, integer.h'SecurityModeLevels
        RemoveZeros(tmpDta$)
        tmpVar$ = tmpVar$ + tmpDta$ + "\r"

        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//------------------------------------------------------------------------------
// Called when there is an incoming security request event
//------------------------------------------------------------------------------
function HandlerSecurityRequest(nCtx, Flags)
    #cmpif 0x00000010 : print "\n## BLE SECURITY REQUEST: (Flags = ";Flags;")"

    //Get connection index from conn handle and send async response if non-VSP
    tmpVar = GetIdxFromHConn(nCtx)
    if tmpVar != HCONN_VSP then
        sprint #tmpDta$, integer.h'Flags
        RemoveZeros(tmpDta$)
        sprint #tmpVar$, "\nSR:";tmpVar;", ";tmpDta$;"\r"
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//------------------------------------------------------------------------------
// Called when there is a bond overwrite event
//------------------------------------------------------------------------------
function HandlerOverwriteBond(nCtx, Flags, BYVAL Addr$)
    #cmpif 0x00000010 : print "\n## BLE OVERWRITE BOND: (Flags = ";integer.h'Flags;" Addr$ = ";strhexize$(Addr$);")"

    //Get connection index from conn handle and send async response if non-VSP
    tmpVar = GetIdxFromHConn(nCtx)
    if tmpVar != HCONN_VSP then
        sprint #tmpDta$, integer.h'Flags
        RemoveZeros(tmpDta$)
        sprint #tmpVar$, "\nOB:";tmpVar;", ";tmpDta$;", ";strhexize$(Addr$);"\r"
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//------------------------------------------------------------------------------
// Called from finddesc and findchar event handlers in VSP mode
//------------------------------------------------------------------------------
sub SvcFindCharDescEv(hConn, hAttr)
    if hAttr == 0 then
        //Did not find the attribute, so check if it was mandatory
        if hVspAttr[vspFindIndex] != 0 then
            //This was a mandatory attribute so something went wrong hence abort
            vspDisconSts = CONN_ERROR_NOVSPSERVICE
            //Some other error, so just drop the connection
            rc = BleDisconnect(hConn)
            //Change state
            NewState(STATE_VSP_DISCONNECTING)
            exitsub
        endif
    endif

    //Save the attribute and check if more to find
    hVspAttr[vspFindIndex] = hAttr
    if vspFindIndex >= (VSP_ATTR_MAX_INDEXES - 1) then
        //This is for the last item in the query table
        vspFindIndex = 0
        rc = CccdsEnable()
        #cmpif 0x00000003 : AssertNE(rc, 0, 2411)
        //Change state
        NewState(STATE_VSP_WRITE_CCCDS)
    else
        //More to look for
        vspFindIndex = vspFindIndex + 1
        rc = FindCharOrDesc()
        //Remain in this state
    endif
endsub

//------------------------------------------------------------------------------
// Returns 1 if nSts from AttrWrite means 'encrypted link required'
//------------------------------------------------------------------------------
function Is_Encr_Required(xSts)
    select xSts
    case ATTRIBUTE_AUTHENTICATED_LINK_REQUIRED, ATTRIBUTE_ENCRYPTED_LINK_REQUIRED_A, ATTRIBUTE_ENCRYPTED_LINK_REQUIRED_B
        //Authenticated or encrypted link required
        exitfunc 1
    case else
    endselect
endfunc 0

//------------------------------------------------------------------------------
// Called only from when are VSP in master mode
//------------------------------------------------------------------------------
sub VspMasterRtsSend(nState)
    if hVspAttr[VSP_ATTR_INDEX_MDMIN] then
        if nState != vspAllowRx then
            if nState then
                tmpVar$ = "\01"
            else
                tmpVar$ = "\00"
            endif
            rc = BleGattcWrite(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_MDMIN], tmpVar$)
            if rc == 0 then
                vspAllowRx = nState
                vspMdmSendFail = VSP_MDM_FAIL_CACHE_NONE
            else
                //Modem update failed, cached the value
                vspMdmSendFail = nState
            endif
        endif
    endif
endsub

//------------------------------------------------------------------------------
// We know there is 1 character in the UART buffer so process it for ^ character
// On exit tmpVar$ contains the single character that was read from the buffer
// Returns 0 if receive buffer is empty and disconnect was intiiated, otherwise
// returns 1
//------------------------------------------------------------------------------
function PollForEscapeSeq()
    dim uLen

    tmpVar$ = ""
    uLen = UartReadN(tmpVar$, vspEscStringLen)
    if strcmp(tmpVar$, vspEscString$) == 0 then
        if vspEscCount == 0 then
            //First ^ in a while so take snapshot of tick count
            vspEscStart = GetTickCount()
            vspEscCount = 1
        else
            //Consecutive ^ so need to calc time spacing
            uLen = GetTickSince(vspEscStart)
            if uLen > vspEscMinIntrvl then
                //Long enough so increment count
                vspEscCount = vspEscCount + 1
                if vspEscCount >= vspEscCountMax then
                    //Disconnect
                    vspDisconSts = CONN_ERROR_USER_DISCON
                    //Some other error, so just drop the connection
                    rc = BleDisconnect(connHandles[HCONN_VSP])
                    #cmpif 0x00000003 : AssertRC(2605)
                    //The ^ caret will not get through
                    tmpVar$ = ""
                    //Change state
                    NewState(STATE_VSP_DISCONNECTING)
                    exitfunc 0
                else
                    //Take snapshot of this one
                    vspEscStart = GetTickCount()
                endif
            else
                //Too short time so reset count
                vspEscCount = 0
            endif
        endif
    else
        vspEscCount = 0
    endif
endfunc 1

//------------------------------------------------------------------------------
// Initialise the UART
//------------------------------------------------------------------------------
sub InitUART()
    //Sets up the UART to use the required baud rate, flow control and parity options
    #cmpif 0x00400000 : //get low power idle timeout
    #cmpif 0x00400000 : UARTIdleToutMs = SRegGet(CfgId_UartIdleTime_ms)

    rc = UARTInfo(0)
    if (rc != 0) then
        //UART is opened, close
        UARTClose()
    endif

    //Get values from S-Register Cache
    UARTbaud   = SRegGet(CfgId_UARTBaudrate)
    UARTTxBuf  = SRegGet(CfgId_UARTTxBufSize)
    UARTRxBuf  = SRegGet(CfgId_UARTRxBufSize)
    UARTFlags$ = "CN81H"

    //Reopen the UART with comms parms from S Registers
    rc = UartOpen(UARTbaud, UARTTxBuf, UARTRxBuf, UARTFlags$)
    #cmpif    0x00000003 : AssertRC(2647)

    #cmpif    0x00400000 : //Start the UART inactivity timer if we are in low power operation
    #cmpif    0x00400000 : TimerStart(TMRNUM_LOWPWR_UART, UARTIdleToutMs, 0)
    #cmpifand 0x00400104 : DbgMsg("Uart Tmr STARTi")
endsub

//------------------------------------------------------------------------------
// Load GAP service defaults into sArg$[] and nArg[] to set things up as follows
//   sArg$[0] = device name
//   nArg[1]  = MinConnInterval
//   nArg[2]  = MaxConnInterval
//   nArg[3]  = LinkSupervisionTimeout
//   nArg[4]  = Appearance
//   nArg[5]  = Slave Latency
//   nArg[6]  = DeviceName is writeable
//------------------------------------------------------------------------------
sub GapServiceGetDefs()
    dim tmpStr$, tmpVal

    //Get device name
    sArg$[ArgIDDeviceName] = SRegGetStr$(CfgIdStr_DeviceName)
    //Append part of module BT address if required
    tmpVal = SRegGet(CfgId_DevNameFormat)
    #cmpif 0x00000004 : DbgMsgVal("DevNameFormat = ", tmpVal)
    //Default selection if the BT address is appended to the advertised device name
    if ((tmpVal >= 1) && (tmpVal <= 7)) then
        //Get device address
        tmpStr$ = SysInfo$(4)
        #cmpif 0x00000004 : dim x$ : x$ = strhexize$(tmpStr$)
        #cmpif 0x00000004 : DbgMsgVal$("SysInfo$(4) = ", x$)
        tmpStr$ = Right$(tmpStr$, tmpVal)
        //Append to device name
        sArg$[ArgIDDeviceName] = sArg$[ArgIDDeviceName] + "-" + strhexize$(tmpStr$)
    endif
    //Take the right-most max characters
    sArg$[ArgIDDeviceName] = right$(sArg$[ArgIDDeviceName], MaxDevNameSize)

    #cmpif 0x00000004 : DbgMsgVal$("DeviceName = ", sArg$[ArgIDDeviceName])

    //Set the Tx power level
    tmpVal = SRegGet(CfgId_TxPower_dBm)
    rc = BleTxPowerSet(tmpVal)
    #cmpif 0x00000003 : AssertRC(2690)

    //Set min/max connection intervals
    nArg[ArgIDMinConnInterval] = CONN_INTERVAL_MIN_ASPERIPH_US
    nArg[ArgIDMaxConnInterval] = CONN_INTERVAL_MAX_ASPERIPH_US
    nArg[ArgIDLinkSupervisionTimeout] = SRegGet(CfgId_LinkSupervsnAsSlaveSec) * US_IN_SECONDS

    //Read the Slave latency
    nArg[ArgIDSlaveLatency] = SRegGet(CfgId_SlaveLatency)
    tmpVal = nArg[ArgIDLinkSupervisionTimeout] / nArg[ArgIDMaxConnInterval] - 1  //LinkSuprvsnTouUs/MaxConnIntUs
    if nArg[ArgIDSlaveLatency] > tmpVal then
        nArg[ArgIDSlaveLatency] = tmpVal        //Slave latency has to be compatible with slave latency
    endif

    //Read the appearance
    nArg[ArgIDAppearance] = SRegGet(CfgId_Appearance)

    //Writeable device name is disabled for now
    nArg[ArgIDDeviceNameWriteable] = 0
endsub

//------------------------------------------------------------------------------
// Initialise the GAP service, uses sArg$[] and nArg[] setup using
// GapServiceGetDefs() and/or AT command line
//------------------------------------------------------------------------------
function GapServiceUpdate()
    //Initialise the GAP service with the connection interval data and device name
    rc = BleGapSvcInit(sArg$[ArgIDDeviceName], nArg[ArgIDDeviceNameWriteable], nArg[ArgIDAppearance], nArg[ArgIDMinConnInterval], nArg[ArgIDMaxConnInterval], nArg[ArgIDLinkSupervisionTimeout], nArg[ArgIDSlaveLatency])
    #cmpif 0x00000003 : AssertRC(2718)
endfunc rc

//------------------------------------------------------------------------------
// Configure the pairing capability as set via the S registers
//------------------------------------------------------------------------------
sub PairingConfig()
    //Set the IO capability, -ve value mean OOB pairing is preferred
    tmpVar = SRegGet(CfgId_PairingIoCapability)
    pairIoCapCache = abs(tmpVar)
    rc = BleSecMngrIoCap(pairIoCapCache)
    #cmpif 0x00000003 : AssertRC(2729)

    if tmpVar<0 then
        //OOB pairing is preferred
        rc = BleSecMngrOOBPref(1)
        #cmpif 0x00000003 : AssertRC(2734)
    endif

    //Enable LESC preference
    rc = BleSecMngrLescPairingPref(1)
    #cmpif 0x00000003 : AssertRC(2739)
endsub

//------------------------------------------------------------------------------
// Read, Cache & Config Scanning Parameters
//------------------------------------------------------------------------------
sub CacheConfigScanParms()
    scanIntervalMs = SRegGet(CfgId_ScanInterval_ms)
    scanWindowMs   = SRegGet(CfgId_ScanWindow_ms)
    scanType       = SRegGet(CfgId_ScanType)

    //Ensure that the window is sensible
    if scanWindowMs > scanIntervalMs then
        scanWindowMs = scanIntervalMs
    endif

    //And finally set them
    rc = BleScanConfig(0, scanIntervalMs)
    #cmpif 0x00000003 : AssertRC(2757)
    rc = BleScanConfig(1, scanWindowMs)
    #cmpif 0x00000003 : AssertRC(2759)
    rc = BleScanConfig(2, scanType)
    #cmpif 0x00000003 : AssertRC(2761)
endsub

//------------------------------------------------------------------------------
// Extract exactly one parameter which MUST be a valid 14 hex digit address
//------------------------------------------------------------------------------
function ExtractAddr(byref cmdStr$)    //sArg$[0] is updated with address
    rc = ExtractArgsCSV(cmdStr$, args, 1, 1)
    if rc == 0 then
        //The supplied parameter must dehex to exactly 7 bytes
        sArg$[0] = StrDehexize$(sArg$[0])
        if strlen(sArg$[0]) != 7 then
            //A valid address has not been supplied
            exitfunc CONN_ERROR_INVALID_ADDRESS
        endif
    endif
endfunc RSP_OK

//------------------------------------------------------------------------------
// Extract addr and load other connection related variables
// if the address has prefix 'l' then a long-range connection will be performed
//------------------------------------------------------------------------------
function ConnSetup(byref cmdStr$)
    dim lngRange

    //Stop adverts if on
    AdvertsStop()
    //Stop Scanning if on
    ScanningStop()

    //Try to open the GATT client
    rc = GattClientOpen()
    if rc != 0 then
        exitfunc rc
    endif

    //Check if the 'L' prefix exists
    DropWhiteSpace(cmdStr$)
    tmpDta = StrGetChr(cmdStr$, 0)
    select tmpDta

    case CHR_ASCII_UPPER_L, CHR_ASCII_LOWER_L    //L or L
        #cmpif 0x00000004 : DbgMsg("Long Range Conn Selected")
        lngRange = 1
        StrShiftLeft(cmdStr$, 1)
    case else
        lngRange = 0
    endselect

    //Extract the mac address of the peer to connect to
    rc = ExtractAddr(cmdStr$) //sArg$[0] is updated with address
    if rc != 0 then
        exitfunc rc
    endif

    //Read the min & max connection intervals
    nArg[ArgIDMinConnInterval] = SRegGet(CfgId_MinConnIntUs)
    nArg[ArgIDMaxConnInterval] = SRegGet(CfgId_MaxConnIntUs)
    if nArg[ArgIDMinConnInterval] > nArg[ArgIDMaxConnInterval] then
         //Check the values are sensible
         nArg[ArgIDMinConnInterval] = nArg[ArgIDMaxConnInterval]
    endif

    //Read the link supervision timeout
    nArg[ArgIDLinkSupervisionTimeout] = SRegGet(CfgId_LinkSuprvsnToutMs) * MS_IN_SECONDS
    if nArg[ArgIDLinkSupervisionTimeout] < nArg[ArgIDMaxConnInterval] then
        nArg[ArgIDLinkSupervisionTimeout] = nArg[ArgIDMaxConnInterval] + US_IN_SECONDS     //Add a second to the max interval
    endif

    //Get connection timeout from s register
    nArg[ArgIDConnectionTimeout] = SRegGet(CfgId_ConnTimeoutSec) * MS_IN_SECONDS

    #cmpif 0x00000004 : DbgMsg("Conn Parms")
    #cmpif 0x00000004 : DbgMsgVal("    Conn Tout(msec) =", nArg[ArgIDConnectionTimeout])
    #cmpif 0x00000004 : DbgMsgVal("    Min Intvl       =", nArg[ArgIDMinConnInterval])
    #cmpif 0x00000004 : DbgMsgVal("    Max Intvl       =", nArg[ArgIDMaxConnInterval])
    #cmpif 0x00000004 : DbgMsgVal("    Link Suprvsn    =", nArg[ArgIDLinkSupervisionTimeout])

    //OK to start an outgoing connection
	rc = BleConnectExtended(sArg$[ArgIDAddress], nArg[ArgIDConnectionTimeout], nArg[ArgIDMinConnInterval], nArg[ArgIDMaxConnInterval], nArg[ArgIDLinkSupervisionTimeout], lngRange, EXTADV_FILTER_NONE)
	#cmpif 0x00000004 : DbgMsg("Called BleConnectExtended()")
    if rc != 0 then
        #cmpif 0x00000004 : DbgMsgVal("BleConnect failed with", rc)
        exitfunc CONN_ERROR_BLECONNECT
    endif
    #cmpif 0x00000004 : DbgMsg("Connecting..")
endfunc rc

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : function InitiateTableMap(hConn)
#cmpif 0x00020000 :     rc = BleDiscServiceFirst(hConn, 0, 0)
#cmpif 0x00020000 :     if rc == 0 then
#cmpif 0x00020000 :         exitfunc -1
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 : endfunc rc

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : sub TerminateTableMap(rc)
#cmpif 0x00020000 :     if rc == ERROR_BLE_GATTC_NO_MORE_DATA then
#cmpif 0x00020000 :         rc = 0
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :     AppendRspEnd(rc, UARTSndBuf$)
#cmpif 0x00020000 :     //Send out data waiting in buffer
#cmpif 0x00020000 :     SendUartData()
#cmpif 0x00020000 : endsub

//##############################################################################
//##############################################################################

//------------------------------------------------------------------------------
// Process ATI command
//:/ATIn
//:/====
//:/
//:/
//------------------------------------------------------------------------------
function _ati(byref cmdStr$, byref rspBuf$)
    rc = ExtractArgsCSV(cmdStr$, args, 0, 1)
    if rc != 0 then
        exitfunc rc
    endif
    if args > 0 then
        if ExtractIntToken(sArg$[0], nArg[0]) == 0 then
            exitfunc RSP_ERROR_SYNTAX_ERROR
        endif
    else
        nArg[0] = 0
    endif

    select nArg[0]
    case 0
        tmpVar$ = ATI_RESPONSE_0

    case 3
        GetFirmwareVersion(tmpVar$)

    case 4
        tmpVar$ = SysInfo$(4)
        tmpVar$ = strhexize$(tmpVar$)

    case 10
        tmpVar$ = ATI_RESPONSE_10

    case 11
        sprint #tmpVar$, fLowPowerUart

    case 13
        sprint #tmpVar$, integer.h' sysinfo(1000)

    case 23
        tmpVar$ = LibVer

    case 33
        tmpVar$ = AppVer

    case 42
        sprint #tmpVar$, curState

    #cmpif 0x00200000 : case 50
    #cmpif 0x00200000 :     sprint #tmpVar$, nfcSenseCnt
    #cmpif 0x00200000 :     nfcSenseCnt = nfcSenseCnt & 1
    #cmpif 0x00200000 :
    #cmpif 0x00200000 : case 51
    #cmpif 0x00200000 :     sprint #tmpVar$, nfcReadCnt
    #cmpif 0x00200000 :     nfcReadCnt = 0

    case else
        sprint #tmpVar$, sysinfo(nArg[0])

    endselect

    //Append to buffer
    rspBuf$ = rspBuf$ + "\n" + tmpVar$ + "\r"
endfunc RSP_OK

//------------------------------------------------------------------------------
// Process ATS command
//:/ATSn=m
//:/ATSn?
//:/ATSn=?
//:/
//:/
//------------------------------------------------------------------------------
function _ats(byref cmdStr$, byref rspBuf$)
    //Extract the s-reg number
    if ExtractIntToken(cmdStr$, nArg[0]) == 0 then
        exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
    //Extract either = or ?
    if ExtractStrToken(cmdStr$, sArg$[1]) == 0 then
        exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
    rc = RSP_ERROR_SYNTAX_ERROR    //Assume syntax error
    if strcmp(sArg$[1], "?") == 0 then
        //Get the value of an S register
        if ExtractStrToken(cmdStr$, sArg$[1]) == 0 then
            //Rest of cmd string is empty
            rc = ATSRegGetValue(nArg[0], rspBuf$)
        endif
    elseif strcmp(sArg$[1], "=") == 0 then
        //An assignment or get range
        if ExtractIntToken(cmdStr$, nArg[2]) == 0 then
            //Not an integer so try to extract a string
            if ExtractStrToken(cmdStr$, sArg$[2]) > 0 then
                if strcmp(sArg$[2], "?") == 0 then
                    //Range query
                    rc = ATSRegGetRange(nArg[0], rspBuf$)
                endif
            endif
        else
            //Got an integer
            if ExtractStrToken(cmdStr$, sArg$[3]) == 0 then
                //Rest of cmd string is empty
                #cmpif 0x00000004 : sprint #dbgmsg$, "\nSetReg ";nArg[0];" ";nArg[2]
                #cmpif 0x00000004 : DbgMsg(dbgmsg$)
                rc = ATSRegSetValue(nArg[0], nArg[2])
            endif
        endif
    endif
endfunc rc

//------------------------------------------------------------------------------
// Process AT%S command
//:/AT%Sn=SomeStringValueInOptionalDoubleQuotes
//:/AT%Sn?
//:/AT%Sn=?
//:/
//:/
//------------------------------------------------------------------------------
function _atsSTR(byref cmdStr$, byref rspBuf$)
    //Extract the s-reg number
    if ExtractIntToken(cmdStr$, nArg[0]) == 0 then
        exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
    //Extract either = or ?
    if ExtractStrToken(cmdStr$, sArg$[1]) == 0 then
        exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
    rc = RSP_ERROR_SYNTAX_ERROR    //Assume syntax error
    if strcmp(sArg$[1], "?") == 0 then
        //Get the value of an S register
        if ExtractStrToken(cmdStr$, sArg$[1]) == 0 then
            //Rest of cmd string is empty
            rc = ATSRegGetValueStr(nArg[0], rspBuf$)
        endif
    elseif strcmp(sArg$[1], "=") == 0 then
        //An assignment or get range
        if ExtractStrToken(cmdStr$, sArg$[2]) > 0 then
            if strcmp(sArg$[2], "?") == 0 then
                //Range query
                rc = ATSRegGetLenRangeStr(nArg[0], rspBuf$)
            else
                if IsQuoted(sArg$[2]) then    //Check for beginning " and ending "
                    //the string is quoted, so set it
                    TrimQuotes(sArg$[2])
                    rc = ATSRegSetValueStr(nArg[0], sArg$[2])
                endif
            endif
        endif
    endif
endfunc rc

//------------------------------------------------------------------------------
// Save registers to non-vol memory
//------------------------------------------------------------------------------
function _atampW(byref cmdStr$, byref rspBuf$)
    //Extract something and there should be nothing
    if ExtractStrToken(cmdStr$, tmpVar$) != 0 then
        exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
endfunc SRegSave()

//------------------------------------------------------------------------------
// Reset all non-vol data to factory settings and then reset
//------------------------------------------------------------------------------
function _atampF(byref cmdStr$, byref rspBuf$)
    //Extract something and there should be nothing
    if ExtractStrToken(cmdStr$, tmpVar$) != 0 then
        exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
    rc = SRegFactoryDef()
    if rc == RSP_OK then
        rc = BleBondingEraseAll()
        if rc == RSP_OK then
            reset(0)
        endif
    endif
endfunc rc

//------------------------------------------------------------------------------
//:/ at+siorN       - read
//:/ at+siowN,V     - write
//:/ at+siocN,F,S   - config   F=1(DIG_IN), 2(DIG_OUT) 3(ANALOG_IN)
//                             (see appropriate value of S in module user guide)
//------------------------------------------------------------------------------
function _atPlusSIO(byval actType, byref cmdStr$, byref rspBuf$)
    rc = ExtractArgsCSV(cmdStr$, args, 1, 3)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Extract the sio number
    rc = SArgConvertToInt(0, 0, 0, MAX_SIO_NUM)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //At this point rc == RSP_OK

    select actType
    case CMD_ACTTYPE_SIOR //READ
        //append to buffer
        //#cmpif 0x00000004 : print "\n## SIO read ";nArg[ArgIDGPIOSIO]
        sprint #tmpVar$, GpioRead(nArg[ArgIDGPIOSIO])
        rspBuf$ = rspBuf$ + "\n" + tmpVar$ + "\r"

    case CMD_ACTTYPE_SIOW //WRITE
        if args == 2 then
            rc = SArgConvertToInt(1, 0, 0, 0x7FFF)
            if rc != RSP_OK then
                exitfunc rc
            endif
            //At this point rc == RSP_OK
            //#cmpif 0x00000004 : print "\n## SIO write ";nArg[ArgIDGPIOSIO], nArg[ArgIDGPIOState]
            GpioWrite(nArg[ArgIDGPIOSIO], nArg[ArgIDGPIOState])
        else
            rc = RSP_ERROR_SYNTAX_ERROR
        endif

    case CMD_ACTTYPE_SIOC //CONFIG
        if args == 3 then
            rc = SArgConvertToInt(1, 1, 1, 3)
            if rc != RSP_OK then
                exitfunc rc
            endif
            //At this point rc == RSP_OK
            rc = SArgConvertToInt(2, 0, 0, 255)
            if rc != RSP_OK then
                exitfunc rc
            endif
            //At this point rc == RSP_OK
            //#cmpif 0x00000004 : print "\n## SIO config ";nArg[ArgIDGPIOSIO], nArg[ArgIDGPIOFunction], nArg[ArgIDGPIOSubFunction]
            rc = GpioSetFunc(nArg[ArgIDGPIOSIO], nArg[ArgIDGPIOFunction], nArg[ArgIDGPIOSubFunction])
        else
            rc = RSP_ERROR_SYNTAX_ERROR
        endif

    case else
        rc = RSP_ERROR_GPIO_NOT_AVAILABLE
    endselect
endfunc rc

//------------------------------------------------------------------------------
//:/ at+lscn<timeout_seconds><,"escaped_pattern"><,rssi><,scantype>
//:/ at+lscn<x>
//------------------------------------------------------------------------------
function _atPlusLSCN(byref cmdStr$, byref rspBuf$)
    sArg$[0] = ""
    rc = ExtractArgsCSV(cmdStr$, args, 0, 4)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //#cmpif 0x00000004 : DbgMsgVal ("args =", args)
    //#cmpif 0x00000004 : DbgMsgVal$("sArg$[0] =", sArg$[0])
    //#cmpif 0x00000004 : DbgMsgVal$("sArg$[1] =", sArg$[1])
    //#cmpif 0x00000004 : DbgMsgVal$("sArg$[2] =", sArg$[2])
    //#cmpif 0x00000004 : DbgMsgVal$("sArg$[3] =", sArg$[3])

    //Check if this is to stop scanning (AT+LSCNX)
    if (args == 1) then
        StrToLower$(sArg$[0])
        if strcmp(sArg$[0], "x") == 0 then
            ScanningStop()
            exitfunc RSP_OK
        endif
    endif

    //Get timeout into nArg[0]
    rc = SArgConvertToInt(0, SRegGet(CfgId_ScanTimeoutSec), 0, SREG_ScanTimeoutSec_MAX)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Get Scan Pattern into sArg$[1]
    StrDeEscape(sArg$[1])  //ensure escaped characters are converted to binary

    //Get minimum RSSI threshold into nArg[2]
    rc = SArgConvertToInt(2, -128, -128, 20)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Get scantype into nArg[3]
    rc = SArgConvertToInt(3, SCANTYPE_1MPHY, 1, SCANTYPE_ALL)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //And now start scanning
    select curState
    case STATE_IDLE_nonVSP
        //Scan timeout has to be specified in milliseconds
        //now start scanning with new parameters
        rc = ScanningStart((nArg[0] * MS_IN_SECONDS), sArg$[1], nArg[2], nArg[3])
        advPrefix$ = "\nAD0:"
        rc = RSP_OK

    case STATE_IDLE_VSP
        if nArg[0] == 0 then
            //Permanent scanning requested
            rc = ScanningStart(0, sArg$[1], nArg[2], nArg[3])
            //Change state
            advPrefix$ = "\nAD0:"
            NewState(STATE_IDLE_nonVSP)
            //If advertising in progress stop it
            AdvertsStop()
            //Need to start advertising in idle
            IdleAdvCommit()
            //Start Advertising
            IdleStartAdverts(idleAdvType, idleAdvIntvlMs)

            rc = RSP_OK
        else
            //Scan timeout has to be specified in milliseconds
            //if advertising and/or scanning in progress stop them
            AdvertsStop()
            //Now start scanning with new parameters
            rc = ScanningStart((nArg[0] * MS_IN_SECONDS), sArg$[1], nArg[2], nArg[3])
            if rc == 0 then
                //Successfully started scanning
                advPrefix$ = "\nAD1:"
                SaveState(oldIdleState)
                NewState(STATE_SCAN_VSP)
                //And suspend parser
                rc = RSP_SUSPEND
            endif
        endif

    case STATE_nonVSP_CONNECTED
        if nArg[0] == 0 then
            //Do not allow unlimited timeout scanning
            rc = RSP_ERROR_VALUE_NOT_VALID
        else
            //If advertising and/or scanning in progress stop them
            AdvertsStop()
            //Now start scanning with new parameters
            rc = ScanningStart((nArg[0] * MS_IN_SECONDS), sArg$[1], nArg[2], nArg[3])
            if rc == 0 then
                //Successfully started scanning
                advPrefix$ = "\nAD2:"
                //Remain in this state
            endif
        endif

    case else
        rc = RSP_ERROR_INCORRECT_MODE
    endselect
endfunc rc

//------------------------------------------------------------------------------
// Returns 1 if args==1 and sArgs[0] is X or x and the adverts has been stopped
//------------------------------------------------------------------------------
function CheckStopAdverts(args)
    if (args == 1) then
        StrToLower$(sArg$[0])
        if strcmp(sArg$[0], "x") == 0 then
            AdvertsStop()
            if curState == STATE_IDLE_VSP then
                //Only change state if we are in VSP Idle
                NewState(STATE_IDLE_nonVSP)
            endif
            exitfunc 1
        endif
    endif
endfunc 0

//------------------------------------------------------------------------------
//:/ at+ladv<advType><,advIntervalMs>
//:/ at+ladv<x>
//------------------------------------------------------------------------------
function _atPlusLADV(byref cmdStr$, byref rspBuf$)
    //This command has up to 2 parameters
    rc = ExtractArgsCSV(cmdStr$, args, 0, 2)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Check if this is to stop advertising (AT+LADVX)
    if CheckStopAdverts(args) then
        exitfunc RSP_OK
    endif

    //Get advtype into nArg[0]
    rc = SArgConvertToInt(0, idleAdvType, SREG_IdleAdvertType_MIN, SREG_IdleAdvertType_MAX)
    if rc != RSP_OK then
        exitfunc rc
    endif
    if nArg[0] == 1 then
        exitfunc RSP_ERROR_ADV_TYPE
    endif

    //Get adv interval milliseconds into nArg[1]
    rc = SArgConvertToInt(1, idleAdvIntvlMs, SREG_IdleAdvertIntvlMs_MIN, SREG_IdleAdvertIntvlMs_MAX)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //If advertising in progress stop it
    AdvertsStop()
    //Need to start advertising in idle
    IdleAdvCommit()
    //Start Advertising
    IdleStartAdverts(nArg[0], nArg[1])
    if curState == STATE_IDLE_VSP then
        //Only change state if we are in VSP Idle
        NewState(STATE_IDLE_nonVSP)
    endif
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+eadv<advProp><,advIntervalMs><,MaxCount><,advPriSecPhy><,peerAddr><,chanMask>
//:/ at+eadv<x>
//------------------------------------------------------------------------------
function _atPlusEADV(byref cmdStr$, byref rspBuf$)
    //This command has from 1 to 6 parameters
    rc = ExtractArgsCSV(cmdStr$, args, 1, 6)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Check if this is to stop advertising (AT+LADVX)
    if CheckStopAdverts(args) then
        exitfunc RSP_OK
    endif

    //Get mandatory advProp into nArg[0]
    rc = SArgConvertToInt(0, MAX_EXTADV_PROPERTY_DEFAULT, 0, MAX_EXTADV_PROPERTY_VALUE) //See BleAdvSetCreate() and advProp description
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Get optional adv interval milliseconds into nArg[1]
    rc = SArgConvertToInt(1, idleAdvIntvlMs, SREG_IdleAdvertIntvlMs_MIN, SREG_IdleAdvertIntvlMs_MAX)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Get optional maxCount nArg[2] - default 0
    rc = SArgConvertToInt(2, EXTADV_MAXCOUNT_DEFAULT, 0, EXTADV_MAXCOUNT_MAXIMUM)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Get optional primary and secondary PHY into nArg[3] - default 1MPHY
    rc = SArgConvertToInt(3, MAX_EXTADV_PRISECPHY_DEFAULT, 0, MAX_EXTADV_PRISECPHY)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Get optional peeraddress which must be empty if directed bit in advprop is clear
    tmpDta = strlen(sArg$[4])
    if tmpDta == 0 then
        //Peer address not specified
        if nArg[0] & EXTADVPROP_DIRECTED then
            //Directed advert
            exitfunc RSP_ERROR_DIRECTED_NOPEERADDR
        endif
    else
        //Non-empty string so dehexize
        sArg$[4] = StrDehexize$(sArg$[4])
        tmpDta = strlen(sArg$[4])
        if tmpDta != SIZE_OF_BLE_ADDRESS then
            //Not a valid ble address
            exitfunc RSP_ERROR_INVALID_ADDRESS
        endif
    endif

    //Get optional channel mask which can be empty or exactly 5 bytes long
    tmpDta = strlen(sArg$[5])
    if tmpDta != 0 then
        //Chan mask specified
        sArg$[5] = StrDehexize$(sArg$[5])
        tmpDta = strlen(sArg$[5])
        if tmpDta != SIZE_OF_CHANNEL_MASK then
            //Not a valid ble address
            exitfunc RSP_ERROR_INVALID_CHANMASK
        endif
    endif

    //------------------------------------------------------------------------------
    //      0          1             2          3              4           5
    // <advProp><,advIntervalMs><,MaxCount><,advPriSecPhy><,peerAddr><,chanMask>
    //------------------------------------------------------------------------------

    //If advertising in progress stop it
    AdvertsStop()
    //Create Advert Set
    rc = BleAdvSetCreate(SETID_DEFAULT, nArg[0], nArg[3], EXTADV_FILTER_NONE, sArg$[4], sArg$[5])
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Attach data to the advert set
    rc = BleAdvSetNewData(SETID_DEFAULT, idleAdvRpt$, idleScnRpt$)
    if rc == NORDICERROR_INVALID_PARM then
        exitfunc RSP_ERROR_INVALID_REPORTS
    elseif rc == NORDICERROR_INVALID_DATA then
        exitfunc RSP_ERROR_INVALID_RPT_DATA
    elseif rc == NORDICERROR_INVALID_DATA_SIZE then
        exitfunc RSP_ERROR_INVALID_RPT_DATA_SIZE
    elseif rc != RSP_OK then
        exitfunc rc
    endif
    rc = BleAdvSetStart(SETID_DEFAULT, nArg[1], ADV_DURATION_FOREVER, nArg[2], AUXOFFSET_DEFAULT)
    if rc != RSP_OK then
        exitfunc rc
    else
        fExtAdvertising = TRUE
    endif
    if curState == STATE_IDLE_VSP then
        //Only change state if we are in VSP Idle
        NewState(STATE_IDLE_nonVSP)
    endif
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+lVSP
//------------------------------------------------------------------------------
function _atPlusLVSP(byref cmdStr$, byref rspBuf$)
    //This command has no parameters
    rc = ExtractArgsCSV(cmdStr$, args, 0, 0)
    if rc != RSP_OK then
        exitfunc rc
    endif

    select curState
    case STATE_IDLE_nonVSP
        //If advertising or scanning in progress stop them
        #cmpif 0x00000004 : DbgMsg("VSP Connectable")
        AdvertsStop()
        ScanningStop()
        //Get default parameters
        if vspAdded == 0 then
            VspGetDefs()
            //Open the VSP service and variable vspAdded will be updated
            rc = VspOpen()
        endif
        if vspAdded != 0 then
            //Create the VSP related Advert report and scan report and commit
            VspAdvCreateCommit()
            //Start Advertising
            VspStartAdverts()
            //Change state
            NewState(STATE_IDLE_VSP)
            rc = RSP_OK
        else
            //Change state to idle because we have definitely stopped adverts
            NewState(STATE_IDLE_nonVSP)
            rc = RSP_ERROR_VSP_OPENFAIL
        endif

    case STATE_IDLE_VSP
        //Do nothing as already there anyway
        rc = RSP_OK

    case else
        rc = RSP_ERROR_INCORRECT_MODE

    endselect
endfunc rc

//------------------------------------------------------------------------------
//:/ at+bndt[addr]
//------------------------------------------------------------------------------
function _atPlusBNDT(byref cmdStr$, byref rspBuf$)
    rc = ExtractAddr(cmdStr$) //SArg$[0] is updated with address
    if rc != 0 then
        exitfunc rc
    endif

    dim isTrusted, keyInfo, rollAge, rollCount
    isTrusted =              BleBondingIsTrusted(sArg$[0], BOND_TRUSTED_AS_CENTRAL, keyInfo, rollAge, rollCount)
    isTrusted = isTrusted || BleBondingIsTrusted(sArg$[0], BOND_TRUSTED_AS_PERIPHERAL, keyInfo, rollAge, rollCount)
    if isTrusted then
        if rollAge <= 0 then
            rollAge = 0  //Persistent
        else
            rollAge = 1  //Rolling
        endif
        sprint #tmpVar$, "\n1, ";rollAge;", ";StrHexize$(sArg$[0]);"\r"
    else
        tmpVar$ = "\n0\r"
    endif
    rspBuf$ = rspBuf$ + tmpVar$
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+bndp[addr]
//------------------------------------------------------------------------------
function _atPlusBNDP(byref cmdStr$, byref rspBuf$)
    rc = ExtractAddr(cmdStr$) //SArg$[0] is updated with address
    if rc != 0 then
        exitfunc rc
    endif
endfunc BleBondingPersistKey(sArg$[0])

//------------------------------------------------------------------------------
//:/ at+bndd[addr]
//------------------------------------------------------------------------------
function _atPlusBNDD(byref cmdStr$, byref rspBuf$)
    rc = ExtractAddr(cmdStr$) //SArg$[0] is updated with address
    if rc != 0 then
        exitfunc rc
    endif

    rc = BleBondingEraseKey(sArg$[0])
    #cmpif 0x00000003 : AssertRC(3477)
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+bndx
//------------------------------------------------------------------------------
function _atPlusBNDX(byref cmdStr$, byref rspBuf$)
    rc = BleBondingEraseAll()
    #cmpif 0x00000003 : AssertRC(3485)
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+bndl
//------------------------------------------------------------------------------
function _atPlusBNDL(byref cmdStr$, byref rspBuf$)
    dim rc, nCap, nRoll, nPers, idx, addr$, ExtraInfo
    nCap = BleBondingStats(nRoll, nPers)
    print "\ncapacity: "; nCap; ", rolling: "; nRoll; ", persistent: ";nPers

    for idx=0 to nCap
        addr$ = ""
        ExtraInfo = 0
        rc = BleBondMngrGetInfo(idx, addr$, ExtraInfo)
        if rc == 0 then
            print "\n"; idx, StrHexize$(addr$), INTEGER.h'ExtraInfo
        endif
    next

    #cmpif 0x00000003 : AssertRC(3505)
endfunc RSP_OK

//------------------------------------------------------------------------------
// Process ATD command
//:/ATD macaddress14hexbytes
//:/ATD L macaddress14hexbytes      //for long-range connection
//:/====
//:/
//:/
//------------------------------------------------------------------------------
function _atD(byref cmdStr$, byref rspBuf$)
    //Now check if we are heading for fast mode
    if (vspCmdModePin >= 0) && (fLowPowerUart == 0) then
        #cmpif 0x00000004 : DbgMsg("Fast Mode will be selected")
        //Yes, so check state of that pin
        if GpioRead(vspCmdModePin) == 0 then
            //Cmd pin is incorrect state so disallow connection
            exitfunc CONN_ERROR_CMDPINSTATE
        endif
    endif

    //Do not allow if we already have a connection
    if connCount > 0 then
        exitfunc CONN_ERROR_TOOMANYCONNECTIONS
    endif

    //Extract address and load nArg[] with connection related parameters
    rc = ConnSetup(cmdStr$)
    if rc != 0 then
        exitfunc rc
    endif

    //Save which state we got ATD in so we can return to it
    SaveState(oldIdleState)

    //Assume a large default, will be reduced in the connect event from the
    //actual connection event time interval
    vspPumpToutMs = 250

    //Change state
    NewState(STATE_VSP_CONNECTING)
endfunc CONN_SUSPEND

//------------------------------------------------------------------------------
// Process AT_LCON command
//:/AT_LCON macaddress14hexbytes
//:/AT_LCON L macaddress14hexbytes  //for long-range connection
//:/====
//:/
//:/
//------------------------------------------------------------------------------
function _atPlusLCON(byref cmdStr$, byref rspBuf$)
    //Extract address and load nArg[] with connection related parameters
    rc = ConnSetup(cmdStr$)
    if rc != 0 then
        exitfunc rc
    endif

    if curState != STATE_nonVSP_CONNECTED then
        //Save which state we got AT+LCON in so we can return to it
        SaveState(oldIdleState)
    endif

    //Change state
    NewState(STATE_nonVSP_CONNECTING)
endfunc CONN_SUSPEND

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusCMD_I(cmdId, byref cmdStr$)
    dim hConn

    rc = ExtractArgsCSV(cmdStr$, args, 1, 1)    //Extract the connection handle
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert to integer and save in nArg[0]
    rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
    if rc != RSP_OK then
        exitfunc rc
    endif

    if curState != STATE_nonVSP_CONNECTED then
        exitfunc RSP_ERROR_INCORRECT_MODE
    endif

    hConn = connHandles[nArg[0]]
    select cmdId
    // Process AT+LDSC command
    //:/AT+LDSCnn
    //:/====
    case CMD_I_LDSC
        if hConn then
            rc = BleDisconnect(hConn)
            #cmpif 0x00000003 : AssertRC(3600)
        endif

    // Process AT+LMTU command
    //:/AT+LMTUnn
    //:/====
    case CMD_I_LMTU
        if hConn then
            rc = BleGattcAttributeMtuRequest(hConn)
            #cmpif 0x00000001 : print "\n## BleGattcAttributeMtuRequest() ret:";integer.h' rc
        endif

    // Process AT+LPHY command
    //:/AT+LPHYnn
    //:/====
    case CMD_I_LPHY
        if hConn then
            rc = ChangePhy(hConn)
            #cmpif 0x00000001 : print "\n## ChangePhy() ret:";integer.h' rc
        endif

    // Process AT+PAIR command
    //:/AT+PAIRnn
    //:/====
    case CMD_I_PAIR
        rc = BlePair(hConn, 1)
        #cmpif 0x00000003 : AssertRC(3626)

    // Process AT+LENC command
    //:/AT+LENCnn
    //:/====
    case CMD_I_LENC
        rc = BleEncryptConnection(hConn, SRegGet(CfgId_MinEncryptionKeyLen), SRegGet(CfgId_MITMreqForEncryption))
        #cmpif 0x00000003 : AssertRC(3633)

    #cmpif 0x00020000 : // Process AT+GCTM command
    #cmpif 0x00020000 : //:/AT+GCTMnn
    #cmpif 0x00020000 : //:/====
    #cmpif 0x00020000 : case CMD_I_GCTM
    #cmpif 0x00020000 :     rc = InitiateTableMap(hConn)
    #cmpif 0x00000003 :     AssertRC(3640)

    case else
    endselect
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusPRSP(byref cmdStr$)
    dim hConn

    if curState != STATE_nonVSP_CONNECTED then
        exitfunc RSP_ERROR_INCORRECT_MODE
    endif

    rc = ExtractArgsCSV(cmdStr$, args, 2, 3)    //Extract the connection handle & response key
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert to integer and save in nArg[0]
    rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
    if rc != RSP_OK then
        exitfunc rc
    endif
    hConn = connHandles[nArg[0]]
    //Convert the second parameter to lower case
    StrToLower$(sArg$[1])
    if strcmp(sArg$[1], "y") == 0 then
        //Accept pairing
        rc = BleAcceptPairing(hConn, 1)
    elseif strcmp(sArg$[1], "n") == 0 then
        //Reject pairing
        rc = BleAcceptPairing(hConn, 0)
    elseif strlen(sArg$[1]) == 32 then
        //OOB key is provided
        sArg$[1] = StrDehexize$(sArg$[1])
        if strlen(sArg$[1]) == 16 then
            rc = BleSecMngrOOBKey(hConn, sArg$[1])
        else
            rc = RSP_ERROR_INVALID_HEXSTR
        endif
    else
        rc = SArgConvertToInt(1, 0, 0, 999999)
        if rc == RSP_OK then
            rc = BleSecMngrPassKey(hConn, nArg[1])
        endif
    endif
endfunc rc

//------------------------------------------------------------------------------
// Host has supplied a static passkey to use in future passkey pairing
//------------------------------------------------------------------------------
function _atPlusPKEY(byref cmdStr$)
    
    rc = ExtractArgsCSV(cmdStr$, args, 1, 1)    //Extract the passkey
    
    if strlen(sArg$[0]) != 6 then
        exitfunc RSP_ERROR_VALUE_NOT_VALID
    endif

    dim tmpPassKeyStr$
    tmpPassKeyStr$ = sArg$[0]

    rc = SArgConvertToInt(0, 0, 0, 999999)
    if rc == RSP_OK then
        rc = BlePairingStaticPasskey(tmpPassKeyStr$)
    endif
    
    if rc != RSP_OK then
        exitfunc rc
    endif
endfunc rc

//------------------------------------------------------------------------------
// Host has supplied the OOB data for remote device
//------------------------------------------------------------------------------
function _atPlusOOBR(byref cmdStr$)

    rc = ExtractArgsCSV(cmdStr$, args, 3, 3)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Submit remote address, OOB Hash and OOB Rand as received over OOB link from the remote device
    if strlen(sArg$[0]) != 14 || strlen(sArg$[1]) != 32 || strlen(sArg$[2]) != 32 then
        exitfunc RSP_ERROR_INVALID_HEXSTR
    endif

    //Dehexize the data first
    sArg$[0] = strdehexize$(sArg$[0])  //address
    sArg$[1] = strdehexize$(sArg$[1])  //hash
    sArg$[2] = strdehexize$(sArg$[2])  //rand
endfunc SubmitRemoteOobData(sArg$[0], sArg$[1], sArg$[2])

//------------------------------------------------------------------------------
// Host is requesting local OOB data so that it can send to remote out-of-band
//------------------------------------------------------------------------------
function _atPlusOOBL(byref cmdStr$, byref rbuf$)
    rc = BleSecMngrLescOwnOobDataGet(sArg$[0], sArg$[1], sArg$[2])
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Hexize the data
    sArg$[0] = strhexize$(sArg$[0])  //address
    sArg$[1] = strhexize$(sArg$[1])  //hash
    sArg$[2] = strhexize$(sArg$[2])  //rand

    rbuf$ = rbuf$ + "\nOL:" + sArg$[0] + ", " + sArg$[1] + ", " + sArg$[2] + "\r"
    //Send data waiting in UART buffer
    SendUartData()
endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGCRD_WR(cmdType, byref cmdStr$)
    dim hConn

    if curState != STATE_nonVSP_CONNECTED then
        exitfunc RSP_ERROR_INCORRECT_MODE
    endif

    rc = ExtractArgsCSV(cmdStr$, args, 3, 3)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert connhandle to integer and save in nArg[0]
    rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert attrhandle to integer and save in nArg[1]
    rc = SArgConvertToInt(1, 0, 1, 0xFFFE)
    if rc != RSP_OK then
        exitfunc rc
    endif

    select cmdType
    case CMD_GCRDWR_GCRD    // GATTC Read
        //Convert offset to integer and save in nArg[2]
        rc = SArgConvertToInt(2, 0, 0, 511)
        if rc != RSP_OK then
            exitfunc rc
        endif

    case CMD_GCRDWR_GCWA, CMD_GCRDWR_GCWC
        tmpVar$ = strdehexize$(sArg$[2])
        if (strlen(tmpVar$) * 2) != strlen(sArg$[2]) then
            exitfunc RSP_ERROR_INVALID_HEXSTR
        endif

    case else
    endselect

    hConn = connHandles[nArg[0]]

    select cmdType
    case CMD_GCRDWR_GCRD  // GATTC Read
        rc = BleGattcRead(hConn, nArg[1], nArg[2])

    case CMD_GCRDWR_GCWA  //GATTC Write Acked
        rc = BleGattcWrite(hConn, nArg[1], tmpVar$)

    case CMD_GCRDWR_GCWC  //GATTC Write NOT Acked
        rc = BleGattcWriteCmd(hConn, nArg[1], tmpVar$)

    case else
    endselect
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGCFA(byref cmdStr$)
    dim i, hConn

    if curState != STATE_nonVSP_CONNECTED then
        exitfunc RSP_ERROR_INCORRECT_MODE
    endif

    rc = ExtractArgsCSV(cmdStr$, args, 5, 7)  //Will be 7 if descriptor find
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert connection handle to integer and save in nArg[0]
    rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
    if rc != RSP_OK then
        exitfunc rc
    endif

    for i = 1 to (args + 1)
        //Yes, given we are using MAX_UUID_HANDLES below means that is the highest
        //instance of that object we can look for, but that is not a showstopper restriction in real life
        rc = SArgConvertToInt(i, 0, 0, (MAX_UUID_HANDLES-1))
        if rc != RSP_OK then
            exitfunc rc
        endif
    next

    hConn = connHandles[nArg[0]]
    if args == 7 then
        //Find a descriptor
        rc = BleGattcFindDesc(hConn, uuidHandles[nArg[1]], nArg[2], uuidHandles[nArg[3]], nArg[4], uuidHandles[nArg[5]], nArg[6])
    else
        //Find a characteristic
        rc = BleGattcFindChar(hConn, uuidHandles[nArg[1]], nArg[2], uuidHandles[nArg[3]], nArg[4])
    endif
endfunc rc

//------------------------------------------------------------------------------
// AT+UUID n,16bitUuid,m
// AT+UUID n,16bitUuid
// AT+UUID n,32bitHex
//------------------------------------------------------------------------------
function _atPlusUUID(byref cmdStr$, byref rspBuf$)
    dim hUuid

    rc = ExtractArgsCSV(cmdStr$, args, 2, 3)  //Extract up to 3 parameters
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert to UUID handle index and save in nArg[0]
    rc = SArgConvertToInt(0, 0, 0, (MAX_UUID_HANDLES-1))
    if rc != RSP_OK then
        exitfunc rc
    endif

    if args == 3 then
        //AT+UUID n,16bituuid,m

        //Convert 16 bit base offset and save in nArg[1]
        rc = SArgConvertToInt(1, 0, 0, 0xFFFF)
        if rc != RSP_OK then
            exitfunc rc
        endif

        //Convert to UUID handle index and save in nArg[2]
        rc = SArgConvertToInt(2, 0, 0, (MAX_UUID_HANDLES-1))
        if rc != RSP_OK then
            exitfunc rc
        endif

        hUuid = BleHandleUuidSibling(uuidHandles[nArg[2]], nArg[1])
    else
        if strlen(sArg$[1]) >= 10 then
            //AT+UUID n,32bitHex

            //Get the 16 byte UUID
            sArg$[1] = StrDehexize$(sArg$[1])
            if strlen(sArg$[1]) != 16 then
                exitfunc RSP_ERROR_INVALID_HEXSTR
            endif

            hUuid = BleHandleUuid128(sArg$[1])

        else
            //AT+UUID n,16bitUuid

            //Convert 16 bit base offset and save in nArg[1]
            rc = SArgConvertToInt(1, 0, 0, 0xFFFF)
            if rc != RSP_OK then
                exitfunc rc
            endif

            hUuid = BleHandleUuid16(nArg[1])

        endif
    endif

    if hUuid == 0 then
        exitfunc RSP_ERROR_INVALID_UUID
    endif

    uuidHandles[nArg[0]] = hUuid

    sprint #tmpVar$, "\n" ; integer.h' hUuid ; "\r"
    //Append to buffer
    rspBuf$ = rspBuf$ + tmpVar$
endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusCMD_IS(cmdType, byref cmdStr$)
    dim hChar

    rc = ExtractArgsCSV(cmdStr$, args, 2, 2)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert first parm to integer and save in nArg[0]
    rc = SArgConvertToInt(0, 0, 1, MAX_CHARACTERISTICS)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert data to binary
    tmpVar$ = strdehexize$(sArg$[1])
    if (strlen(tmpVar$) * 2) != strlen(sArg$[1]) then
        exitfunc RSP_ERROR_INVALID_HEXSTR
    endif

    hChar = charHandles[nArg[0]]
    select cmdType
    case CMD_IS_NOTIFY
        if curState != STATE_nonVSP_CONNECTED then
            exitfunc RSP_ERROR_INCORRECT_MODE
        endif
        rc = BleCharValueNotify(hChar, tmpVar$)

    case CMD_IS_INDICATE
        if curState != STATE_nonVSP_CONNECTED then
            exitfunc RSP_ERROR_INCORRECT_MODE
        endif
        rc = BleCharValueIndicate(hChar, tmpVar$)

    case CMD_IS_LOCALWRITE
        rc = BleCharValueWrite(hChar, tmpVar$)

    case else
        rc = RSP_ERROR_UNKNOWN_CMD
    endselect
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGSSB_E(fNew, byref cmdStr$)
    if fNew then
        //CMD_GSSBE_GSSB
        rc = ExtractArgsCSV(cmdStr$, args, 1, 1)  //extract the UUID handle index
        if rc != RSP_OK then
            exitfunc rc
        endif
        //Convert to UUID handle index and save in nArg[0]
        rc = SArgConvertToInt(0, 0, 0, (MAX_UUID_HANDLES-1))
        if rc != RSP_OK then
            exitfunc rc
        endif

        //A new service is being defined
        if svcHandle then
            //We have not ENDed a service definition yet
            exitfunc RSP_ERROR_SVC_NOTENDED
        endif
        //Always define a primary service
        rc = BleServiceNew(1, uuidHandles[nArg[0]], svcHandle)
    else
        //CMD_GSSBE_GSSE
        //The end of a service definition
        rc = BleServiceCommit(svcHandle)
        svcHandle = 0
    endif
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGSMD(byref cmdStr$)
    dim i

    rc = ExtractArgsCSV(cmdStr$, args, 4, 4)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert to metadata handle index and save in nArg[0]
    rc = SArgConvertToInt(0, 1, 1, MAX_METADATA_HANDLES)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert to read & write rights and save in nArg[]
    for i = 1 to 2
        rc = SArgConvertToInt(i, 0, 0, 6)
        if rc != RSP_OK then
            exitfunc rc
        elseif nArg[i] == 4 || nArg[i] == 5 then
            //4&5 are not allowed.
            exitfunc RSP_ERROR_VALUE_NOT_VALID
        endif
    next
    //Convert to length and save in nArg[3]
    rc = SArgConvertToInt(3, 1, 1, MAX_ATTRIBUTE_LEN)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Set nFlags to 0 -- No capability for authorisation exposed.
    metaHandles[nArg[0]] = BleAttrMetadataEx(nArg[1], nArg[2], nArg[3], 0, rc)
endfunc rc

//------------------------------------------------------------------------------
// AT+GSCB u,pr,m{V}<,m{C}<,m{S}>>  //CharAdd m{XXX} is the metadata index and 0 means not provided.
//------------------------------------------------------------------------------
function _atPlusGSCB(byref cmdStr$)
    dim i

    if chrInProg then
        exitfunc RSP_ERROR_CHAR_NOTENDED
    endif

    rc = ExtractArgsCSV(cmdStr$, args, 3, 5)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert to UUID handle index and save in nArg[0]
    rc = SArgConvertToInt(0, 1, 1, (MAX_UUID_HANDLES-1))
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert to properties and save in nArg[1]
    rc = SArgConvertToInt(1, 1, 1, 63)  //does not allow reliable writes
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Initialise all 3 metadata in nArg[2]..nArg[4] to 0
    nArg[3] = 0 : nArg[4] = 0
    //Convert to read & write rights and save in nArg[]
    args = args -1
    for i = 2 to args
        rc = SArgConvertToInt(i, 1, 1, MAX_METADATA_HANDLES)
        if rc != RSP_OK then
            exitfunc rc
        endif
    next
    rc = BleCharNew(nArg[1], uuidHandles[nArg[0]], metaHandles[nArg[2]], metaHandles[nArg[3]], metaHandles[nArg[4]])
    if rc == 0 then
        chrInProg = 1
    endif
endfunc rc

//------------------------------------------------------------------------------
// AT+GSCE hexdata  - returns an index to identify the characteristic
//------------------------------------------------------------------------------
function _atPlusGSCE(byref cmdStr$, byref rspBuf$)
    dim charH, nIdx

    if chrInProg == 0 then
        exitfunc RSP_OK
    endif
    if svcHandle == 0 then
        exitfunc RSP_ERROR_SVC_NOTSTARTED
    endif

    rc = ExtractArgsCSV(cmdStr$, args, 1, 1)
    if rc != RSP_OK then
        exitfunc rc
    endif
    //Convert data to binary
    tmpVar$ = strdehexize$(sArg$[0])
    if (strlen(tmpVar$) * 2) != strlen(sArg$[0]) then
        exitfunc RSP_ERROR_INVALID_HEXSTR
    endif

    rc = BleCharCommit(svcHandle, tmpVar$, charH)
    if rc == 0 then
        chrInProg = 0
        rc = AddCharHandle(charH, nIdx)
        if rc == 0 then
            sprint #tmpVar$, "\n" ; nIdx ; "\r"
            //Append to buffer
            rspBuf$ = rspBuf$ + tmpVar$
        endif
    endif
endfunc rc

//------------------------------------------------------------------------------
// AT+GSDA u,m,hexdata      //Descriptor Add
//------------------------------------------------------------------------------
//function _atPlusGSDA(byref cmdStr$)
//    dim charH, nIdx
//
//    if chrInProg == 0 then
//        exitfunc RSP_ERROR_CHAR_NOTSTARTED
//    endif
//
//    rc = ExtractArgsCSV(cmdStr$, args, 3, 3)
//    if rc != RSP_OK then
//        exitfunc rc
//    endif
//    //Convert to UUID handle index and save in nArg[0]
//    rc = SArgConvertToInt(0, 1, 1, (MAX_UUID_HANDLES-1))
//    if rc != RSP_OK then
//        exitfunc rc
//    endif
//    //Convert to metadata handle index and save in nArg[1]
//    rc = SArgConvertToInt(1, 1, 1, MAX_METADATA_HANDLES)
//    if rc != RSP_OK then
//        exitfunc rc
//    endif
//    //Convert data to binary
//    tmpVar$ = strdehexize$(sArg$[2])
//    if (strlen(tmpVar$) * 2) != strlen(sArg$[2]) then
//        exitfunc RSP_ERROR_INVALID_HEXSTR
//    endif
//
//    DO SOMETHING HERE
//
//endfunc rc

//------------------------------------------------------------------------------
// AT% has been encountered
//------------------------------------------------------------------------------
function _atPERCENT(byref cmdStr$, byref rspBuf$)
    //Extract the command letter and process
    select GetAtCmdLetter(cmdStr$)
    case ATCMD_S, (ATCMD_S + CHR_ASCII_SPACE)
        rc = _atsSTR(cmdStr$, rspBuf$)

    case else
        rc = RSP_ERROR_UNKNOWN_CMD

    endselect
endfunc rc

//------------------------------------------------------------------------------
// AT& has been encountered
//------------------------------------------------------------------------------
function _atAMPERSAND(byref cmdStr$, byref rspBuf$)
    //Extract the command letter and process
    select GetAtCmdLetter(cmdStr$)
    case ATCMD_W, (ATCMD_W + CHR_ASCII_SPACE)
        rc = _atampW(cmdStr$, rspBuf$)

    case ATCMD_F, (ATCMD_F + CHR_ASCII_SPACE)
        rc = _atampF(cmdStr$, rspBuf$)

    case else
        rc = RSP_ERROR_UNKNOWN_CMD

    endselect
endfunc rc

//------------------------------------------------------------------------------
//:/ at+nopn max_buf_len <,writable>
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNOPN(byref cmdStr$)
#cmpif 0x00200000 :     sArg$[0] = ""
#cmpif 0x00200000 :     rc = ExtractArgsCSV(cmdStr$, args, 1, 2)
#cmpif 0x00200000 :     if rc != RSP_OK then
#cmpif 0x00200000 :         exitfunc rc
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :     //Get max_buf_len into nArg[0]
#cmpif 0x00200000 :     rc = SArgConvertToInt(0, NFC_DEFAULT_TAG_SIZE, NFC_MIN_TAG_SIZE, NFC_MAX_TAG_SIZE)
#cmpif 0x00200000 :     if rc != RSP_OK then
#cmpif 0x00200000 :         exitfunc rc
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :     //Get writable into nArg[1]
#cmpif 0x00200000 :     nArg[1] = 0 //default is not writable
#cmpif 0x00200000 :     if args > 1 then
#cmpif 0x00200000 :         rc = SArgConvertToInt(1, 0, 0, 1)
#cmpif 0x00200000 :         if rc != RSP_OK then
#cmpif 0x00200000 :             exitfunc rc
#cmpif 0x00200000 :         endif
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :     //Open NFC and allocate memory for the ndef message
#cmpif 0x00200000 :     rc = NfcOpen(0, "\00", nfcHandle)
#cmpif 0x00200000 :     if rc == 0 then
#cmpif 0x00200000 :         rc = NfcNdefMsgNew(nArg[0], ndefHandle)
#cmpif 0x00200000 :         if rc != 0 then
#cmpif 0x00200000 :             NfcClose(nfcHandle)
#cmpif 0x00200000 :             nfcHandle = INVALID_NFC_HANDLE
#cmpif 0x00200000 :             ndefHandle = INVALID_NDEF_HANDLE
#cmpif 0x00200000 :         endif
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+ncls
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNCLS()
#cmpif 0x00200000 :     if nfcHandle != INVALID_NFC_HANDLE then
#cmpif 0x00200000 :         if ndefHandle != INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :             //Release the ndef message buffer
#cmpif 0x00200000 :             rc = NfcNdefMsgDelete(ndefHandle)
#cmpif 0x00200000 :             ndefHandle = INVALID_NDEF_HANDLE
#cmpif 0x00200000 :             //Close NFC
#cmpif 0x00200000 :             NfcClose(nfcHandle)
#cmpif 0x00200000 :             nfcHandle = INVALID_NFC_HANDLE
#cmpif 0x00200000 :         endif
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 : endfunc 0  //Rc = 0

//------------------------------------------------------------------------------
//:/ at+nrst
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRST()
#cmpif 0x00200000 :     rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :     if nfcHandle != INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :         if ndefHandle != INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :             rc = NfcNdefMsgReset(ndefHandle)
#cmpif 0x00200000 :         endif
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nrat "lang", "message"
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRAT(byref cmdStr$)
#cmpif 0x00200000 :     dim id$, type$, lang$
#cmpif 0x00200000 :     sArg$[0] = ""
#cmpif 0x00200000 :     rc = ExtractArgsCSV(cmdStr$, args, 2, 2)
#cmpif 0x00200000 :     if rc != RSP_OK then
#cmpif 0x00200000 :         exitfunc rc
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :     rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :     if ndefHandle != INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :         //Add a NDEF Record of type "T" and message in language code provided
#cmpif 0x00200000 :         lang$ = "\00"+sArg$[0]
#cmpif 0x00200000 :         rc = strsetchr(lang$, strlen(lang$) - 1, 0)
#cmpif 0x00200000 :         //AssertRC(4248)
#cmpif 0x00200000 :         id$ = ""
#cmpif 0x00200000 :         type$ = "T"
#cmpif 0x00200000 :         StrDeEscape(sArg$[1])
#cmpif 0x00200000 :         rc = NfcNdefRecAddGeneric(ndefHandle, NFC_TNF_WELL_KNOWN, type$, id$, lang$, INVALID_NDEF_HANDLE, sArg$[1])
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nrag tnf, "type", "id", "val0"
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRAG(byref cmdStr$)
#cmpif 0x00200000 :     sArg$[0] = ""
#cmpif 0x00200000 :     rc = ExtractArgsCSV(cmdStr$, args, 4, 4)
#cmpif 0x00200000 :     if rc != RSP_OK then
#cmpif 0x00200000 :         exitfunc rc
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :     //Get tnf into nArg[0]
#cmpif 0x00200000 :     rc = SArgConvertToInt(0, NFC_TNF_UNKNOWN_TYPE, NFC_TNF_EMPTY, NFC_TNF_RESERVED)
#cmpif 0x00200000 :     if rc != RSP_OK then
#cmpif 0x00200000 :         exitfunc rc
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :     rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :     if ndefHandle != INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :         //Add a NDEF Record
#cmpif 0x00200000 :         StrDeEscape(sArg$[1])
#cmpif 0x00200000 :         StrDeEscape(sArg$[2])
#cmpif 0x00200000 :         StrDeEscape(sArg$[3])
#cmpif 0x00200000 :         tmpVar$ = ""
#cmpif 0x00200000 :         rc = NfcNdefRecAddGeneric(ndefHandle, nArg[0], sArg$[1], sArg$[2], sArg$[3], INVALID_NDEF_HANDLE, tmpVar$)
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+ncmt
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNCMT()
#cmpif 0x00200000 :     dim records, memTotal, memUsed
#cmpif 0x00200000 :     rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :     if nfcHandle != INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :         rc = NfcNdefMsgGetInfo(ndefHandle, records, memTotal, memUsed)
#cmpif 0x00200000 :         if rc == 0 then
#cmpif 0x00200000 :             if records > 0 then
#cmpif 0x00200000 :                 rc = NfcNdefMsgCommit(nfcHandle, ndefHandle)
#cmpif 0x00200000 :             else
#cmpif 0x00200000 :                 rc = RSP_ERROR_NFC_NDEF_EMPTY
#cmpif 0x00200000 :             endif
#cmpif 0x00200000 :         endif
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nsen
//:/ at+nsds
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNS_EN_DS(onOff)
#cmpif 0x00200000 :     rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :     if nfcHandle != INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :         rc = NfcFieldSense(nfcHandle, onOff)
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+acmt  //Commit NonVspo advert & scan reports if not in VSP  mode
//------------------------------------------------------------------------------
function _atPlusACMT()
    if (curState == STATE_IDLE_nonVSP) || (curState == STATE_nonVSP_CONNECTED) then
        //Only allow reports to be committed if in non-VSP idle mode or non-VSP connected mode
        IdleAdvCommit()
    else
        exitfunc RSP_ERROR_INCORRECT_MODE
    endif
endfunc 0

//------------------------------------------------------------------------------
//:/ at+aara tag,"data"  //Append AD to NonVsp Advert report
//:/ at+asra tag,"data"  //Append AD to NonVsp Scan report
//------------------------------------------------------------------------------
function _atPlusAxRA(cmdStr$, rpt$)
    rc = ExtractArgsCSV(cmdStr$, args, 2, 2)
    if rc == 0 then
        //Convert the tag to an integer
        rc = SArgConvertToInt(0, -1, 0, 255)    //-1 will result in an error
        if rc != RSP_OK then
            exitfunc rc
        endif
        //De-escape the data
        StrDeEscape(sArg$[1])
        //Finally append to the report
        rc = BleExtAdvRptAppendAD(rpt$, nArg[0], sArg$[1])
    endif
endfunc rc

//------------------------------------------------------------------------------
//:/ at+arst <conn>   //Non Vsp Advert reports reset (conn==0 or 1) default = 1
//:/ at+sfmt <fmt>    //scan advert report format type, default fmt=0
//------------------------------------------------------------------------------
function _atPlusM0O1(byref cmdStr$, cmdId, defval, mn, mx)
    rc = ExtractArgsCSV(cmdStr$, args, 0, 1)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Extract optional parameter
    if args == 1 then
        rc = SArgConvertToInt(0, defval, mn, mx)
        if rc != RSP_OK then
            exitfunc rc
        endif
    else
        nArg[0] = defval
    endif

    select cmdId
    case CMD_MO01_ARST //Arst
        GenAdvCreateMinimal(idleAdvRpt$, idleScnRpt$)
        if nArg[0] == 0 then
            //Not connectable advert so we can remove all AD elements from the ADV report
            idleAdvRpt$ = idleScnRpt$
        endif

    case CMD_MO01_SFMT //Sfmt
        scnFmt = nArg[0]

    case else
    endselect
endfunc rc

//------------------------------------------------------------------------------
//:/ at+bovr conn,accept  //Accept (1) or decline (0) the bond overwrite
//------------------------------------------------------------------------------
function _atPlusBOVR(byref cmdStr$, byref rspBuf$)
    rc = ExtractArgsCSV(cmdStr$, args, 2, 2)
    if rc != 0 then
        exitfunc rc
    endif

    //Convert connection handle to integer and save in nArg[0]
    rc = SArgConvertToInt(0, -1, 0, MAX_CONNECTIONS)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Convert action to integer (decline/accept) and save in nArg[1]
    rc = SArgConvertToInt(1, -1, 0, 1)
    if rc != RSP_OK then
        exitfunc rc
    endif

    rc = BleOverwriteBond(connHandles[nArg[0]], nArg[1])
    #cmpif 0x00000003 : AssertRC(4400)
endfunc rc

//------------------------------------------------------------------------------
//:/ at+adad           //Output advertising address
//:/ at+adad advset    //Output advertising address for specified advert set
//------------------------------------------------------------------------------
function _atPlusADAD(byref cmdStr$, byref rspBuf$)
    rc = ExtractArgsCSV(cmdStr$, args, 0, 1)
    if rc != 0 then
        exitfunc rc
    endif
    if args > 0 then
        if ExtractIntToken(sArg$[0], nArg[0]) == 0 then
            exitfunc RSP_ERROR_SYNTAX_ERROR
        endif
        rc = BleGetAdvertisingAddress$(nArg[0], tmpDta$)
        sprint #tmpVar$, nArg[0]
    else
        rc = BleGetAdvertisingAddress$(0, tmpDta$)
        tmpVar$ = "*"
    endif
    #cmpif 0x00000003 : AssertRC(4422)

    if rc != RSP_OK then
        exitfunc rc
    endif

    rspBuf$ = rspBuf$ + "\nADAD:" + tmpVar$ + ", " + strhexize$(tmpDta$) + "\r"
endfunc rc

//------------------------------------------------------------------------------
//:/ at+pcfg config      //Sets the pair confirmation bitmask value, see the
//                       smartBASIC user guide for your module on the
//                       BleSecMngrPairConf function to see what the values are
//------------------------------------------------------------------------------
function _atPlusPCFG(byref cmdStr$, byref rspBuf$)
    rc = ExtractArgsCSV(cmdStr$, args, 0, 1)
    if rc != 0 then
        exitfunc rc
    endif
    if args > 0 then
        if ExtractIntToken(sArg$[0], nArg[0]) == 0 then
            exitfunc RSP_ERROR_SYNTAX_ERROR
        endif

        rc = BleSecMngrPairConf(nArg[0])
        #cmpif 0x00000003 : AssertRC(4447)
    else
        rc = RSP_ERROR_SYNTAX_ERROR
    endif
endfunc rc

//------------------------------------------------------------------------------
//:/ at+pcnf <conn> <accept> //Responds to a pairing confirmation event for the
//                             specified connection to either accept (1) or
//                             decline (0)
//------------------------------------------------------------------------------
function _atPlusPCNF(byref cmdStr$, byref rspBuf$)
    rc = ExtractArgsCSV(cmdStr$, args, 2, 2)
    if rc != 0 then
        exitfunc rc
    endif

    //Convert connection handle to integer and save in nArg[0]
    rc = SArgConvertToInt(0, -1, 0, MAX_CONNECTIONS)
    if rc != RSP_OK then
        exitfunc rc
    endif

    //Convert action to integer (decline/accept) and save in nArg[1]
    rc = SArgConvertToInt(1, -1, 0, 1)
    if rc != RSP_OK then
        exitfunc rc
    endif

    rc = BlePairingResponse(connHandles[nArg[0]], nArg[1], 0)
    #cmpif 0x00000003 : AssertRC(4477)
endfunc rc

//------------------------------------------------------------------------------
//:/ at+txpo         //Outputs the default connection transmit power
//:/ at+txpo conn    //Outputs the transmission power for the specified connection
//------------------------------------------------------------------------------
function _atPlusTXPO(byref cmdStr$, byref rspBuf$)
    rc = ExtractArgsCSV(cmdStr$, args, 0, 1)
    if rc != 0 then
        exitfunc rc
    endif

    if args > 0 then
        //Convert connection handle to integer and save in nArg[0]
        rc = SArgConvertToInt(0, -1, 0, MAX_CONNECTIONS)
        if rc != RSP_OK then
            exitfunc rc
        endif

        rc = BleTxPowerGet(TRANSMISSION_POWER_ACTIVE_CONNECTION, connHandles[nArg[0]], tmpVar)
        sprint #tmpVar$, nArg[0]
    else
        rc = BleTxPowerGet(TRANSMISSION_POWER_DEFAULT_CONNECTION, 0, tmpVar)
        tmpVar$ = "*"
    endif
    #cmpif 0x00000003 : AssertRC(4503)

    if rc != RSP_OK then
        exitfunc rc
    endif

    rspBuf$ = rspBuf$ + "\nTXPO:" + tmpVar$ + ", "
    sprint #tmpVar$, tmpVar
    rspBuf$ = rspBuf$ + tmpVar$ + "\r"
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+csec <conn>  //Outputs the security for the specified connection, see
//                     the smartBASIC user guide for your module on the
//                     BleGetCurConnParms function to see what the values are
//------------------------------------------------------------------------------
function _atPlusCSEC(byref cmdStr$, byref rspBuf$)
    dim Flags, SecMode, SecLevel
    rc = ExtractArgsCSV(cmdStr$, args, 0, 1)
    if rc != 0 then
        exitfunc rc
    endif

    //Convert connection handle to integer and save in nArg[0]
    rc = SArgConvertToInt(0, -1, 0, MAX_CONNECTIONS)
    if rc != RSP_OK then
        exitfunc rc
    endif

    rc = BleGetCurConnSecInfo(connHandles[nArg[0]], Flags, SecMode, SecLevel)
    #cmpif 0x00000003 : AssertRC(4533)

    if rc != RSP_OK then
        exitfunc rc
    endif

    sprint #tmpVar$, nArg[0]
    rspBuf$ = rspBuf$ + "\nCSEC:" + tmpVar$ + ", "
    sprint #tmpVar$, integer.h'Flags
    RemoveZeros(tmpVar$)
    rspBuf$ = rspBuf$ + tmpVar$ + ", "
    sprint #tmpVar$, SecMode
    rspBuf$ = rspBuf$ + tmpVar$ + ", "
    sprint #tmpVar$, SecLevel
    rspBuf$ = rspBuf$ + tmpVar$ + "\r"
endfunc RSP_OK

//------------------------------------------------------------------------------
// AT+ has been encountered
//------------------------------------------------------------------------------
function _atPLUS(byref cmdStr$, byref rspBuf$)
    dim tmp$

    //Extract the first 4 characters
    tmp$ = StrSplitLeft$(cmdStr$, 4)
    //Convert all data to lower case
    StrToLower$(tmp$)
    //Check what command it is
    if strcmp(tmp$, "sior") == 0 then
        rc = _atPlusSIO(CMD_ACTTYPE_SIOR, cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "siow") == 0 then
        rc = _atPlusSIO(CMD_ACTTYPE_SIOW, cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "sioc") == 0 then
        rc = _atPlusSIO(CMD_ACTTYPE_SIOC, cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "lscn") == 0 then
        rc = _atPlusLSCN(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "lvsp") == 0 then
        rc = _atPlusLVSP(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "ladv") == 0 then
        rc = _atPlusLADV(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "eadv") == 0 then
        rc = _atPlusEADV(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "bndt") == 0 then
        rc = _atPlusBNDT(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "bndp") == 0 then
        rc = _atPlusBNDP(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "bndd") == 0 then
        rc = _atPlusBNDD(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "bndl") == 0 then
        rc = _atPlusBNDL(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "bndx") == 0 then
        rc = _atPlusBNDX(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "lcon") == 0 then
        rc = _atPlusLCON(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "ldsc") == 0 then
        rc = _atPlusCMD_I(CMD_I_LDSC, cmdStr$)

    elseif strcmp(tmp$, "lmtu") == 0 then
        rc = _atPlusCMD_I(CMD_I_LMTU, cmdStr$)

    elseif strcmp(tmp$, "lphy") == 0 then
        rc = _atPlusCMD_I(CMD_I_LPHY, cmdStr$)

    elseif strcmp(tmp$, "pair") == 0 then
        rc = _atPlusCMD_I(CMD_I_PAIR, cmdStr$)

    elseif strcmp(tmp$, "lenc") == 0 then
        rc = _atPlusCMD_I(CMD_I_LENC, cmdStr$)

    elseif strcmp(tmp$, "prsp") == 0 then
        rc = _atPlusPRSP(cmdStr$)

    elseif strcmp(tmp$, "pkey") == 0 then
        rc = _atPlusPKEY(cmdStr$)

    elseif strcmp(tmp$, "oobr") == 0 then
        rc = _atPlusOOBR(cmdStr$)

    elseif strcmp(tmp$, "oobl") == 0 then
        rc = _atPlusOOBL(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "gcrd") == 0 then
        rc = _atPlusGCRD_WR(CMD_GCRDWR_GCRD, cmdStr$)

    elseif strcmp(tmp$, "gcwa") == 0 then  //Write acked
        rc = _atPlusGCRD_WR(CMD_GCRDWR_GCWA, cmdStr$)

    elseif strcmp(tmp$, "gcwc") == 0 then  //Write cmd (not acked)
        rc = _atPlusGCRD_WR(CMD_GCRDWR_GCWC, cmdStr$)

    elseif strcmp(tmp$, "gcfa") == 0 then  //Find attribute of characteristic value or descriptor
        rc = _atPlusGCFA(cmdStr$)

    elseif strcmp(tmp$, "uuid") == 0 then
        rc = _atPlusUUID(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "gsno") == 0 then
        rc = _atPlusCMD_IS(CMD_IS_NOTIFY, cmdStr$)

    elseif strcmp(tmp$, "gsic") == 0 then
        rc = _atPlusCMD_IS(CMD_IS_INDICATE, cmdStr$)

    elseif strcmp(tmp$, "gssb") == 0 then
        rc = _atPlusGSSB_E(CMD_GSSBE_GSSB, cmdStr$)

    elseif strcmp(tmp$, "gsse") == 0 then
        rc = _atPlusGSSB_E(CMD_GSSBE_GSSE, cmdStr$)

    elseif strcmp(tmp$, "gsmd") == 0 then
        rc = _atPlusGSMD(cmdStr$)

    elseif strcmp(tmp$, "gscb") == 0 then
        rc = _atPlusGSCB(cmdStr$)

    elseif strcmp(tmp$, "gsce") == 0 then
        rc = _atPlusGSCE(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "gswc") == 0 then
        rc = _atPlusCMD_IS(CMD_IS_LOCALWRITE, cmdStr$)

    elseif strcmp(tmp$, "arst") == 0 then
        rc = _atPlusM0O1(cmdStr$, CMD_MO01_ARST, 1, 0, 1)

    elseif strcmp(tmp$, "acmt") == 0 then
        rc = _atPlusACMT()

    elseif strcmp(tmp$, "aara") == 0 then
        rc = _atPlusAxRA(cmdStr$, idleAdvRpt$)

    elseif strcmp(tmp$, "asra") == 0 then
        rc = _atPlusAxRA(cmdStr$, idleScnRpt$)

    elseif strcmp(tmp$, "sfmt") == 0 then
        rc = _atPlusM0O1(cmdStr$, CMD_MO01_SFMT, 0, 0, 1)

    elseif strcmp(tmp$, "bovr") == 0 then
        rc = _atPlusBOVR(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "adad") == 0 then
        rc = _atPlusADAD(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "pcfg") == 0 then
        rc = _atPlusPCFG(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "pcnf") == 0 then
        rc = _atPlusPCNF(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "txpo") == 0 then
        rc = _atPlusTXPO(cmdStr$, rspBuf$)

    elseif strcmp(tmp$, "csec") == 0 then
        rc = _atPlusCSEC(cmdStr$, rspBuf$)

//  --------------------------------------------------
// Following only to be added when custom descriptor requirement
// asked for.
//  --------------------------------------------------
//    elseif strcmp(tmp$, "gsda") == 0 then
//        rc = _atPlusGSDA(cmdStr$)
//  --------------------------------------------------

    //Optional Tablemap command
    #cmpif 0x00020000 : elseif strcmp(tmp$, "gctm") == 0 then  //tablemap
    #cmpif 0x00020000 :     rc = _atPlusCMD_I(CMD_I_GCTM, cmdStr$)

    //Optional NFC related commands
    #cmpif 0x00200000 : elseif strcmp(tmp$, "nopn") == 0 then
    #cmpif 0x00200000 :     rc = _atPlusNOPN(cmdStr$)
    #cmpif 0x00200000 :
    #cmpif 0x00200000 : elseif strcmp(tmp$, "ncls") == 0 then
    #cmpif 0x00200000 :     rc = _atPlusNCLS()
    #cmpif 0x00200000 :
    #cmpif 0x00200000 : elseif strcmp(tmp$, "nrst") == 0 then
    #cmpif 0x00200000 :     rc = _atPlusNRST()
    #cmpif 0x00200000 :
    #cmpif 0x00200000 : elseif strcmp(tmp$, "nrat") == 0 then
    #cmpif 0x00200000 :     rc = _atPlusNRAT(cmdStr$)
    #cmpif 0x00200000 :
    #cmpif 0x00200000 : elseif strcmp(tmp$, "nrag") == 0 then
    #cmpif 0x00200000 :     rc = _atPlusNRAG(cmdStr$)
    #cmpif 0x00200000 :
    #cmpif 0x00200000 : elseif strcmp(tmp$, "ncmt") == 0 then
    #cmpif 0x00200000 :     rc = _atPlusNCMT()
    #cmpif 0x00200000 :
    #cmpif 0x00200000 : elseif strcmp(tmp$, "nsen") == 0 then
    #cmpif 0x00200000 :     rc = _atPlusNS_EN_DS(1)
    #cmpif 0x00200000 :
    #cmpif 0x00200000 : elseif strcmp(tmp$, "nsds") == 0 then
    #cmpif 0x00200000 :     rc = _atPlusNS_EN_DS(0)

    else
        //Not a known 'at+' command
        rc = RSP_ERROR_UNKNOWN_CMD
    endif
endfunc rc

//------------------------------------------------------------------------------
// Function for parsing commands when in application command mode and cmdStr$
// is at least 3 characters
//------------------------------------------------------------------------------
sub ParseAtCommand(byref cmdStr$, byref rspBuf$)
    dim tmp$

    //Extract the first 2-characters
    tmp$ = StrSplitLeft$(cmdStr$, 2)
    //Convert all data to lower case
    StrToLower$(tmp$)
    //Check that it is "at"
    if strcmp(tmp$, "at") != 0 then
        //Not an 'at' command
        rc = RSP_ERROR_SYNTAX_ERROR
    else
        //Extract the command letter and process
        select GetAtCmdLetter(cmdStr$)
        case ATCMD_EMPTY
            rc = RSP_OK

        case ATCMD_I, (ATCMD_I + CHR_ASCII_SPACE)
            rc = _ati(cmdStr$, rspBuf$)

        case ATCMD_S, (ATCMD_S + CHR_ASCII_SPACE)
            rc = _ats(cmdStr$, rspBuf$)

        case ATCMD_D, (ATCMD_D + CHR_ASCII_SPACE)
            rc = _atD(cmdStr$, rspBuf$)
            AppendConnRspEnd(rc, rspBuf$)
            exitsub //Because we don't want to hit the AppendRspEnd() at the end of this routine

        case ATCMD_Z, (ATCMD_Z + CHR_ASCII_SPACE)
            reset(0)

        case ATCMD_PERCENT
            rc = _atPERCENT(cmdStr$, rspBuf$)

        case ATCMD_AMPERSAND
            rc = _atAMPERSAND(cmdStr$, rspBuf$)

        case ATCMD_PLUS
            rc = _atPLUS(cmdStr$, rspBuf$)

        case else
            rc = RSP_ERROR_UNKNOWN_CMD

        endselect
    endif

    // Add an OK or ERROR to the response
    AppendRspEnd(rc, rspBuf$)
endsub

//------------------------------------------------------------------------------
// Routine to service command mode, if it returns 0, then it implies exit the application
//------------------------------------------------------------------------------
sub ProcessCommands(byref ORIGRecBuf$, byref RSPSndBuf$)
    dim termPos, cmdStr$

    //Find position of the first \r in the string
    termPos = StrPos(ORIGRecBuf$, termStr$, 0)
    while (atParse) && (termPos >= 0)
        if (termPos == 0) then
            //Empty string so just send OK
            AppendRspEnd(RSP_OK, RSPSndBuf$)
            cmdStr$ = StrSplitLeft$(ORIGRecBuf$, 1)
        else
            //Non empty string
            termPos = termPos + termlen
            cmdStr$ = StrSplitLeft$(ORIGRecBuf$, termPos)

            //Parse and run AT command
            ParseAtCommand(cmdStr$, RSPSndBuf$)
        endif
        //Send out data waiting in buffer
        SendUartData()
        //Find position of the first \r in the string
        termPos = StrPos(ORIGRecBuf$, termStr$, 0)
    endwhile

    if (strlen(ORIGRecBuf$) >= MaxCmdStringSize) then
        //Buffer is full and no newline character has been found, clear buffer and output error response
        ORIGRecBuf$ = ""
        AppendRspEnd(RSP_ERROR_UART_NEWLINE_EXPECTED, RSPSndBuf$)
        SendUartData()
    endif
endsub

//------------------------------------------------------------------------------
// Startup
//------------------------------------------------------------------------------
sub Startup()
    dim scanPat$, i

    //Initial non-VSP connection handle array
    for i = 0 to MAX_CONNECTIONS
        connHandles[i] = INVALID_CONN_HANDLE
    next

    //Initial UUID handle array
    for i = 0 to (MAX_UUID_HANDLES-1)
        uuidHandles[i] = INVALID_UUID_HANDLE
    next

    //Initialise the first metadata handle to 0 and will remain that way
    metaHandles[0] = 0

    //Set SRegister Defaults
    SReg8SetCache()
    SReg16SetCache()
    SReg32SetCache()
    SRegStrSetCache()

    //Wait for Tx buffer to flush
    #cmpif 0x00000001 : while UartInfo(5) > 0
    #cmpif 0x00000001 : endwhile

    //Get start-up flags
    startflags = SRegGet(CfgId_StartupFlags)

    //Get the DLE Attribute length
    dleAttrSz = SRegGet(CfgId_DleAttributeSize)

    //Get the maximum number of VSP packets that can be cached
    vspCachedPkts = SRegGet(CfgId_VspMaxCachedRxPkts)

    //Update config keys and reset if required
    dim nUpdated, newVal[4] : nUpdated = 0

    //Update config keys that affect throughput if enabled
    if ((startflags >> CONFIG_VSP_OPTIMISED_BIT_SHIFT) & CONFIG_VSP_OPTIMISED_BIT_MASK) then
        //Set for optimised VSP mode (max 1 incoming or 1 outgoing connection)
        newVal[IDX_MAX_CONN_AS_SLAVE] = 1                                //Max connection as slave
        newVal[IDX_MAX_CONN_AS_MASTER] = 1                               //Max connection as master
        newVal[IDX_EVENT_LENGTH] = SRegGet(CfgId_EventLength)            //Max event length in VSP conn
    else
        //Not set for optimised VSP mode (max 1 incoming or 1 outgoing connection)
        newVal[IDX_MAX_CONN_AS_SLAVE] = SRegGet(CfgId_MaxConnsAsSlave)   //Max connection as slave
        newVal[IDX_MAX_CONN_AS_MASTER] = SRegGet(CfgId_MaxConnsAsMaster) //Max connection as master
        newVal[IDX_EVENT_LENGTH] = DEFAULT_EVENT_LENGTH                  //Max event length in VSP conn
    endif
    SetConfigKey(MAX_CONNS_SLAVE_KEY_ID,  newVal[IDX_MAX_CONN_AS_SLAVE],  nUpdated)
    SetConfigKey(MAX_CONNS_MASTER_KEY_ID, newVal[IDX_MAX_CONN_AS_MASTER], nUpdated)
    SetConfigKey(BLE_EVENT_LENGTH_PER_CONN_KEY_ID, newVal[IDX_EVENT_LENGTH],     nUpdated)

    //Update Data Length Extension related config keys
    if ((startflags >> CONFIG_VSP_DLE_BIT_SHIFT) & CONFIG_VSP_DLE_BIT_MASK) then
        vspAttrMaxLen = dleAttrSz
    else
        vspAttrMaxLen = DEFAULT_ATTRIBUTE_SIZE
    endif
    newVal[IDX_TRANSMISSION_BUFFERS] = SRegGet(CfgId_TransmissionBuffers)
    SetConfigKey(ATTRIBUTE_DATA_LENGTH_KEY_ID,  vspAttrMaxLen,          nUpdated) //Maximum size of attributes
    SetConfigKey(ATTRIBUTE_MTU_KEY_ID,         (vspAttrMaxLen + 3),     nUpdated) //Maximum size of ATT_MTU
    SetConfigKey(BLE_MAX_PACKET_LENGTH_KEY_ID, (vspAttrMaxLen + 3 + 4), nUpdated) //Maximum size of on-air packet length
    SetConfigKey(BLE_TRANSMISSION_BUFFERS_KEY_ID, newVal[IDX_TRANSMISSION_BUFFERS], nUpdated) //Transmission buffers

    //If any config keys were changed then reset module so they come into effect
    if nUpdated > 0 then
        reset(0)
    endif

    //Cache the long-range VSP flag
    vspLongRange = 0
    if ((startflags >> CONFIG_PHY_BIT_SHIFT) & CONFIG_PHY_BIT_MASK) == 1 then
        vspLongRange = 1
    endif

    //Set default chuck size, it will be negotiated and updated after there is a VSP connection.
    //It will also be reset to the default when there is a VSP  connection.
    vspChunkLen = DEFAULT_ATTRIBUTE_SIZE

    //Setup the UART
    InitUART()
    //If we came alive because of a reset() call earlier, then send an OK
    if sysinfo(2000) == 10 then
        AppendRspEnd(RSP_OK, UARTSndBuf$)
        //Send out data waiting in buffer
        SendUartData()
    endif

    #cmpif 0x00000001 : print "\n## startFlags = 0x";integer.h' startflags
    #cmpif 0x00000004 : DbgMsgVal("AttrMaxLen = ", vspAttrMaxLen)
    #cmpif 0x00000200 : rc = GpioBindEvent(0, BUTTON2, 1)
    #cmpif 0x00000200 : rc = GpioBindEvent(1, BUTTON1, 1)

    //Initialise the GPIO
    InitGPIO()

    //Configure Pairing Capability
    PairingConfig()

    //Initialise the GAP Service
    GapServiceGetDefs()  //into sArg$[] and nArg[]
    rc = GapServiceUpdate()

    //Cache & config scanning parameters
    CacheConfigScanParms()

    //Pre-create the idle more advert reports
    IdleAdvCreate()
    CacheAdvertType() //Cache variable idleAdvType with SReg value
    idleAdvIntvlMs = SRegGet(CfgId_IdleAdvertIntvlMs)

    //Cache the max ^ count
    vspEscCountMax = SRegGet(CfgId_VspEscChrCountMax)
    //Cache the min ^ interval
    vspEscMinIntrvl = SRegGet(CfgId_VspEscChrIntrvlMinMs)

    //VSP escape string in slow connection mode
    vspEscString$ = "^"
    vspEscStringLen = strlen(vspEscString$) + 1 //Added 1 to ensure that if we get 1 more byte then
                                                //we have NOT received the escape sequence

    //Manage 2MPHY change request via app rather than just auto accept the change
    #cmpif    0x00800000 : rc = BleConnectConfig(9, 1)
    #cmpifand 0x00800103 : AssertRC(4959)

    //Get start-up flags
    vspAdded = 0
    //Check if need to make connectable for VSP

    if (startflags & CONFIG_VSP_ENABLED) then
        #cmpif 0x00000004 : DbgMsg("VSP Connectable")
        //Get default parameters
        VspGetDefs()
        //Open the VSP service and variable vspAdded will be updated
        rc = VspOpen()
        if vspAdded != 0 then
            //Create the VSP related Advert report and scan report and commit
            VspAdvCreateCommit()
            //Start Advertising
            VspStartAdverts()
            //Change state
            NewState(STATE_IDLE_VSP)
        endif
    endif
    if vspAdded == 0 then
        //VSP was not added
        if ((startflags & (CONFIG_SCANNING_ENABLED | CONFIG_ADVERTS_ENABLED)) == 0) then
            //Do not start advertising or scanning
            NewState(STATE_IDLE_nonVSP)
            exitsub
        endif
        //Check if adverts to be started
        if ((startflags & CONFIG_ADVERTS_ENABLED) == CONFIG_ADVERTS_ENABLED) then
            //Need to start advertising in idle
            IdleAdvCommit()
            //Start Advertising
            IdleStartAdverts(idleAdvType, idleAdvIntvlMs)
            //#cmpif 0x00000004 : DbgMsg("IDLE_ADV_SCN adverts started")
        endif
        //Check if scanning to be started
        if ((startflags & CONFIG_SCANNING_ENABLED) == CONFIG_SCANNING_ENABLED) then
            //Need to start scanning in idle
            scanPat$ = SRegGetStr$(CfgIdStr_ScanPattern)
            rc = ScanningStart(0, scanPat$, SRegGet(CfgId_ScanRssiMinimum), SCANTYPE_VSP_MODE)
            //#cmpif 0x00000004 : DbgMsg("IDLE_ADV_SCN scanning started")
        endif
        //Change state
        advPrefix$ = "\nAD0:"
        NewState(STATE_IDLE_nonVSP)
    endif
endsub

//******************************************************************************
// Handlers
//******************************************************************************

//------------------------------------------------------------------------------
// In Command mode and data has arrived from the UART
//------------------------------------------------------------------------------
function HndlrUartCommand()
    //Data received from UART
    tmpVar = UARTReadN(UARTRecBuf$, MaxCmdStringSize)
    ProcessCommands(UARTRecBuf$, UARTSndBuf$)
endfunc 1

//------------------------------------------------------------------------------
// Called when scanning has timed out
//------------------------------------------------------------------------------
function HndlrScanTimeout() as integer
    #cmpif 0x00000004 : DbgMsg("Scan Timeout")

    if curState == STATE_SCAN_VSP then
        rc = BleScanAbort()

        IdleReturnAction()

        //Send an OK response
        AppendRspEnd(RSP_OK, UARTSndBuf$)
        //Send out data waiting in buffer
        SendUartData()
        //Also trigger a reprocessing of the UART buffer just in case
        rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
    else
        //Send a 'scanend' response
        SendScanEnd(UARTSndBuf$)
    endif
endfunc 1

//------------------------------------------------------------------------------
// This handler is called when a connection attempt has timeout
//------------------------------------------------------------------------------
function HndlrConnTout()
    #cmpif 0x00000004 : DbgMsg("Connect Timeout")
    select curState
    case STATE_VSP_CONNECTING
        VspNoCarrierRet(CONN_ERROR_TIMEOUT)

    case STATE_nonVSP_CONNECTING
        if connCount <= 0 then
            //First outgoing non-VSP connection
            SioConnDeassert()
            NonVspDisconRet(CONN_ERROR_TIMEOUT, 0)    //will take us back to the idle state
        else
            //Multiple non-VSP connections
            //send an DISCON response
            SendNonVspDiscon(CONN_ERROR_TIMEOUT, 0, UARTSndBuf$)
            //Change state
            NewState(STATE_nonVSP_CONNECTED)
            //Also trigger a reprocessing of the UART buffer just in case
            rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
        endif

    case else
    endselect
endfunc 1

//------------------------------------------------------------------------------
// Helper routine to display the advert information
dim _display, _adType  //To only be used by the following functions
//------------------------------------------------------------------------------
sub HelperShowReport(adtyp, prefix$)
    #cmpif 0x00000400 : print "\n## Adv = ";strhexize$(advData$)
    _display = 0
    if nRssi > scnRssi then
        if scnPatternLen > 0 then
            if strpos(advData$, scnPattern$, 0) >= 0 then
                //RSSI is above threshold and pattern found
                _display = 1
            endif
        else
            //RSSI is above threshold and no pattern specified
            _display = 1
        endif
    endif
    if _display then
        #cmpif 0x00400000 : UartReOpen()
        print prefix$;adtyp;" ";StrHexize$(periphAddr$);" ";nRssi
        select scnFmt
        case 1
            print " \22"; StrHexize$(advData$);"\22\r"

        case else
            rc = BleGetADBytag(advData$, 0x09, nme$)
            print " \22"; nme$ ; "\22\r";
        endselect
    endif
endsub

//------------------------------------------------------------------------------
// This handler is called when there at least one scan response waiting to be read
//------------------------------------------------------------------------------
function HndlrAdvReport()
    //Read all cached advert reports
    rc = BleScanGetAdvReportEx(_adType, periphAddr$, advData$, nDiscarded, nRssi, tmpVar)
    while (rc == 0)
        HelperShowReport(_adType, advPrefix$)
        rc = BleScanGetAdvReport(periphAddr$, advData$, nDiscarded, nRssi)
    endwhile
endfunc 1

//------------------------------------------------------------------------------
// This handler is called when there is an extended advert report
//------------------------------------------------------------------------------
function HndlrExtAdvRpt(byval ad$, byval dta$, rsi, byval metadata$)
    advData$ = dta$
    periphAddr$ = ad$
    nRssi = rsi
    HelperShowReport(0, eadvpfx$)
endfunc 1

//------------------------------------------------------------------------------
// This handler is called when there is an extended advert report
//------------------------------------------------------------------------------
function HndlrExtScnRpt(byval ad$, byval dta$, rsi, byval metadata$)
    advData$ = dta$
    periphAddr$ = ad$
    nRssi = rsi
    HelperShowReport(0, escnpfx$)
endfunc 1

//------------------------------------------------------------------------------
// Disconnect
//------------------------------------------------------------------------------
function HndlrDisCon(hndl as integer, rsn as integer)
    #cmpif 0x00000004 : DbgMsg("Disconnect")

    select curState
    case STATE_VSP_DISCONNECTING, STATE_VSP_PAIRING, STATE_VSP_CARET_CONNECTED, STATE_VSP_FAST_CONNECTED
        //Disable VSP-related event handlers
        OnEvent EVNOTIFYBUF disable
        OnEvent EVATTRNOTIFY disable
        OnEvent EVUARTTXEMPTY disable
        OnEvent EVVSPRX disable
        OnEvent EVVSPTXEMPTY disable
        OnEvent EVUARTTXEMPTY disable

        //Clear UART buffer
        UARTRecBuf$ = ""

        //Some other error while writing to a cccd
        if vspDisconSts <= 0 then
            //Assume a normal disconnection has happened
            vspDisconSts = CONN_ERROR_USER_DISCON
        endif
        //De-assert DCD
        VspDcdDeassert()
        //Send response
        VspNoCarrierRet(vspDisconSts)
        connHandles[HCONN_VSP] = INVALID_CONN_HANDLE

    case STATE_nonVSP_CONNECTING, STATE_nonVSP_CONNECTED
        dim nodeIdx : nodeIdx = GetIdxFromHConn(hndl)
        if nodeIdx == 0 then
            //Ignore this because we were not track that connection
        else
            if connCount <= 1 then    //Comparing against 1 because it decremented at the end of this routine
                //First outgoing non-VSP connection
                SioConnDeassert()
                NonVspDisconRet(rsn, nodeIdx)    //Will take us back to the idle state
            else
                //Multiple non-VSP connections
                //Send an DISCON response
                SendNonVspDiscon(rsn, nodeIdx, UARTSndBuf$)
                //Also trigger a reprocessing of the UART buffer just in case
                rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
            endif
            connHandles[nodeIdx] = INVALID_CONN_HANDLE
            connIsEncrypted[nodeIdx] = FALSE
            SioEncrDeassert()
        endif

    case else
        //De-assert DCD
        VspDcdDeassert()
        //Send response
        VspNoCarrierRet(rsn)
        connHandles[HCONN_VSP] = INVALID_CONN_HANDLE
    endselect

    if connCount > 0 then
        //Decrement the connection count
        connCount = connCount - 1
    endif
endfunc 1

//------------------------------------------------------------------------------
// CCCD Descriptor found via BleGattcFindDesc()
//------------------------------------------------------------------------------
function HndlrFindDesc(hConn, hAttr)
    //#cmpif 0x00000004 : DbgMsgVal("EvFindDesc hAttr = ", hAttr)

    select curState
    case STATE_VSP_GET_HANDLES
        SvcFindCharDescEv(hConn, hAttr)

    case STATE_nonVSP_CONNECTED
        //Get connection index from conn handle
        tmpVar = GetIdxFromHConn(hConn)
        sprint #tmpVar$, "\nFD:";tmpVar;", ";hAttr;"\r"
        SendUartDataEx(tmpVar$)

    case else
    endselect
endfunc 1

//------------------------------------------------------------------------------
// Characteristic found via BleGattcFindChar()
//------------------------------------------------------------------------------
function HndlrFindChar(hConn, cProp, hAttr, hIncSvcUuid)
    //#cmpif 0x00000004 : DbgMsgVal("EvFindChar hAttr = ", hAttr)

    select curState
    case STATE_VSP_GET_HANDLES
        SvcFindCharDescEv(hConn, hAttr)

    case STATE_nonVSP_CONNECTED
        //Get connection index from conn handle
        tmpVar = GetIdxFromHConn(hConn)
        sprint #tmpVar$, "\nFC:";tmpVar;", ";hAttr;", ";cProp;"\r"
        SendUartDataEx(tmpVar$)

    case else
    endselect
endfunc 1

//------------------------------------------------------------------------------
// UART data received in VSP fast connected state (as master)
//------------------------------------------------------------------------------
function HndlrUartRxVspOutFC()
    //Check if there is a pending modem characteristic value that wasn't sent
    if (vspMdmSendFail != VSP_MDM_FAIL_CACHE_NONE) then
        VspMasterRtsSend(vspMdmSendFail)
    endif

    //Read data that has arrived through via the UART
    if (vspAllowTx == 1) then
        do
            tmpVar = UartReadN(UARTRecBuf$, vspChunkLen)

            if tmpVar > 0 then
                rc = BleGattcWriteCmd(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_RX], UARTRecBuf$)

                select rc

                case ERROR_SUCCESS
                    StrShiftLeft(UARTRecBuf$, tmpVar)
                    #cmpif 0x00000040 : vtxcnt = vtxcnt + tmpVar

                //Wait for a BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event and retry which is EVNOTIFYBUF in sb
                case ERROR_BLE_NO_TX_BUFFERS, ERROR_BLE_RESOURCES
                    exitfunc 1

                case ERROR_BLE_DATA_SIZE
                    tmpVar$ = StrSplitLeft$(UARTRecBuf$, vspChunkLen)
                    rc = BleGattcWriteCmd(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_RX], tmpVar$)
                    if rc != 0 then
                        //Did not manage to send it, so put it back in the original buffer (at the beginning)
                        UARTRecBuf$ = tmpVar$+UARTRecBuf$
                        if (rc == ERROR_BLE_NO_TX_BUFFERS) || (rc == ERROR_BLE_RESOURCES) then
                            exitfunc 1
                        endif
                        #cmpif 0x00000040 : else
                        #cmpif 0x00000040 :     vtxcnt = vtxcnt + tmpVar
                    endif

                //Some other error, so just exit
                case else
                    exitfunc 1

                endselect
            endif
        dowhile (tmpVar > 0)
    endif
endfunc 1

//------------------------------------------------------------------------------
// UART data received in VSP slow connected state (as master)
//------------------------------------------------------------------------------
function HndlrUartRxVspOutSC()
    //Check number of bytes in receive buffer
    tmpVar = UartInfo(3)
    if tmpVar == 1 then
        if (PollForEscapeSeq() == 0) then    //On exit tmpVar$ contains what was read
            //Disconnected connection so exit out
            exitfunc 1
        endif
        UARTRecBuf$ = UARTRecBuf$+tmpVar$
    endif
endfunc HndlrUartRxVspOutFC()

//------------------------------------------------------------------------------
// A write to an attribute has been acked/nacked
//------------------------------------------------------------------------------
function HandlerAttrWrite(hConn, hAttr, xSts)
    //#cmpif 0x00000004 : print "\n## EvAttrWrite hAttr = ";hAttr;" sts = ";xSts

    select curState
    case STATE_VSP_WRITE_CCCDS
        //Save status for later use
        vspDisconSts = nSts
        //Check status
        if xSts == 0 then
            //#cmpif 0x00000004 : DbgMsg("EvAttrWrite OK")
            //A cccd was successfully written, so check for next
            vspFindIndex = vspFindIndex + 1
            if vspFindIndex >= VSP_ATTR_MAX_INDEXES then
                //All cccd's written
                vspIsOutGoing = TRUE
                VspEnterConnState(MSGAPP_ENTER_VSPOUT_CONN_STATE)
            else
                //There could be more cccd's to enable
                rc = CccdsEnable()
                if rc == 0 then
                    //There were no more cccd's to enable
                    vspIsOutGoing = TRUE
                    VspEnterConnState(MSGAPP_ENTER_VSPOUT_CONN_STATE)
                else
                    //A write has been sent to a cccd, remain in this state
                    //NOTHING TO DO
                endif
            endif
        elseif (Is_Encr_Required(xSts) != 0) && (pairIoCapCache == 0) then
            #cmpif 0x00000004 : DbgMsg("EvAttrWrite Encr Req ** Start PAIRING")
            //The link requires encryption, and configured for just works
            rc = BlePair(hConn, 1)
            #cmpif 0x00000003 : AssertRC(5341)
            //Change state
            NewState(STATE_VSP_PAIRING)
        else
            #cmpif 0x00000004 : DbgMsgVal("EvAttrWrite other err", xSts)
            //Some other error, so just drop the connection
            vspDisconSts = CONN_ERROR_AUTHLINK_REQUIRED
            rc = BleDisconnect(hConn)
            //Change state
            NewState(STATE_VSP_DISCONNECTING)
        endif

    case STATE_VSP_FAST_CONNECTED, STATE_VSP_CARET_CONNECTED
        //And immediately send more data if we can
        rc = HndlrUartRxVspOutFC()

    case STATE_nonVSP_CONNECTED
        dim nIdx
        //Get connection index from conn handle
        nIdx = GetIdxFromHConn(hConn)
        sprint #tmpVar$, "\nAW:";nIdx;", ";xSts;"\r"
        SendUartDataEx(tmpVar$)

    case else
    endselect
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function HndlrAttrRead(hConn, hAttr, xSts) as integer
    dim a$, ofst, nIdx
    //Get connection index from conn handle
    nIdx = GetIdxFromHConn(hConn)
    if xSts == 0 then
        //We have a successful read
        rc = BleGattcReadData(hConn, hAttr, ofst, a$)
        if rc == 0 then
            sprint #tmpVar$, "\nAR:";nIdx;", ";ofst;", ";StrHexize$(a$);"\r"
        else
            sprint #tmpVar$, "\nAB:";nIdx;", ";integer.h' rc;"\r"
        endif
    else
        //Failed to read
        sprint #tmpVar$, "\nAS:";nIdx;", ";xSts;"\r"
    endif
    SendUartDataEx(tmpVar$)
endfunc 1

//------------------------------------------------------------------------------
// Called wheh UART Tx buffer is empty in VSP fast mode
//------------------------------------------------------------------------------
function HndlrUartTxEmptyOut()
    VspMasterRtsSend(1)
    SendUartData()
endfunc 1

//------------------------------------------------------------------------------
// VSP (air-side) data received in VSP fast connected state
//------------------------------------------------------------------------------
function HndlrNotifyVspOut()
    dim hConn, hAttr, aData$, discard, wrLen
    rc = BleGattcNotifyRead(hConn, hAttr, aData$, discard)
    while (rc == 0)
        if (hAttr == hVspAttr[VSP_ATTR_INDEX_TX]) then
            //Data has arrived
            SendUartDataEx(aData$)
            if strlen(UARTSndBuf$) > 0 then
                VspMasterRtsSend(0)
            endif
        elseif (hAttr == hVspAttr[VSP_ATTR_INDEX_MDMOUT]) then
            //Modem Out from peer changed
            if (strcmp(aData$, "\01") == 0) then
                #cmpif 0x00000040 : print "\n+MDM+ ";vtxcnt
                vspAllowTx = 1
                rc = HndlrUartRxVspOutFC()
            else
                #cmpif 0x00000040 : print "\n-MDM- ";vtxcnt
                vspAllowTx = 0
            endif
        endif
        rc = BleGattcNotifyRead(hConn, hAttr, aData$, discard)
    endwhile
endfunc 1

//------------------------------------------------------------------------------
// Non-VSP connection received a notify
//------------------------------------------------------------------------------
function HndlrNotifyNonVsp()
    dim hConn, hAttr, aData$, discard, wrLen, nIdx
    do
        rc = BleGattcNotifyRead(hConn, hAttr, aData$, discard)
        if rc != 0 then
            exitfunc 1
        endif
        nIdx = GetIdxFromHConn(hConn)
        if nIdx > 0 then
            sprint #tmpVar$, "\nIN:";nIdx;", ";hAttr;", ";StrHexize$(aData$);"\r"
            SendUartDataEx(tmpVar$)
        endif
    dowhile(1)
endfunc 1

//------------------------------------------------------------------------------
// Waited too long for VSP connection to be encrypted do just drop the connection
//------------------------------------------------------------------------------
function HndlrTmrWaitEncr()
    if curState == STATE_VSP_IN_WAIT_ENCR then
        vspDisconSts = CONN_ERROR_UNENCRYPTED
        //Some other error, so just drop the connection
        rc = BleDisconnect(connHandles[HCONN_VSP])
        //Change state
        NewState(STATE_VSP_DISCONNECTING)
    endif
endfunc 1

//------------------------------------------------------------------------------
// Function called when there is a VSP overrun
//------------------------------------------------------------------------------
function HndlrVspRxOverrun()
    #cmpif 0x00000080 : print "\n## VspRx Overrun, UARTtx space = ";UARTinfo(4);"\n"
endfunc 1

//------------------------------------------------------------------------------
// Function for bridging data between the VSP service and the UART in FAST mode
//------------------------------------------------------------------------------
function HndlrBridgeInF()
        //Pass data between UART and VSP service
        BleVspUartBridge()
endfunc 1

//------------------------------------------------------------------------------
// Function for bridging data between the VSP service and the UART in SLOW mode
//------------------------------------------------------------------------------
function HndlrBridgeInS()
    //Pass data between UART and VSP service
    dim uLen

    #cmpif 0x00400000 : //If there is data in the VSP Rx buffer then it will get transferred to
    #cmpif 0x00400000 : //the UART so we need to reopen UART just in case
    #cmpif 0x00400000 : if BleVspInfo(3) then
    #cmpif 0x00400000 :     UartReOpen()
    #cmpif 0x00400000 : endif

    //Check space in VSP Tx buffer
    if BleVspInfo(4) >= MIN_SPACE_IN_VSPTXBUF_TO_CHECK_FOR_CARETS then
        //Check number of bytes in receive buffer
        uLen = UartInfo(3)
        if uLen == 1 then
            if (PollForEscapeSeq() == 0) then    //On exit tmpVar$ contains what was read from UART
                //Disconnected, so exit out
                exitfunc 1
            endif

            rc = BleVspWrite(tmpVar$)
        endif
    endif
    BleVspUartBridge()
endfunc 1

//------------------------------------------------------------------------------
// This will be called with the cmd mode pin transitions from 0 to 1
//------------------------------------------------------------------------------
function HndlrVspCmdMode()
    select curState
    case STATE_VSP_FAST_CONNECTED
        //Disconnect
        vspDisconSts = CONN_ERROR_USER_DISCON
        //Some other error, so just drop the connection
        rc = BleDisconnect(connHandles[HCONN_VSP])
        //Change state
        NewState(STATE_VSP_DISCONNECTING)

    case else
    endselect
endfunc 1

//------------------------------------------------------------------------------
// This will be called with the cmd mode pin transitions from 0 to 1 which is
// repurposed in low power mode to reopen the UART
//------------------------------------------------------------------------------
#cmpif    0x00400000 : function HndlrReopenUart()
#cmpif    0x00400000 :     UartReOpen()
#cmpifand 0x00400104 :     DbgMsg("Uart reopened")
#cmpif    0x00400000 : endfunc 1

//------------------------------------------------------------------------------
// BLE message
//------------------------------------------------------------------------------
function HndlrBleMsg(nMsgId, nCtx)
    select nMsgId
    case BLE_EVBLEMSGID_CONNECT
        OnConnect(nCtx)

    case BLE_EVBLEMSGID_ENCRYPTED
        OnEncrypted(nCtx)

    case BLE_EVBLEMSGID_UNENCRYPTED
        OnUnencrypted(nCtx)

    #cmpif 0x00000004 : case BLE_EVBLEMSGID_NEW_BOND
    #cmpif 0x00000004 :     DbgMsg("New Bond")

    #cmpif 0x00000004 : case BLE_EVBLEMSGID_UPDATED_BOND
    #cmpif 0x00000004 :     DbgMsg("Updated Bond")

    #cmpif 0x00000004 : case BLE_EVBLEMSGID_BOND_ADDFAIL
    #cmpif 0x00000004 :     DbgMsg("Bond add FAILED")

    #cmpif 0x00000004 : case BLE_EVBLEMSGID_LESC_PAIRING
    #cmpif 0x00000004 :     DbgMsg("LESC Pairing")

    case BLE_EVBLEMSGID_LESC_OOB_REQUEST
        #cmpif 0x00000004 :     DbgMsgVal("LESC OOB Request", nCtx)
        SendAuthInfoReq(nCtx, BLE_GAP_AUTH_KEY_TYPE_LESC_OOB, UARTSndBuf$)

    #cmpif 0x00000004 : case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
    #cmpif 0x00000004 :     DbgMsg("Conn to Bonded Master ")

    #cmpif 0x00000008 : case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
    #cmpif 0x00000008 :     ShowConnParms(nCtx)

    #cmpif 0x00000004 : case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
    #cmpif 0x00000004 :     DbgMsg("Conn Parm Negotiation FAILED")

    case BLE_EVBLEMSGID_AUTHENTICATION_FAILED
        #cmpif 0x00000004 : DbgMsgVal("Authentication FAILED", nCtx)

    case BLE_EVBLEMSGID_AUTHENTICATION_SUCCESSFUL
        #cmpif 0x00000004 : DbgMsgVal("Authentication successful", nCtx)

    case BLE_EVBLEMSGID_CONFIRM_PAIRING
        #cmpif 0x00000004 : DbgMsgVal("Confirm Pairing", nCtx)
        dim Initiator, Flags, IOCap, MinKeySize, MaxKeySize
        rc = BlePairingInfo(nCtx, Initiator, Flags, IOCap, MinKeySize, MaxKeySize, tmpVar)
        #cmpif 0x00000003 : AssertRC(5575)
        if (rc == 0) then
            tmpVar = GetIdxFromHConn(nCtx)
            sprint #tmpDta$, integer.h'Flags
            RemoveZeros(tmpDta$)
            sprint #tmpVar$, "\nCP:";tmpVar;", ";Initiator;", ";tmpDta$;", ";IOCap;", ";MinKeySize;", ";MaxKeySize;"\r"
            SendUartDataEx(tmpVar$)
        else
            //Failed to fetch details, disconnect device
            rc = BleDisconnect(nCtx)
            #cmpif 0x00000003 : AssertRC(5585)
        endif

    case BLE_EVBLEMSGID_CONFIRM_TIMED_OUT
        #cmpif 0x00000004 : DbgMsg("Confirm pairing timeout")

    case else
        #cmpif 0x00000004 : DbgMsgVal("Unprocessed nMsgId", nMsgId)
    endselect
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x00020000 : function HandlerPrimSvc(hConn, hUuid, hStart, hEnd) as integer
#cmpif 0x00020000 :     if hStart != 0 then
#cmpif 0x00020000 :         //S: hStart,(hEnd),hUuid
#cmpif 0x00020000 :         sprint #tmpVar$, "\nTM:S:";hStart;", (";hEnd;"), ";integer.h' hUuid;"\r"
#cmpif 0x00020000 :         SendUartDataEx(tmpVar$)
#cmpif 0x00020000 :         if hStart == hEnd then
#cmpif 0x00020000 :             //The service is empty so move on to next service
#cmpif 0x00020000 :             rc = BleDiscServiceFirst(hConn, (hEnd + 1), 0)
#cmpif 0x00020000 :             if rc != 0 then
#cmpif 0x00020000 :                 TerminateTableMap(rc)
#cmpif 0x00020000 :             endif
#cmpif 0x00020000 :         else
#cmpif 0x00020000 :             //And get all characteristics of this service
#cmpif 0x00020000 :             rc = BleDiscCharFirst(hConn, 0, hStart, hEnd)
#cmpif 0x00020000 :             if rc != 0 then
#cmpif 0x00020000 :                 TerminateTableMap(rc)
#cmpif 0x00020000 :             endif
#cmpif 0x00020000 :         endif
#cmpif 0x00020000 :     else
#cmpif 0x00020000 :         //Reached end of remote GATT table
#cmpif 0x00020000 :         TerminateTableMap(0)
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 : endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x00020000 : function HandlerCharDisc(hConn, hUuid, cProp, hVal, hiUuid) as integer
#cmpif 0x00020000 :     if hVal != 0 then
#cmpif 0x00020000 :         //C: hVal,cProp,hUuid,hiUuid
#cmpif 0x00020000 :         sprint #tmpVar$, "\nTM: C:";hVal;", ";integer.h' cProp;", ";integer.h' hUuid;", ";hiUuid;"\r"         //use SendUartData instead
#cmpif 0x00020000 :         SendUartDataEx(tmpVar$)
#cmpif 0x00020000 :         //And get all descriptors of this characteristics
#cmpif 0x00020000 :         rc = BleDiscDescFirst(hConn, 0, hVal)
#cmpif 0x00020000 :         if rc != 0 then
#cmpif 0x00020000 :             TerminateTableMap(rc)
#cmpif 0x00020000 :         endif
#cmpif 0x00020000 :     else
#cmpif 0x00020000 :         //No more chars in this service, so go for next service
#cmpif 0x00020000 :         rc = BleDiscServiceNext(hConn)
#cmpif 0x00020000 :         if rc != 0 then
#cmpif 0x00020000 :             TerminateTableMap(rc)
#cmpif 0x00020000 :         endif
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 : endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#cmpif 0x00020000 : function HandlerDescDisc(hConn, hUuid, hDesc) as integer
#cmpif 0x00020000 :     if hDesc != 0 then
#cmpif 0x00020000 :         //D: hDesc,hUuid
#cmpif 0x00020000 :         sprint #tmpVar$, "\nTM:  D:";hDesc;", ";integer.h' hUuid;"\r"         //use SendUartData instead
#cmpif 0x00020000 :         SendUartDataEx(tmpVar$)
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :     //And get all descriptors of this characteristics
#cmpif 0x00020000 :     rc = BleDiscDescNext(hConn)
#cmpif 0x00020000 :     if rc != 0 then
#cmpif 0x00020000 :         //No more descc in this char, so go for next char
#cmpif 0x00020000 :         rc = BleDiscCharNext(hConn)
#cmpif 0x00020000 :         if rc != 0 then
#cmpif 0x00020000 :             rc = BleDiscServiceNext(hConn)
#cmpif 0x00020000 :             if rc != 0 then
#cmpif 0x00020000 :                 TerminateTableMap(rc)
#cmpif 0x00020000 :             endif
#cmpif 0x00020000 :         endif
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 : endfunc 1

//------------------------------------------------------------------------------
// This handler is called when there when an Indicate is acknowledged
//------------------------------------------------------------------------------
function HndlrCharHvc(BYVAL hChar AS INTEGER) as integer
    charIdx = GetIdxFromHChar(hChar)
    if charIdx > 0 then
        sprint #tmpVar$, "\nAK:";charIdx;"\r"
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function HndlrCharVal(BYVAL hChar AS INTEGER, byval offset, byval len) as integer
    charIdx = GetIdxFromHChar(hChar)
    if charIdx > 0 then
        rc = BleCharValueRead(hChar, tmpDta$)
        sprint #tmpVar$, "\nWR:";charIdx;", ";StrHexize$(tmpDta$);"\r"
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function HndlrCharCccd(BYVAL hChar AS INTEGER, BYVAL nVal AS INTEGER) as integer
    charIdx = GetIdxFromHChar(hChar)
    if charIdx > 0 then
        sprint #tmpVar$, "\nCC:";charIdx;", ";nVal;"\r"
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function HndlrCharSccd(BYVAL hChar AS INTEGER, BYVAL nVal AS INTEGER) as integer
    charIdx = GetIdxFromHChar(hChar)
    if charIdx > 0 then
        sprint #tmpVar$, "\nSC:";charIdx;", ";nVal;"\r"
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//------------------------------------------------------------------------------
// This handler is called process an event thrown by this application used
// for serialisation
//------------------------------------------------------------------------------
function HndlrMessageApp(nMsgId, nCtx)
    select nMsgId
    case MSGAPP_PROCESS_UART
        //Process the UART as if we just got some UART activity
        OnEvent EVUARTRX Call HndlrUartCommand
        rc = HndlrUartCommand()

    case MSGAPP_ENTER_NONVSP_CONN_STATE
        OnEvent EVATTRNOTIFY Call HndlrNotifyNonVsp
        //Assert the active connection indication pin
        SioConnAssert()
        //Also trigger a reprocessing of the UART buffer just in case
        rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)

    case MSGAPP_ENTER_VSPOUT_CONN_STATE  //NCTx is the new state to enter
        #cmpif 0x00000004 : DbgMsg("Going For VSPOUT")
        //Allow TX
        vspAllowTx = 1
        //Assert DCD
        VspDcdAssert()
        //Send the connect response
        AppendConnRspEnd(CONN_OK, UARTSndBuf$)
        //Send out data waiting in buffer
        SendUartData()
        //Change UART and VSP handlers
        if nCtx == STATE_VSP_FAST_CONNECTED then
            #cmpif 0x00000004 : DbgMsg("HndlrUartRxVspOutFC")
            OnEvent EVUARTRX    Call HndlrUartRxVspOutFC
            OnEvent EVNOTIFYBUF Call HndlrUartRxVspOutFC
        else
            #cmpif 0x00000004 : DbgMsg("HndlrUartRxVspOutSC")
            OnEvent EVUARTRX    Call HndlrUartRxVspOutSC
            OnEvent EVNOTIFYBUF Call HndlrUartRxVspOutFC  //Not HndlrUartRxVspOutSC because escape seq cannot be sent by peer
        endif

        OnEvent EVATTRNOTIFY  Call HndlrNotifyVspOut
        OnEvent EVUARTTXEMPTY Call HndlrUartTxEmptyOut

        //Enable incoming data from peer
        VspMasterRtsSend(1)
        //Change state
        NewState(nCtx)

    case MSGAPP_ENTER_VSPIN_CONN_STATE  //NCTx is the new state to enter
        #cmpif 0x00000004 : DbgMsg("Going For VSPIN")
        //Assert DCD
        VspDcdAssert()
        //Send the connect response
        AppendConnRspEnd(CONN_OK, UARTSndBuf$)
        //Send out data waiting in buffer
        SendUartData()
        //Change UART and VSP handlers
        #cmpif 0x00080000 : OnEvent EVVSPRXOVRN Call HndlrVspRxOverrun

        if nCtx == STATE_VSP_FAST_CONNECTED then
            #cmpif 0x00000004 : DbgMsg("HndlrUartRxVspInFC")
            OnEvent EVVSPRX       Call HndlrBridgeInF
            OnEvent EVUARTRX      Call HndlrBridgeInF
            OnEvent EVVSPTXEMPTY  Call HndlrBridgeInF
            OnEvent EVUARTTXEMPTY Call HndlrBridgeInF
            //Start bridging cached data
            rc = HndlrBridgeInF()
        else
            #cmpif 0x00000004 :     DbgMsg("HndlrUartRxVspInSC")
            OnEvent EVVSPRX       Call HndlrBridgeInS
            OnEvent EVUARTRX      Call HndlrBridgeInS
            OnEvent EVVSPTXEMPTY  Call HndlrBridgeInS
            OnEvent EVUARTTXEMPTY Call HndlrBridgeInS
            //Start bridging cached data
            rc = HndlrBridgeInS()
        endif
        //Change state
        NewState(nCtx)

    case else
        //Do nothing
    endselect
endfunc 1

//==============================================================================
// This handler is called when the packet length is changed
//==============================================================================
function HandlerPacketLength(BYVAL hConn, BYVAL Tx_Octets, BYVAL Tx_Time, BYVAL Rx_Octets, BYVAL Rx_Time)
    #cmpif 0x00000010 :    print "\n## Pkt-Len_Chg: Tx(Len = ";Tx_Octets;" Time = ";Tx_Time;"us) Rx(Len = ";Rx_Octets;" Time = ";Rx_Time;"us)"
    //Not vspChunkLen is == Tx_Octets-7

    //If this is a VSP connection then update the PHY if not 1MPHY
    if hConn == connHandles[HCONN_VSP] then
        if vspIsOutGoing != FALSE then
            rc = ChangePhy(hConn)
            #cmpif 0x00000001 :    print "\n## ChangePhy() ret:";integer.h' rc
        endif
    endif
endfunc 1

//==============================================================================
// This handler is called when there is an event that the attribute MTU has changed
//==============================================================================
function HandlerAttrMTU(BYVAL hCOnn AS INTEGER, BYVAL nSize AS INTEGER)
    #cmpif 0x00000010 :    print "\n## Attribute MTU Changed to Size:";nSize
    vspChunkLen = nSize-3

    //Get connection index from conn handle and send async response if non-VSP
    tmpVar = GetIdxFromHConn(hConn)
    if tmpVar != HCONN_VSP then
        sprint #tmpVar$, "\nMT:";tmpVar;", ";vspChunkLen;"\r"
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//==============================================================================
// This handler is called when remote is requesting a switch to a different PHY
//==============================================================================
function HandlerPhyRequest(BYVAL hConn, BYVAL PhyTx, BYVAL PhyRx)
    #cmpif    0x00000010 : print "\n## BLE PHY REQUEST: (PhyTx = ";PhyTx;" PhyRx = ";PhyRx;")"
    #cmpif    0x00800000 : if (((startflags >> CONFIG_PHY_BIT_SHIFT) & CONFIG_PHY_BIT_MASK) != (PHY_1M | PHY_2M)) then
    #cmpif    0x00800000 :     //Only allow 2M if SReg100 has bits 5&6 set (SReg100 is cached in var startflags)
    #cmpif    0x00800000 :     if (PhyTx & PHY_2M) == PHY_2M then
    #cmpif    0x00800000 :         PhyTx = PhyTx & (~PHY_2M)
    #cmpif    0x00800000 :     endif
    #cmpif    0x00800000 :     if PhyRx == PHY_2M then
    #cmpif    0x00800000 :         PhyRx = PhyRx & (~PHY_2M)
    #cmpif    0x00800000 :     endif
    #cmpif    0x00800000 : endif
    #cmpif    0x00800000 : //Prevent AUTO value in PhyTx and PhyRx
    #cmpif    0x00800000 : if PhyTx == PHY_AUTO then
    #cmpif    0x00800000 :     PhyTx = PHY_1M
    #cmpif    0x00800000 : endif
    #cmpif    0x00800000 : if PhyRx == PHY_AUTO then
    #cmpif    0x00800000 :     PhyRx = PHY_1M
    #cmpif    0x00800000 : endif
    #cmpif    0x00000010 : print "\n## BlePhySet(PhyTx = ";PhyTx;" PhyRx = ";PhyRx;")"
    #cmpif    0x00800000 : rc = BlePhySet(hConn, PhyTx, PhyRx, 0)
    #cmpifand 0x00800103 : AssertRC(5844)
endfunc 1

//==============================================================================
// This handler is called when the BLE PHY is updated
//==============================================================================
function  HandlerPhyUpdated(BYVAL hConn, BYVAL nStatus, BYVAL PhyTx, BYVAL PhyRx)
    #cmpif 0x00000010 : if nStatus == 0 then
    #cmpif 0x00000010 :     print "\n## BLE PHY UPDATED: (PhyTx = ";PhyTx;" PhyRx = ";PhyRx;")"
    #cmpif 0x00000010 : else
    #cmpif 0x00000010 :     print "\n## BLE PHY UPDATE FAIL: ";integer.h' nStatus
    #cmpif 0x00000010 : endif

    //Get connection index from conn handle and send async response if non-VSP
    tmpVar = GetIdxFromHConn(hConn)
    if tmpVar != HCONN_VSP then
        if nStatus == 0 then
            sprint #tmpVar$, "\nPU:";tmpVar;", ";PhyTx;", ";PhyRx;"\r"
        else
            sprint #tmpVar$, "\nPF:";tmpVar;", ";nStatus;"\r"
        endif
        SendUartDataEx(tmpVar$)
    endif
endfunc 1

//==============================================================================
// This handler is called when extended adverts have stopped because of max count
//==============================================================================
function HndlrExtAdvEnd(setid, reason) as integer
    tmpVar$ = "\nAE:\r"
    SendUartDataEx(tmpVar$)
endfunc 1

//==============================================================================
// On ERROR handler
//==============================================================================
sub HandlerOnErr()
    #cmpif 0x00400000 : UartReOpen()
    #cmpif 0x00000001 : print "\nOnErr - ";GetLastError();"\n"
    #cmpif 0x00000001 : //Wait for Tx buffer to flush
    #cmpif 0x00000001 : while UartInfo(5) > 0
    #cmpif 0x00000001 : endwhile
    #cmpif 0x00040000 : reset(0)
endsub

//==============================================================================
// This handler is called when there is an NFC event
//==============================================================================
#cmpif 0x00020000 : function HandlerNfc(msgid) as integer
#cmpif 0x00020000 :     // Send an asynchronous response only in certain states and certainly
#cmpif 0x00020000 :     // not when in a VSP connection.
#cmpif 0x00020000 :     select curState
#cmpif 0x00020000 :     case STATE_IDLE_nonVSP, STATE_IDLE_VSP, STATE_SCAN_VSP, STATE_nonVSP_CONNECTED
#cmpif 0x00020000 :         select(msgid)
#cmpif 0x00020000 :         case NFC_MSGIN_NFCFIELDOFF
#cmpif 0x00020000 :             tmpVar$ = "\nNS:0\r"
#cmpif 0x00200000 :             nfcSenseCnt = nfcSenseCnt + 1
#cmpif 0x00020000 :
#cmpif 0x00020000 :         case NFC_MSGIN_NFCFIELDON
#cmpif 0x00020000 :           tmpVar$ = "\nNS:1\r"
#cmpif 0x00200000 :           nfcSenseCnt = nfcSenseCnt + 1
#cmpif 0x00020000 :
#cmpif 0x00020000 :         case NFC_MSGIN_NFCTAGREAD
#cmpif 0x00020000 :           tmpVar$ = "\nNR\r"
#cmpif 0x00200000 :           nfcReadCnt = nfcReadCnt + 1
#cmpif 0x00020000 :
#cmpif 0x00020000 :         case else
#cmpif 0x00020000 :           exitfunc 1
#cmpif 0x00020000 :         endselect
#cmpif 0x00020000 :         SendUartDataEx(tmpVar$)
#cmpif 0x00020000 :     case else
#cmpif 0x00020000 :     endselect
#cmpif 0x00020000 : endfunc 1

//------------------------------------------------------------------------------
// The UART low power operation timer has expired
//------------------------------------------------------------------------------
#cmpif    0x00400000 : function HndlrTmrLowPwrUart()
#cmpifand 0x00400104 :     DbgMsg("Uart Tmr EXPIRE")
#cmpif    0x00400000 :     //If in the meantime the timer was restarted do nothing
#cmpif    0x00400000 :     if TimerRunning(TMRNUM_LOWPWR_UART) == 0 then
#cmpif    0x00400000 :         //The buffers have to empty and transmit register should be empty too
#cmpif    0x00400000 :         UartCloseConditional()
#cmpif    0x00400000 :     endif
#cmpif    0x00400000 : endfunc 1


//==============================================================================
// Use Button1 for debugging
//==============================================================================
#cmpif 0x00000200 : function HandlerButton1() as integer
#cmpif 0x00000200 :     print "\n## B1:"
#cmpif 0x00000200 :     //The following empty line is just to make it easier to add new debugging lines
#cmpif 0x00000200 :
#cmpif 0x00000200 :
#cmpif 0x00000200 :
#cmpif 0x00000200 :
#cmpif 0x00000200 :
#cmpif 0x00000200 : endfunc 1

//==============================================================================
// Use Button2 for debugging
//==============================================================================
#cmpif 0x00000200 : function HandlerButton2() as integer
#cmpif 0x00000200 :     print "\n## B2:";curState;", ";UARTRecBuf$
#cmpif 0x00000200 :
#cmpif 0x00000200 :     //Print "\n = BTN = ";vtxcnt
#cmpif 0x00000200 :     //vtxcnt = 0
#cmpif 0x00000200 :     //vrxcnt = 0
#cmpif 0x00000200 :
#cmpif 0x00000200 : endfunc 1

//******************************************************************************
//Setup event handlers
//******************************************************************************
OnError NEXT HandlerOnErr

OnEvent EVBLEMSG                             Call HndlrBleMsg
OnEvent EVUARTRX                             Call HndlrUartCommand
OnEvent EVBLE_SCAN_TIMEOUT                   Call HndlrScanTimeout
OnEvent EVBLE_ADV_REPORT                     Call HndlrAdvReport
OnEvent EVMSGAPP                             Call HndlrMessageApp
OnEvent EVBLE_CONN_TIMEOUT                   Call HndlrConnTout
OnEvent EVDISCON                             Call HndlrDisCon
OnEvent EVFINDDESC                           Call HndlrFindDesc
OnEvent EVFINDCHAR                           Call HndlrFindChar
OnEvent EVATTRWRITE                          Call HandlerAttrWrite
OnEvent EVATTRREAD                           Call HndlrAttrRead
OnEvent EVTMR0                               Call HndlrTmrWaitEncr
OnEvent EVDETECTCHAN0                        Call HndlrVspCmdMode
OnEvent EVCHARHVC                            Call HndlrCharHvc
OnEvent EVCHARVAL                            Call HndlrCharVal
OnEvent EVCHARCCCD                           Call HndlrCharCccd
OnEvent EVCHARSCCD                           Call HndlrCharSccd
//OnEvent EVCHARDESC                           Call HndlrCharDesc   //FUTURE

OnEvent  EVBLE_EXTADV_RPT                    Call HndlrExtAdvRpt
OnEvent  EVBLE_EXTSCN_RPT                    Call HndlrExtScnRpt
OnEvent  EVBLE_EXTADV_END                    Call HndlrExtAdvEnd

#cmpif 0x00020000 : OnEvent EVDISCPRIMSVC    Call HandlerPrimSvc
#cmpif 0x00020000 : OnEvent EVDISCCHAR       Call HandlerCharDisc
#cmpif 0x00020000 : OnEvent EVDISCDESC       Call HandlerDescDisc

OnEvent EVPACKETLENGTH                       Call HandlerPacketLength
OnEvent EVATTRIBUTEMTU                       Call HandlerAttrMTU
OnEvent EVBLE_PHY_REQUEST                    Call HandlerPhyRequest
OnEvent EVBLE_PHY_UPDATED                    Call HandlerPhyUpdated
OnEvent EVBLE_AUTHKEY                        Call HandlerAuthKey
OnEvent EVBLE_PASSKEY                        Call HandlerPassKey

OnEvent EVPACKETLENGTHLIMITED                Call HandlerPacketLengthLimited
#cmpif 0x80000000 : OnEvent EVTXPOWERLIMITED Call HandlerTxPowerLimited
OnEvent EVBLEAUTHINFO                        Call HandlerAuthInfo
OnEvent EVBLESECREQUEST                      Call HandlerSecurityRequest
OnEvent EVBLEOVERWRITEBOND                   Call HandlerOverwriteBond

#cmpif 0x00200000 : OnEvent EVNFC            Call HandlerNfc

//Override GPIO detect change handler if UART low operation is enabled
#cmpif 0x00400000 : OnEvent EVDETECTCHAN0    Call HndlrReopenUart
#cmpif 0x00400000 : OnEvent EVTMR1           Call HndlrTmrLowPwrUart

#cmpif 0x00000200 : OnEvent EVGPIOCHAN0      Call HandlerButton2
#cmpif 0x00000200 : OnEvent EVGPIOCHAN1      Call HandlerButton1

//******************************************************************************
// Start-up code from here is equivalent to main() in a 'C' application
//******************************************************************************
Startup()

//******************************************************************************
//Wait in a lower-power mode for an event to occur
//******************************************************************************
WAITEVENT
